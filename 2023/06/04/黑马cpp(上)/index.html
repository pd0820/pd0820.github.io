<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <script type="text/javascript" src="/love.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="总结cpp中最基础的操作，以便忘了一看就能记起来。">
<meta property="og:type" content="article">
<meta property="og:title" content="黑马C++（上）">
<meta property="og:url" content="http://example.com/2023/06/04/%E9%BB%91%E9%A9%ACcpp(%E4%B8%8A)/index.html">
<meta property="og:site_name" content="仓中鼠的博客">
<meta property="og:description" content="总结cpp中最基础的操作，以便忘了一看就能记起来。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306010942357.png">
<meta property="og:image" content="https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306021105407.png">
<meta property="og:image" content="https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306021115489.png">
<meta property="article:published_time" content="2023-06-04T10:41:18.000Z">
<meta property="article:modified_time" content="2023-06-04T10:59:14.010Z">
<meta property="article:author" content="仓中鼠">
<meta property="article:tag" content="常识">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306010942357.png">

<link rel="canonical" href="http://example.com/2023/06/04/%E9%BB%91%E9%A9%ACcpp(%E4%B8%8A)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>黑马C++（上） | 仓中鼠的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <a target="_blank" rel="noopener" href="https://github.com/pd0820" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">仓中鼠的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录美好生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">7</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/04/%E9%BB%91%E9%A9%ACcpp(%E4%B8%8A)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="仓中鼠">
      <meta itemprop="description" content="仓中鼠，食积粟，居大庑之下，不见人犬之忧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="仓中鼠的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          黑马C++（上）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 18:41:18 / 修改时间：18:59:14" itemprop="dateCreated datePublished" datetime="2023-06-04T18:41:18+08:00">2023-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>
            <div class="post-description">总结cpp中最基础的操作，以便忘了一看就能记起来。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="黑马C"><a href="#黑马C" class="headerlink" title="黑马C++"></a>黑马C++</h4><hr>
<h5 id="一、第一天"><a href="#一、第一天" class="headerlink" title="一、第一天"></a>一、第一天</h5><pre><code class="cpp"># include &lt;iostream&gt;  //标准的输入输出流 in输入 out输出
using namespace std;  //使用命名空间 std 打开一个叫std的房间

//程序入口
int main(void)
&#123;
    // cout 标准的输出
    // &lt;&lt; 拼接的作用
    // endl 结束换行并刷新缓冲区
    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; 123 &lt;&lt; endl;
    system(&quot;pause&quot;);  //阻塞功能
    return EXIT_SUCCESS;  //返回正常退出
&#125;
</code></pre>
<h6 id="1-1-双冒号作用域运算符"><a href="#1-1-双冒号作用域运算符" class="headerlink" title="1.1 双冒号作用域运算符"></a>1.1 双冒号作用域运算符</h6><p><code>::</code>:作用域运算符有两种用法</p>
<p>1、作用域::变量名或其它名</p>
<pre><code class="cpp">eg:
std::cout (用了这个，就不用using namespace std;了)
</code></pre>
<p>2、</p>
<p>::变量名</p>
<pre><code class="cpp">int atk = 200;
void test01(void)
&#123;
    int atk = 100;
    cout &lt;&lt; &quot;攻击力：&quot; &lt;&lt; atk &lt;&lt; endl;
    // ::双冒号（作用域运算符 :: 全局作用域）
    cout &lt;&lt; &quot;全局攻击力：&quot; &lt;&lt; ::atk &lt;&lt; endl;
&#125;
输出结果：
----------------
攻击力：100
全局攻击力：200
----------------
</code></pre>
<h6 id="1-2-namespace-命名空间"><a href="#1-2-namespace-命名空间" class="headerlink" title="1.2 namespace(命名空间)"></a>1.2 namespace(命名空间)</h6><p><strong>用途</strong>：解决命名冲突问题<br>        <strong>注意</strong>：必须在全局作用域下声明<br>        <strong>内容</strong>：命名空间中可以放入函数，变量，结构体，类（命名空间还可以嵌套命名空间）<br>        <strong>另外</strong>：命名空间是开放的，可以随时加入新的成员；且命名空间可以起别名</p>
<h6 id="1-3-using的使用"><a href="#1-3-using的使用" class="headerlink" title="1.3 using的使用"></a>1.3 using的使用</h6><p>1、使用using时，要避免局部变量与之冲突</p>
<p>2、就近原则的优先级高于“打开房间”这个操作</p>
<p>3、用using打开两个房间，会导致程序不知道用哪个</p>
<h6 id="1-4-cpp对c语言的增强"><a href="#1-4-cpp对c语言的增强" class="headerlink" title="1.4 cpp对c语言的增强"></a>1.4 cpp对c语言的增强</h6><pre><code class="cpp">* 全局变量检测增强

* 函数检测增强:形参前必须要有类型;若定义函数名前不是void，则必须要有返回值;函数调用参数检测增强;

* 类型转换检测增强

* 结构体(struct)增强:cpp中结构体可以放函数,C语言中构造结构体用struct Person p1;cpp中可以直接用Person p1;

* 相比C语言新增bool类型:bool flag = true;

* 三目运算符的增强a&gt;b ? a : b = 100; b的值会被改成100(三目运算符中C语言返回的是值，cpp返回的是变量)
</code></pre>
<h6 id="1-5-const-常量"><a href="#1-5-const-常量" class="headerlink" title="1.5 const(常量)"></a>1.5 const(常量)</h6><p><strong>1、const不分配内存，但取地址会分配临时内存</strong></p>
<p>c语言中，const修饰的变量，是伪常量，编译器是会分配内存的（可以用指针修改）</p>
<p>cpp中，const不会分配内存，而是放在符号表中</p>
<p>eg: <code>const int n_a = 10；</code><strong>（基本上只有这个方式，不会分配内存，而是放到符号表中）</strong></p>
<table>
<thead>
<tr>
<th align="center">key(键值)</th>
<th align="center">value(实值)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">n_a</td>
<td align="center">10</td>
</tr>
</tbody></table>
<pre><code class="cpp">const int b = 20;
int* p = (int*)&amp;b;
*p = 200;
cout &lt;&lt; b &lt;&lt; endl;
cout &lt;&lt; *p &lt;&lt; endl;
输出结果：
20
200

为什么会输出200？
在int* p = (int*)&amp;b;中编译器会临时开辟一块内存空间；
相当于：
int tmp = b;  //给tmp分配了一块内存空间，将b的值赋给它
int* p = (int *)&amp;tmp;  //*p指向的是临时的那块空间
</code></pre>
<p><strong>2、用extern  编译器也会给const变量分配内存</strong></p>
<p>C语言中，默认const是外部链接</p>
<p>cpp中，默认const是内部链接（即只有在当前文件夹内才能访问）</p>
<p>如果想提高const的作用域，用<code>extern</code></p>
<p><code>extern const int a = 10;</code>(可将const转换为外部链接)</p>
<p><strong>3、用变量初始化const变量</strong></p>
<pre><code class="cpp">int a = 10;
const int b = a;  //会分配内存
</code></pre>
<p><strong>注意：只要是分配内存的，都能用指针修改它</strong></p>
<p><strong>4、自定义数据类型分配内存</strong></p>
<pre><code class="cpp">struct Person
&#123;
    string m_Name;
    int m_Age;
&#125;
</code></pre>
<p><strong>5、尽量用const来代替#define</strong></p>
<pre><code class="cpp">在旧版本c中，如果想建立一个常量，必须使用预处理器
#define MAX 1024;
我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX都已经被替换为了1024
因此，并没有将MAX加入到符号表中。但如果我们使用这个常量获得一个错误的编译错误信息时，
我们看到的是1024而非MAX。若MAX被定义在一个不是我写的头文件中，我可能不知道1024意味着什么，
为了解决这个问题可能要花费很长时间。
解决办法就是用一个常量替换上面的宏
const MAX = 1024;
1.const有类型，可进行编译器安全检查
2.const有作用域，而#define默认是从定义处到程序结束
</code></pre>
<h6 id="1-6-引用"><a href="#1-6-引用" class="headerlink" title="1.6 引用"></a>1.6 引用</h6><p><strong>1、引用的实质就是起别名(<code>类型 &amp;别名 = 原名;</code>)</strong></p>
<pre><code class="cpp">int a = 10;
int &amp;b = a;就是给变量a取一个别名b(实质：int* const b = &amp;a ;b存放的是a的地址)
(当使用b时,eg:b = 10;实质上是:*b = 10;)
(&amp;写到等号左侧，叫引用；写到右侧，就是取地址符)
</code></pre>
<p><strong>2、引用初始化后不可修改</strong></p>
<p>即b做了a的别名以后，不能再做c的别名</p>
<ul>
<li>对数组建立引用</li>
</ul>
<pre><code class="cpp">int arr[10];
for (int i=0; i&lt;10; ++i)
&#123;
    arr[i] = i;
&#125;
//第一种方式
int (&amp;pArr)[10] = arr;
for (int i; i&lt;10; ++i)
&#123;
    cout &lt;&lt; pArr[i] &lt;&lt; &quot; &quot;;
&#125;
cout &lt;&lt; endl;
//第二种方式
typedef int(ARRAYREF)[10];  //一个具有十个元素的int类型数组
ARRAYREF &amp;pArr2 = arr;
for (int i = 0; i &lt; 10; ++i)
&#123;
    cout &lt;&lt; pArr2[i] &lt;&lt; &quot; &quot;;
&#125;
cout &lt;&lt; endl;
</code></pre>
<p><strong>3、引用的注意事项</strong></p>
<ul>
<li><p>引用必须引一块合法(存在、能引用)的内存空间</p>
</li>
<li><p>不要返回局部变量的引用</p>
</li>
</ul>
<p><strong>4、引用的本质(是一个指针常量)</strong></p>
<pre><code class="cpp">int a = 10;
int&amp; aRef = a;  //自动转换为int* const aRef = &amp;a;这也能说明为什么必须初始化
aRef = 20;  //内部发现aRef是引用，自动帮我们转换为：*aRef = 20；`````````````````````
</code></pre>
<p><strong>5、常量引用</strong></p>
<pre><code class="cpp">//int&amp; ref = 10;  //引用了不合法的内存
const int&amp; ref = 10;  //加入const后，编译器处理方式为：int tmp = 10;const int &amp;ref = tmp;
//ref = 10;
int* p = (int*)&amp;ref;
*p = 1000;
cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;
输出结果：
----------------
ref = 1000
----------------
</code></pre>
<p><strong>6、用一级指针引用可以代替二级指针</strong></p>
<pre><code class="cpp">void f(int &amp;p)  //主调函数传过来一个值，用&amp;能直接提取该值的地址
&#123;
    ;
&#125;
//在C++中，当我们将一个值作为参数传递给函数时，实际上会发生参数的复制。复制操作会创建一个新的变量，该变量具有与原始值相同的值。
//当我们在函数参数中使用&amp;（取地址符）时，它表示取得该变量的内存地址。通过使用&amp;，我们可以获取原始值的地址，而不是复制后的值的地址。
//这种通过引用获取原始值地址的机制称为引用传递（pass by reference），它允许函数在不进行复制的情况下直接访问和修改原始值。
</code></pre>
<p><strong>7、使用场景：修饰形参为只读（防君子不防小人）</strong></p>
<pre><code class="cpp">void showValue(const int &amp;val)
&#123;
    val += 1000;  //如果只是想显示内容，而不修改内容，那么就用const修饰这个形参
    cout &lt;&lt; &quot;val = &quot; &lt;&lt; val &lt;&lt; endl;
&#125;
</code></pre>
<p><strong>8、注意：const int &amp;a &#x3D; 10;会分配内存</strong></p>
<h5 id="二、第二天"><a href="#二、第二天" class="headerlink" title="二、第二天"></a>二、第二天</h5><h6 id="2-1-class"><a href="#2-1-class" class="headerlink" title="2.1 class"></a>2.1 class</h6><pre><code class="cpp">类的创建
class 类名
&#123;
public:  //公共权限
//设置成员属性
//设置成员函数
&#125;;
实例化对象
类名 对象名;
通过对象来设置属性，调用成员函数
    **类是对对象的抽象
对象是对类的实例**
</code></pre>
<h6 id="2-2-内联函数-用于代替C语言中的预处理宏"><a href="#2-2-内联函数-用于代替C语言中的预处理宏" class="headerlink" title="2.2 内联函数(用于代替C语言中的预处理宏)"></a>2.2 内联函数(用于代替C语言中的预处理宏)</h6><p>宏：</p>
<pre><code class="cpp">C语言为什么要用宏？
答：我们在编程时，有一些很短但是执行频繁的计算；因为太短了，我不想写成函数，又可以避免函数调用的开销，所以用宏。

但是宏有不小的缺点，宏的缺点如下：
1、运行结果与预想的不符(宏看起来像一个函数调用，但会隐藏一些难以发现的错误)
eg:
定义一个加法
#define MyADD(x, y) x+y
void test01()
&#123;
    int ret = MyADD(10, 20) * 20;
    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;
&#125;
输出结果：
-------------
ret = 410
-------------
可以预想到实际运行的是x+y*20 = 410

优化一下（把括号加上，避免算数优先级导致问题）：
#define MyCompare(a, b) ((a) &lt; (b)) ? (a) : (b)
void test02()
&#123;
    int a = 10;
    int b = 20;
    int ret = MyCompare(++a, b);

    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;
&#125;
输出结果：
-------------
ret = 12
-------------
还是与预想的11不符

2、在cpp中，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类的成员函数
</code></pre>
<p>内联函数：</p>
<pre><code class="cpp">内联函数定义
inline 函数定义
eg：
inline void mycompare(int a, int b)
&#123;
    int ret = a &lt; b ? a : b
    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;
&#125;

内联函数注意事项：
inline void func();  //内联函数声明
inline void func()
&#123; 
    ; 
&#125;  //如果函数实现的时候，没有加inline关键字，那么这个函数依然不算内联函数

内联函数的优点：
&quot;以空间换时间&quot;（内联函数除了没有宏的缺点外，基本可以当做宏来使用）

内联函数与class：
在class(类)中，成员函数默认都是加了内联函数关键字(inline)的

内联函数与编译器：
内联函数只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有
将函数声明为内联函数，编译器也可能将小的，简单的函数声明为内联函数；
在这些情况下，编译器不会将inline关键字修饰的函数当内联函数处理
1.不能存在任何形式的循环语句
2.不能存在过多的条件判断语句
3.函数体不能过于庞大
4.不能对函数进行取址操作
</code></pre>
<h6 id="2-3-函数的默认参数"><a href="#2-3-函数的默认参数" class="headerlink" title="2.3 函数的默认参数"></a>2.3 函数的默认参数</h6><pre><code class="cpp">//函数的默认参数 参数后面 = ......
//函数参数的注意事项，如果有一个位置有了默认参数，那么从这个位置开始，从左往右都必须有默认参数
void func(int a =10, int b, int c =1)  //a有了默认参数，a右边的b没有，报错
&#123;
    cout &lt;&lt; &quot;ａ+ b + c = &quot; &lt;&lt; a + b + c&lt;&lt; endl;
&#125;
void test01()
&#123;
    func(1, 2, 3);
&#125;
注意:
//函数声明里面有了默认参数，那么函数实现的时候必须没有
//函数声明和实现中，只能有一个默认参数，不要同时出现，因为我可能写的不一样，编译器不知道用哪个
void myFunc(int a = 10, int b = 10);
void myFunc(int a = 10, int b = 10)&#123;&#125;
报错：重定义默认参数
</code></pre>
<p>附加：占位参数</p>
<pre><code class="cpp">//函数 占位参数
//如果有了占位参数，函数调用时候必须要提供这个参数，但是用不到这个参数
//占位参数 没有什么用 只有后面重载 ++符号才有一点用
//占位参数 可以有默认值
void func2(int a, int)
&#123;

&#125;
void test02()
&#123;
    func2(10, 1);
&#125;
</code></pre>
<h6 id="专题：函数重载-overload"><a href="#专题：函数重载-overload" class="headerlink" title="专题：函数重载(overload)"></a>专题：函数重载(overload)</h6><p>实现函数重载的条件</p>
<p>1、同一个作用域</p>
<p>2、参数个数不同or参数类型不同or参数顺序不同</p>
<p>3、返回值类型不能作为函数重载的条件（因为调用函数时eg：func(a,b);无法区分到底用不用返回值）</p>
<p>4、当函数重载碰到了默认参数时，要注意避免二义性问题</p>
<pre><code class="cpp">eg:
void func2(int a, int b = 10)
&#123;

&#125;
void func2(int a)
&#123;

&#125;
</code></pre>
<p>5、const也可以作为重载的条件</p>
<pre><code class="cpp">void func3(const int &amp;a)  //引用必须要引合法的内存空间//const也可以作为重载的条件
&#123;

&#125;
void test03()
&#123;
    int a = 10;
    func3(10);
&#125;
</code></pre>
<p>函数重载的原理</p>
<pre><code class="cpp">为实现函数重载，不同的编译器会用不同的机制来修饰函数名
如：void func(),编译器内部可能会将其修饰为_func;
void func(int x),编译器内部可能将其修饰为_func_int;
void func(int x, cahr c),编译器内部可能将其修饰为_func_int_char
</code></pre>
<h6 id="2-4-extern-“C”浅析"><a href="#2-4-extern-“C”浅析" class="headerlink" title="2.4 extern “C”浅析"></a>2.4 extern “C”浅析</h6><pre><code class="cpp">解决的问题 在C++中调用C语言的函数(由于函数重载，C++中编译器可能会把函数名改掉)
(C++比C语言多了些特性，所以直接调用可能会出问题，用下面的方式能屏蔽C++的特性，用C语言的语法规则使用函数)

调用多个：
#ifdef __cplusplus
extern &quot;C&quot; &#123;
#endif
......(C语言的函数 eg: void func(); )
#ifdef __cplusplus
&#125;
#endif

调用单个:
extern &quot;C&quot; void func();
</code></pre>
<h6 id="专题：封装"><a href="#专题：封装" class="headerlink" title="专题：封装"></a>专题：封装</h6><p><strong>1、属性和行为作为一个整体来表示生活中的事物</strong></p>
<p>（与C语言相区分，C语言中strucrt中不能放函数，就可能造成“人”的行为作用到“狗”的属性上）</p>
<p><strong>2、在c++中struct和class是一个意思，唯一的不同，默认权限， struct是public，而class默认权限是private</strong></p>
<p><strong>3、私有权限(private)  就是私有成员，在类内部可以访问，类外部不可访问<br>公共权限(public)  在类内部和外部都可以访问<br>保护权限(protected)  类内部可以访问（以及当前类子类可以访问），类外部不可以访问</strong></p>
<p><strong>建议：将所有成员变量都设置为private，对外提供读或写的接口</strong></p>
<h5 id="三、第三天"><a href="#三、第三天" class="headerlink" title="三、第三天"></a>三、第三天</h5><h6 id="3-1-分文件编写"><a href="#3-1-分文件编写" class="headerlink" title="3.1 分文件编写"></a>3.1 分文件编写</h6><p><code>.h</code>中写类的成员函数的申明（一般要添加标准的输入输出流和命名空间std）</p>
<p><code>.cpp</code>中写成员函数的实现，其中该成员函数要以<code>作用域::成员函数的形式</code></p>
<p>可以用<code>#pragme once</code>避免头文件被重复包含</p>
<h6 id="3-2-对象的构造-初始化-与析构-清理"><a href="#3-2-对象的构造-初始化-与析构-清理" class="headerlink" title="3.2 对象的构造(初始化)与析构 (清理)"></a>3.2 对象的构造(初始化)与析构 (清理)</h6><p>1、对象的初始化与清理</p>
<pre><code class="cpp">当定义了一个类后
Person p1;  
程序员若没有提供构造函数和析构函数
编译器就默认调用了构造函数和析构函数，但此时构造函数和析构函数是系统提供的两个空实现的函数

构造函数：
1.与类名相同,没有返回值，不写void，可以发生重载（即可以有参数，可以有多个构造函数）
2.构造函数由编译器自动调用，而不是手动，而且只会调用一次

3.
eg:
Person()
&#123;
    cout &lt;&lt; &quot;构造函数的调用&quot; &lt;&lt; endl;
&#125;

析构函数：
1.与类名相同，类名前面加一个符号 &quot;~&quot;，也没有返回值，不写void，不可以有参数（不能发生函数重载）
2.析构函数由编译器自动调用，而不是手动，而且只会调用一次
3.构函数调用于主调函数结束之后。所以如果是在main函数中调用，要等函数全部执行完才调用，我们就看不到。
4.
eg:
~Person()
&#123;
    cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;
&#125;
注意：构造和析构必须写在public下
</code></pre>
<p>2、构造函数的分类及调用</p>
<pre><code class="cpp">1.按照参数有无进行分类:
无参构造函数的写法：
Person()  //无参构造函数又叫默认构造函数
&#123;
    cout &lt;&lt; &quot;无参构造函数调用&quot; &lt;&lt; endl;
&#125;
无参构造函数的调用：
Person p1;(注意：不要写成 Person p1(); 编译器会把这个当做是函数声明
有参构造函数的写法：
Person(int a)
&#123;
    cout &lt;&lt; &quot;有参构造函数调用&quot; &lt;&lt; endl;
&#125;
有参构造函数的调用：
Person p2(10);   or   Person p2 = Person(10);

**附加知识点**
Person(10)； 匿名对象，执行当前行后就会释放这个对象（注意与上面的区分）

2.按照类型进行分类
普通构造函数（就是上面的无参和有参）
拷贝构造函数的写法
Person(const Person&amp; p)//因为是“拷贝”，不让修改，所以加const
&#123;
    m_Age = p.m_Age;
    cout &lt;&lt; &quot;拷贝构造函数调用&quot; &lt;&lt; endl;
&#125;
拷贝构造函数的调用
Person p1(p2);   or   Person p1 = Person(p2);

注意：不能用拷贝构造函数初始化匿名对象（因为拷贝构造函数需要一个对象名来作为参数）
eg：
Person(p5);  //如果这么写，编译器会认为你写的是 Person p5; 即对象的声明
</code></pre>
<blockquote>
<p>注意：拷贝构造函数并不是把一个对象直接复制给另一个对象，拷贝构造函数仅仅是将一个对象的地址传给另一个对象，至于如何操作，是复制还是什么具体要自己实现</p>
</blockquote>
<p>注意：隐式类型转换</p>
<pre><code class="cpp">Person p7 = 100;  //相当于调用了Person p7 = Person(100);  隐式类型转换
Person p8 = p7;  //相当于调用了Person p8 = Person(p7);  隐式类型转换
</code></pre>
<p>3、拷贝构造函数调用时机</p>
<p>（1）用已经创建好的对象来初始化新的对象</p>
<pre><code class="cpp">void test01()
&#123;
    Person p1;
    p1.m_Age = 10;
    Person p2 = Person(p1);
&#125;
</code></pre>
<p>（2）以值传递的方式给函数的参数传值</p>
<pre><code class="cpp">void doWork(Person p1)  //Person p1 = Person(p);
&#123;

&#125;
void test02()
&#123;
    Person p;
    p.m_Age = 10;
    doWork(p);
&#125;
</code></pre>
<p>（3）以值方式返回局部对象</p>
<pre><code class="cpp">Person doWork2()
&#123;
    Person p1;
    return p1;
&#125;
void test03()
&#123;
    Person p = doWork2();
&#125;
</code></pre>
<p>4、构造函数的调用规则</p>
<p>默认情况下，c++编译器至少为我们写的类提供三个函数</p>
<p>1.默认构造函数（无参，函数体为空）</p>
<p>2.默认析构函数（无参，函数体为空）</p>
<p>3.默认拷贝构造函数，<strong>对类中非静态成员属性简单值拷贝</strong></p>
<p>注意：当用户定义了有参的构造，系统就不会提供默认构造函数，但是会提供拷贝构造函数</p>
<p>注意：当用户定义了拷贝构造，c++就不会提供其它构造函数</p>
<h6 id="3-3-深拷贝和浅拷贝"><a href="#3-3-深拷贝和浅拷贝" class="headerlink" title="3.3 深拷贝和浅拷贝"></a>3.3 深拷贝和浅拷贝</h6><p>由于&amp;的特性，浅拷贝即通常的拷贝构造函数的拷贝，仅仅是“取别名”，本质上是只复制了被拷贝的变量的地址,原对象和浅拷贝对象会共享相同的数据。</p>
<p>系统默认提供的拷贝构造，会进行简单的值拷贝</p>
<p>如果属性里有指向堆区空间的数据，那么简单的浅拷贝会导致重复释放内存的异常</p>
<p>解决上述问题，需要我们自己提供拷贝构造函数，进行深拷贝</p>
<h6 id="3-4-初始化列表"><a href="#3-4-初始化列表" class="headerlink" title="3.4 初始化列表"></a>3.4 初始化列表</h6><p>利用初始化列表来初始化数据</p>
<p>在构造函数后面 + ： 属性（值 or 参数），属性（值 or 参数）…</p>
<p><strong>是值就是赋值给前面的属性，是参数就是传参给前面的属性</strong></p>
<pre><code class="cpp">//第一种
Person() : m_A(10),m_B(20), m_C(30)
&#123;

&#125;  //相当于m_A = 10;前提是Person类中要有m_A这个成员属性
//第二种
Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c)
&#123;

&#125;  //相当于m_A = a;前提是Person类中要有m_A这个成员属性
//想初始化哪个值初始化哪个值，没有说三个数都要写上去
</code></pre>
<h6 id="3-5-类对象作为类成员"><a href="#3-5-类对象作为类成员" class="headerlink" title="3.5 类对象作为类成员"></a>3.5 类对象作为类成员</h6><p>&#x3D;&#x3D;当类对象作为类成员时，构造顺序是先构造类对象的构造，然后构造自己&#x3D;&#x3D;</p>
<blockquote>
<p>这是为了确保成员函数在使用前已经被正确初始化</p>
</blockquote>
<p>&#x3D;&#x3D;析构顺序与构造相反&#x3D;&#x3D;</p>
<blockquote>
<p>这是为了确保在对象的析构函数执行时，成员对象仍然是有效的。</p>
<p>这样可以保证在成员对象的析构函数中，可以正确地处理和释放它们所占用的资源。</p>
</blockquote>
<h6 id="专题：explicit-显式"><a href="#专题：explicit-显式" class="headerlink" title="专题：explicit(显式)"></a>专题：explicit(显式)</h6><p>explicit关键字，放在函数名前，防止隐式类型转换</p>
<pre><code class="cpp">eg：explicit MyString(int a)
&#123;
    mSize = a;
&#125;
</code></pre>
<h6 id="3-6-new关键字"><a href="#3-6-new关键字" class="headerlink" title="3.6 new关键字"></a>3.6 new关键字</h6><pre><code class="cpp">//用于在动态存储区（堆）上分配内存，创建动态对象，并返回指向该对象的指针。
//用于创建对象、动态数组或分配其他类型的动态内存
void test02()
&#123;
    //开辟到堆区
    Person* p1 = new Person;
    Person* p2 = new Person(10);
    Person* p3 = new Person(*p2);
    //释放new出来的对象
    delete p1;
    delete p2;
    delete p3;
&#125;
//1.malloc与new的区别
//malloc是一个库函数，new是一个运算符
//malloc返回值是void*，new返回值是new出来的对象的指针
//malloc要看是否开辟成功，而new内部做好了该操作（内部会malloc数据在堆区，判断内存是否分配成功，调用构造函数）
//malloc不会调用构造函数，new会调用构造函数
//malloc对应的释放是free，new对应的释放是delete
//2.注意事项
//不要用void*万能指针去接受new出来的对象，原因是不能释放
//3.利用new创建数组
// int* pInt = new int[10];//调用10次默认构造函数
// 在堆区创建数组时，类中必须要存在默认构造函数，否则无法创建
// Person* persons = new Person[10];
// 如果是数组，释放的时候要在delete后加[]
// delete [] persons;
// 如果数组是在栈上开辟，那么可以指定利用哪个构造函数来初始化对象
// Person Persons2[3] = &#123; person(10),person(10),person(10) &#125;;
</code></pre>
<h6 id="3-7-静态成员变量"><a href="#3-7-静态成员变量" class="headerlink" title="3.7 静态成员变量"></a>3.7 静态成员变量</h6><p>在一个类中，若将一个成员变量声明为static，这种成员称为静态变量成员，与一般的数据成员不同，<u>无论建立了多少对象，所有对象共享这个静态成员变量</u>；静态成员变量，属于某个类，所有对象共享</p>
<blockquote>
<p>静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间，所以比main函数还先调用</p>
</blockquote>
<p><strong>1.静态成员变量必须在类中声明，在类外定义</strong>（主要是为了避免多次定义静态成员变量）</p>
<pre><code class="cpp">原因：调用静态成员变量有两种方式：
分别是用类名
eg: Person::m_Age;
和对象名
eg: P1.m_Age;
若静态成员变量在类内定义，若定义在构造函数中，
用对象名的方式，显然能调用构造函数
但用类名的方式，则不会调用构造函数，此时，静态成员变量就没有初始化
</code></pre>
<p>静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间</p>
<p><strong>注意：静态成员变量也是有权限的</strong></p>
<pre><code class="cpp">private:
    static int m_other; //私有权限 在类外不能访问
&#125;;
//但是：
int Person::m_other = 10; //类外初始化却是可以的，因为编译器会算作你这一条语句写在了Person类里面
</code></pre>
<p><strong>2.静态数据成员可以通过类名或者对象名来引用</strong></p>
<p><strong>3.静态成员变量，属于某个类的所有对象共享</strong></p>
<h6 id="3-8-静态成员函数"><a href="#3-8-静态成员函数" class="headerlink" title="3.8 静态成员函数"></a>3.8 静态成员函数</h6><p>基本和静态成员变量一样</p>
<p><strong>但是：静态成员函数不可以访问普通的成员变量</strong>（因为没有编译器没有自动添加this指针）</p>
<pre><code class="cpp">原因：
静态成员函数由类的所有对象共享。
当静态成员函数访问了普通的成员变量时，
每一个对象都有该普通成员变量，并且他们的值不一定相等
静态成员函数就会分不清要调用哪一个
</code></pre>
<p><strong>可以访问静态成员变量，因为静态成员变量也只有一份</strong></p>
<p><strong>普通成员函数，可以访问普通成员变量，也可以访问静态成员变量</strong></p>
<h6 id="3-9-静态成员实现单例模式"><a href="#3-9-静态成员实现单例模式" class="headerlink" title="3.9 静态成员实现单例模式"></a>3.9 静态成员实现单例模式</h6><p>单例模式：一个类中只有唯一的一个实例对象。</p>
<blockquote>
<p>私有化默认构造函数，拷贝构造函数，唯一主席指针变成只读状态；对外提供公共接口static ChairMan* getInstance();</p>
</blockquote>
<pre><code class="cpp">class Printer
&#123;
private:
    Printer()
    &#123;
        m_Count = 0;
    &#125;
    Printer(const Printer&amp; p)
    &#123;

    &#125;
    static Printer* printer;

public:
    static Printer* getInstance()
    &#123;
        return printer;
    &#125;

    void printText(string text)
    &#123;
        cout &lt;&lt; &quot;打印的内容：&quot; &lt;&lt; text &lt;&lt; endl;
        m_Count++;
    &#125;

    int m_Count;
&#125;;

Printer* Printer::printer = new Printer;

void test01()
&#123;
    Printer* p1 = Printer::getInstance();
    p1-&gt;printText(&quot;入职申请&quot;);
    p1-&gt;printText(&quot;离职报告&quot;);

    cout &lt;&lt; &quot;打印机使用次数&quot; &lt;&lt; p1-&gt;m_Count &lt;&lt; endl;

    Printer* p2 = Printer::getInstance();
    p2-&gt;printText(&quot;调休申请&quot;);

    cout &lt;&lt; &quot;打印机使用次数&quot; &lt;&lt; p2-&gt;m_Count &lt;&lt; endl;
&#125;
</code></pre>
<h6 id="3-10-成员变量与函数的存储"><a href="#3-10-成员变量与函数的存储" class="headerlink" title="3.10 成员变量与函数的存储"></a>3.10 成员变量与函数的存储</h6><p>C++成员变量与成员函数分开存储</p>
<p>一个类中，只有非静态成员变量属于类大小</p>
<p>空类的大小为1个字节</p>
<p>（每个对象在内存中必须有独一无二的地址，即使是空对象也不例外。为确保空类的每个实例都有唯一的地址，编译器会为空类分配一个字节的内存空间。）</p>
<p>（这个额外的字节并不存储任何数据，它只是用来区分不同的空类实例。）</p>
<pre><code class="cpp">class Person
&#123;
public:
    int m_A;//成员属性 算在类的大小中
    
    //成员函数 并不算在类的大小中（成员函数属于这个类的作用域，而不属于某一个具体的对象）
    void func()
    &#123;

    &#125;

    static int m_B;//静态成员变量，也不属于某个对象，不算在类的大小（即占几个字节）中

    static void func2()//静态成员函数，也不属于某个对象，不算在类的大小（即占几个字节）中
    &#123;

    &#125;

    double m_D;//最后结果是16，如果单单考虑数据类型大小应该是12（4+8），原因：考虑内存对齐。

&#125;;
int Person::m_B = 0;

void test01()
&#123;
    //空类的大小为1个字节
    //C++中空类也可以实例化对象，每个对象在内存中都应该有独一无二的地址
    cout &lt;&lt; sizeof(Person) &lt;&lt; endl;
&#125;
</code></pre>
<h6 id="3-11-this指针"><a href="#3-11-this指针" class="headerlink" title="3.11 this指针"></a>3.11 this指针</h6><p>this指针指向被调用的成员函数所属的对象</p>
<p>&#x3D;&#x3D;个人理解：this最大的意义可能就在于“属于谁”&#x3D;&#x3D;</p>
<pre><code class="cpp">//实际上每个成员函数的第一个参数默认都有个指向对象的 this 指针，如：
void Hello() 
&#123; 
    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; 
&#125; //上面的函数实质上是下面这样的：
void Hello(Person* this ) 
&#123; 
    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; 
&#125;//每个成员函数都拥有所属对象的地址作为自己的第一个参数
</code></pre>
<p>*this 对象本体</p>
<pre><code class="cpp">//对于一般对象是：Person p1;  是p1.func();
//对于指针对象：Person* p1;  则是（*p1）.func();编译器觉得这样太丑了。改为p1-&gt;func();与上面的同等效果
</code></pre>
<p>this可以解决名称的冲突</p>
<pre><code class="cpp">//1.在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。
//2.this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。
//3.友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针
//4.静态成员函数是不能使用 this 指针，因为静态成员函数相当于是共享的变量，不属于某个对象的变量。
class Person
&#123;
public:
    Person(int age)
    &#123;
        //this指针指向的是被调用的成员函数所属的对象
        //*this是这个对象的本体
        this-&gt;age = age;
    &#125;
    void showAge()
    &#123;
        cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; this-&gt;age &lt;&lt; endl;
    &#125;
    int age;
    //Person&amp; 链式调用，该数据类型返回的是它本身，如p1返回p1
    Person&amp; addAge(Person&amp; p)
    &#123;
        this-&gt;age += p.age;
        return *this;
    &#125;
&#125;;
void test01()
&#123;
    Person p1(18);
    cout &lt;&lt; &quot;p1的年龄：&quot; &lt;&lt; p1.age &lt;&lt; endl;
    p1.showAge();
    Person p2(10);
    p1.addAge(p2).addAge(p2).addAge(p2);//链式编程
    p1.showAge();
&#125;
//c++中当定义类对象是指针对象时候，就需要用到-&gt;指向类中的成员；当定义一般对象时候时就需要用到&quot;.&quot;指向类中的成员。
</code></pre>
<h6 id="3-12-空指针访问成员函数"><a href="#3-12-空指针访问成员函数" class="headerlink" title="3.12 空指针访问成员函数"></a>3.12 空指针访问成员函数</h6><p>如果是一个空指针</p>
<p>可以访问没有this的一些成员函数</p>
<p>如果函数用到了this指针，程序会down掉，如果想让代码严谨，加判断：</p>
<pre><code class="cpp">class Person
&#123;
public:
    void showClassName()
    &#123;
        cout &lt;&lt; &quot;class Name is Person&quot; &lt;&lt; endl;
    &#125;
    void showAge()
    &#123;
        //NULL-&gt;m_Age;
        if (this == NULL)
        &#123;
            return;
        &#125;
        cout &lt;&lt; &quot;age = &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
    &#125;
    int m_Age = 10;
&#125;;
void test01()
&#123;
    /*Person p1;
    p1.m_Age = 18;
    p1.showAge();
    p1.showClassName();*/
    Person* p1 = NULL;
    p1-&gt;showAge();
    p1-&gt;showClassName();
&#125;
</code></pre>
<h6 id="3-13-常函数与常对象"><a href="#3-13-常函数与常对象" class="headerlink" title="3.13 常函数与常对象"></a>3.13 常函数与常对象</h6><p>this指针本质是 指针常量  Person* const this（指针的指向是不可以修改的，指针指向的值可以改）</p>
<p>如果想指针指向的值也不能修改 const Person* const this</p>
<p>需要将成员函数改成常函数，成员函数的后面 加 const</p>
<p>有些特例的属性，即使是常函数或者说常对象 也是可以修改的，需要将属性加关键字 mulable</p>
<p>常对象 const Person p;常对象只能调用常函数，不可以调用普通的成员函数</p>
<pre><code class="cpp">class Person
&#123;
public:
    //**成员函数** 声明的后面加const代表常函数，不可以修改成员属性了
    void showPerson() const
    &#123;
        //const Person* const this
        //this指针的本质 是一个指针常量，指针的指向是不可以修改的，指针指向的值可以改
        cout &lt;&lt; this-&gt;m_A &lt;&lt; endl;
        //this-&gt;m_A = 100;
        //this = NULL;

        this-&gt;m_B = 100;
    &#125;
    void showPerson2()
    &#123;
        cout &lt;&lt; &quot;aaa&quot; &lt;&lt; endl;
    &#125;
    int m_A;
    mutable int m_B;//即使是常函数，m_B我也想可以修改，用mutable关键字
&#125;;
void test01()
&#123;
    Person p1;
    p1.m_A = 10;
    p1.showPerson();
&#125;
//常对象
void test02()
&#123;
    const Person p1;//常对象
    //常对象也不可以修改内部的属性
    //p1.m_A = 100;
    p1.m_B = 100;//m_B是特殊属性，即使是常对象或常函数，都可以改

    p1.showPerson();//常对象 只能调用常函数
    p1.showPerson2();//常对象 是不能调用普通的成员函数的
&#125;
</code></pre>
<h6 id="3-14-全局函数作为友元函数"><a href="#3-14-全局函数作为友元函数" class="headerlink" title="3.14 全局函数作为友元函数"></a>3.14 全局函数作为友元函数</h6><p>有一个全局函数，作为本类的友元函数，可以访问到私有内容</p>
<p>类的内部写入：friend + 函数声明</p>
<pre><code class="cpp">//家建筑
class Building
&#123;
    //有一个全局函数，作为本类的友元函数，可以访问到私有内容
    friend void goodGay(Building&amp; building);
public:
    Building()
    &#123;
        this-&gt;m_SittingRoom = &quot;客厅&quot;;
        this-&gt;m_BedRoom = &quot;卧室&quot;;
    &#125;
public:
    //客厅
    string m_SittingRoom;
private:
    //卧室
    string m_BedRoom;
&#125;;
//好基友全局函数
void goodGay(Building &amp; building)
&#123;
    cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;
    cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building.m_BedRoom &lt;&lt; endl;
&#125;
void test01()
&#123;
    Building b;
    goodGay(b);
&#125;
</code></pre>
<h5 id="四、第四天"><a href="#四、第四天" class="headerlink" title="四、第四天"></a>四、第四天</h5><h6 id="4-1-类作为有元类"><a href="#4-1-类作为有元类" class="headerlink" title="4.1 类作为有元类"></a>4.1 类作为有元类</h6><p>类作为友元类</p>
<p>告诉编译器 goodGay类是本类的好朋友，可以访问到里面的私有内容</p>
<p>在类内部写入：friend class goodGay;</p>
<pre><code class="cpp">class Building;
class goodGay
&#123;
public:
    goodGay();
    void visit();
private:
    Building* building;
&#125;;
class Building
&#123;
    //告诉编译器 goodGay类是本类的好朋友，可以访问到里面的私有内容
    friend class goodGay;
public:
    Building()
    &#123;

    &#125;
public:
    //客厅
    string m_SittingRoom;
private:
    //卧室
    string m_BedRoom;
&#125;;
//类外做函数的实现
goodGay::goodGay()
&#123;
    this-&gt;building = new Building;
&#125;
void goodGay::visit()
&#123;
    cout &lt;&lt; &quot;好基友类 正在访问：&quot; &lt;&lt; this-&gt;building-&gt;m_SittingRoom &lt;&lt; endl;
    cout &lt;&lt; &quot;好基友类 正在访问：&quot; &lt;&lt; this-&gt;building-&gt;m_BedRoom &lt;&lt; endl;
&#125;
Building::Building()
&#123;
    this-&gt;m_SittingRoom = &quot;客厅&quot;;
    this-&gt;m_BedRoom = &quot;卧室&quot;;
&#125;
void test01()
&#123;
    //Building building;
    goodGay gg;
    gg.visit();
&#125;
</code></pre>
<h6 id="4-2-类中成员函数作为友元函数"><a href="#4-2-类中成员函数作为友元函数" class="headerlink" title="4.2 类中成员函数作为友元函数"></a>4.2 类中成员函数作为友元函数</h6><p>告诉编译器，goodGay类中的visit成员函数，利用访问本类中的私有内容</p>
<p>friend void goodGay::visit();</p>
<h6 id="4-3-数组类封装"><a href="#4-3-数组类封装" class="headerlink" title="4.3 数组类封装"></a>4.3 数组类封装</h6><p>（这里只展示MyArray.cpp）</p>
<pre><code class="cpp">#include &quot;MyArray.h&quot;

MyArray::MyArray()//默认构造函数
&#123;
    this-&gt;m_capacity = 100;
    this-&gt;m_Size = 0;
    this-&gt;pAddress = new int[this-&gt;m_capacity];
&#125;

MyArray::MyArray(int capacity)//有参构造函数
&#123;

    this-&gt;m_capacity = capacity;
    this-&gt;m_Size = 0;
    this-&gt;pAddress = new int[this-&gt;m_capacity];
&#125;

MyArray::MyArray(const MyArray&amp; arr)//拷贝构造函数
&#123;
    this-&gt;m_capacity = arr.m_capacity;
    this-&gt;m_Size = arr.m_Size;
    this-&gt;pAddress = new int[this-&gt;m_capacity];
    for (int i = 0; i &lt; this-&gt;m_Size; ++i)
    &#123;
        this-&gt;pAddress[i] = arr.pAddress[i];
    &#125;
&#125;

void MyArray::pushBack(int val)//尾插
&#123;
    this-&gt;pAddress[this-&gt;m_Size] = val;
    this-&gt;m_Size++;
&#125;

int MyArray::getCapacity()//获取数组容量
&#123;
    return this-&gt;m_capacity;
&#125;

int MyArray::getSize()//获取数组大小
&#123;
    return this-&gt;m_Size;
&#125;

void MyArray::setData(int index, int val)//修改数据
&#123;
    this-&gt;pAddress[index] = val;
&#125;

int MyArray::getData(int index)//获取数据
&#123;
    return this-&gt;pAddress[index];
&#125;

MyArray::~MyArray()//析构函数
&#123;
    if (this-&gt;pAddress != NULL)
    &#123;
        delete[] this-&gt;pAddress;
        this-&gt;pAddress = NULL;
    &#125;
    
&#125;
</code></pre>
<h6 id="4-4-加号运算符重载"><a href="#4-4-加号运算符重载" class="headerlink" title="4.4 加号运算符重载"></a>4.4 加号运算符重载</h6><p>对于内置的数据类型，编译器知道该如何进行运算；但对于自定义的数据类型，编译器不知道如何运算；</p>
<p>&#x3D;&#x3D;利用运算符重载可以解决这个问题。&#x3D;&#x3D;下面是运用成员函数和全局函数来解决这个问题</p>
<p>&#x3D;&#x3D;注意：运算符重载也可以发生函数重载&#x3D;&#x3D;</p>
<pre><code class="cpp">class Person
&#123;
public:
    Person() &#123;&#125;;

    Person(int a, int b) : m_A(a), m_B(b)
    &#123;

    &#125;

    ////利用成员函数+号运算符重载
    //Person operator+(Person&amp; p)
    //&#123;
    //	Person temp;
    //	temp.m_A = this-&gt;m_A + p.m_A;
    //	temp.m_B = this-&gt;m_B + p.m_B;

    //	return temp;//存疑：返回的是拷贝构造
    //&#125;
    int m_A;
    int m_B;

&#125;;

//利用全局函数进行+运算符的重载
Person operator+(Person&amp; p1, Person&amp; p2)
&#123;
    Person temp;
    temp.m_A = p1.m_A + p2.m_A;
    temp.m_B = p1.m_B + p2.m_B;

    return temp;
&#125;
//运算符重载的函数重载
Person operator+(Person&amp; p1, int a)
&#123;
    Person temp;
    temp.m_A = p1.m_A + a;
    temp.m_B = p1.m_B + a;

    return temp;
&#125;
void test01()
&#123;
    Person p1(10, 10);
    Person p2(10, 10);

    Person p3 = p1 + p2;
    //成员函数的本质：
    // Person p3 = p1.operator+(p2);
    //全局函数的本质
    //Person p3 = operator+(p1,p2);
    cout &lt;&lt; &quot;p3的m_A:&quot; &lt;&lt; p3.m_A &lt;&lt; endl;

    //运算符重载 可不可以发生函数重载？
    
    Person p4 = p1 + 100;
    cout &lt;&lt; &quot;p4的m_A:&quot; &lt;&lt; p4.m_A &lt;&lt; endl;
&#125;
</code></pre>
<h6 id="4-5-左移运算符重载任务布置"><a href="#4-5-左移运算符重载任务布置" class="headerlink" title="4.5 左移运算符重载任务布置"></a>4.5 左移运算符重载任务布置</h6><p>1.运算符重载知识一种“语法上的方便”，也就是它是另一种函数调用的方式。</p>
<p>2.对与内置的数据类型的表达式的运算符是不能改变的（如想重载int类型数据的+号）</p>
<pre><code class="cpp">//该代码用到了运算符重载，链式编程，友元
class Person
&#123;
    //若Person的属性是私有，可以用友元访问私有属性
    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p);
public:
    Person() &#123;&#125;;
    Person(int a, int b)
    &#123;
        this-&gt;m_A = a;
        this-&gt;m_B = b;
    &#125;
    
    //试图利用成员函数 实现&lt;&lt;运算符重载      这样做不行，这样cout就在&lt;&lt;右边了
    /*void operator&lt;&lt;(ostream&amp; cout)
    &#123;

    &#125;*/
private:
    int m_A;
    int m_B;
&#125;;

//试图利用全局函数 实现&lt;&lt;运算符重载
ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p)//将这的cout改成out，下数第二行的cout不变也能正常运行。原因：&amp;是取别名，原名也能用
&#123;
    cout &lt;&lt; &quot;m_A=&quot; &lt;&lt; p.m_A &lt;&lt; &quot; m_B=&quot; &lt;&lt; p.m_B;
    return cout;
&#125;

void test01()
&#123;
    Person p1(10, 10);
    //cout &lt;&lt; &quot;m_A=&quot; &lt;&lt; p1.m_A &lt;&lt; &quot; m_B=&quot; &lt;&lt; p1.m_B &lt;&lt; endl;
    cout &lt;&lt; p1 &lt;&lt; endl;//链式编程，cout&lt;&lt;p1后返回值应该要还是cout
&#125;
</code></pre>
<h6 id="4-6-递增运算符重载"><a href="#4-6-递增运算符重载" class="headerlink" title="4.6 递增运算符重载"></a>4.6 递增运算符重载</h6><pre><code class="cpp">class MyInter
&#123;
    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInter&amp; myInt);

public:
    MyInter()
    &#123;
        this-&gt;m_Num = 0;
    &#125;
    //重载前置++
    MyInter&amp; operator++()//这里为什么要加&amp;,因为加&amp;返回的是本体，不加返回的是编译器复制出来的一个对象
    &#123;
        m_Num++;

        return *this;
    &#125;
    //重载后置++
    MyInter&amp; operator++(int)
    &#123;
        MyInter temp = *this;

        this-&gt;m_Num++;

        return temp;
    &#125;

private:int m_Num;
&#125;;

//左移运算符
ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInter&amp; myInt)
&#123;
    cout &lt;&lt; myInt.m_Num;
    return cout;
&#125;
//前置++案例
void test01()
&#123;
    MyInter myInt;
    cout &lt;&lt; ++myInt &lt;&lt; endl;//  1
    cout &lt;&lt; myInt &lt;&lt; endl;//  1
    cout &lt;&lt; myInt++ &lt;&lt; endl;//  1
    cout &lt;&lt; myInt &lt;&lt; endl;//    2
    cout &lt;&lt; ++myInt &lt;&lt; endl;//  3
    cout &lt;&lt; myInt &lt;&lt; endl;//   3

&#125;
</code></pre>
<h6 id="4-7-指针运算符重载-智能指针"><a href="#4-7-指针运算符重载-智能指针" class="headerlink" title="4.7 指针运算符重载-智能指针"></a>4.7 指针运算符重载-智能指针</h6><p>智能指针的用途：托管堆区创建的对象的释放</p>
<p>如果想让sp对象当做一个指针去对待，需要重载-&gt;与*</p>
<pre><code class="cpp">class Person
&#123;
public:
    Person(int age)
    &#123;
        this-&gt;m_Age = age;
        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;
    &#125;
    void showAge()
    &#123;
        cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
    &#125;
    ~Person()
    &#123;
        cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;
    &#125;
private:
    int m_Age;
&#125;;
//智能指针，用来托管new出来的对象的释放
class SmartPointer
&#123;
public:
    SmartPointer(Person* person)
    &#123;
        cout &lt;&lt; &quot;SmartPointer构造函数调用&quot; &lt;&lt; endl;
        this-&gt;person = person;
    &#125;
    //重载指针运算符
    Person* operator-&gt;()
    &#123;
        return this-&gt;person;
    &#125;
    //重载*(解引用)运算符
    Person&amp; operator*()
    &#123;
        return *this-&gt;person;
    &#125;
    ~SmartPointer()
    &#123;
        cout &lt;&lt; &quot;SmartPointer析构函数调用&quot; &lt;&lt; endl;
        if (this-&gt;person != NULL)
        &#123;
            delete this-&gt;person;
            this-&gt;person = NULL;
        &#125;
    &#125;
private:
    Person* person;
&#125;;
void test01()
&#123;
    //Person* p = new Person(18);
    //p-&gt;showAge();
    //(*p).showage();
    //delete p;
    SmartPointer sp = SmartPointer(new Person(18));
    //sp-&gt;showAge();//sp-&gt;-&gt;showAge();编译器简化为sp-&gt;showAge();
    sp-&gt;showAge();
    (*sp).showAge();
&#125;
</code></pre>
<h6 id="4-8-赋值运算符重载"><a href="#4-8-赋值运算符重载" class="headerlink" title="4.8 赋值运算符重载"></a>4.8 赋值运算符重载</h6><p>系统会默认给一个类添加4个函数：默认构造，拷贝构造，析构，operator&#x3D;</p>
<blockquote>
<p>由于系统提供的operator&#x3D;会进行简单的值拷贝，导致如果属性中有堆区的数据，会进行重复释放（当一个类中包含指针成员变量指向堆区内存时，在进行浅拷贝时，两个对象的指针成员变量会指向同一块内存。这会导致问题，当其中一个对象的析构函数调用 <code>delete</code> 释放堆区内存时，另一个对象仍然持有指向已释放内存的指针，导致悬空指针的问题。）</p>
</blockquote>
<p>解决方案，需要重载operator&#x3D;，对于a&#x3D;b&#x3D;c的问题，要注意返回值是Person&amp;。</p>
<pre><code class="cpp">class Person
&#123;
public:
    Person(const char* name, int age)
    &#123;
        this-&gt;m_Name = new char[strlen(name) + 1];
        strcpy(this-&gt;m_Name, name);

        this-&gt;m_Age = age;
    &#125;
    //系统会默认给一个类，创建至少三个函数，默认构造，析构，拷贝构造（简单值拷贝），operator=（值拷贝）

    Person&amp; operator=(const Person&amp; p)
    &#123;
        //先判断原来堆区是否有数据，如果有先释放
        if (this-&gt;m_Name != NULL)
        &#123;
            delete [] this-&gt;m_Name;
            this-&gt;m_Name = NULL;
            this-&gt;m_Name = new char[strlen(p.m_Name) + 1];
            strcpy(this-&gt;m_Name, p.m_Name);
        &#125;
        //this-&gt;m_Name = p.m_Name;
        this-&gt;m_Age = p.m_Age;

        return *this;
    &#125;
    Person(const Person&amp; p)
    &#123;
        this-&gt;m_Name = new char[strlen(p.m_Name) + 1];
        strcpy(this-&gt;m_Name, p.m_Name);
        this-&gt;m_Age = p.m_Age;
    &#125;

    ~Person()
    &#123;
        if (this-&gt;m_Name != NULL)
        &#123;
            delete[] this-&gt;m_Name;
            this-&gt;m_Name = NULL;
        &#125;
    &#125;
    char* m_Name;
    int m_Age;
&#125;;

void test01()
&#123;
    Person p1(&quot;tom&quot;, 18);
    Person p2(&quot;Jerry&quot;, 19);

    p1 = p2;

    cout &lt;&lt; &quot;p1 姓名：&quot; &lt;&lt; p1.m_Name &lt;&lt; &quot; 年龄&quot; &lt;&lt; p1.m_Age &lt;&lt; endl;
    cout &lt;&lt; &quot;p2 姓名：&quot; &lt;&lt; p2.m_Name &lt;&lt; &quot; 年龄&quot; &lt;&lt; p1.m_Age &lt;&lt; endl;

    Person p3(&quot;&quot;, 0);
    p3 = p1 = p2;

    cout &lt;&lt; &quot;p3 姓名：&quot; &lt;&lt; p3.m_Name &lt;&lt; &quot; 年龄&quot; &lt;&lt; p1.m_Age &lt;&lt; endl;

    Person p4 = Person(p3);

    cout &lt;&lt; &quot;p4 姓名：&quot; &lt;&lt; p4.m_Name &lt;&lt; &quot; 年龄&quot; &lt;&lt; p1.m_Age &lt;&lt; endl;
&#125;
</code></pre>
<h5 id="五、第五天"><a href="#五、第五天" class="headerlink" title="五、第五天"></a>五、第五天</h5><h6 id="5-1-关系运算符重载"><a href="#5-1-关系运算符重载" class="headerlink" title="5.1 关系运算符重载"></a>5.1 关系运算符重载</h6><pre><code class="cpp">class Person
&#123;
public:
    Person(string name,int age)
    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;

    bool operator==(const Person&amp; p)
    &#123;
        /*if (this-&gt;m_Age == p.m_Age &amp;&amp; this-&gt;m_Name == p.m_Name)
        &#123;
            return true;
        &#125;
        return false;*/

        return this-&gt;m_Age == p.m_Age &amp;&amp; this-&gt;m_Name == p.m_Name;
    &#125;

    string m_Name;
    int m_Age;
&#125;;

void test01()
&#123;
    Person p1(&quot;Tom&quot;, 10);
    Person p2(&quot;Tom&quot;, 10);

    if (p1 == p2)
    &#123;
        cout &lt;&lt; &quot;p1等于p2&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;p1不等于p2&quot; &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<h6 id="5-2-函数调用运算符重载"><a href="#5-2-函数调用运算符重载" class="headerlink" title="5.2 函数调用运算符重载"></a>5.2 函数调用运算符重载</h6><p>实现了两个()运算符重载</p>
<pre><code class="cpp">class MyFunc
&#123;
public:
    void operator()(string text)
    &#123;
        cout &lt;&lt; text &lt;&lt; endl;
    &#125;
&#125;;

void test01()
&#123;
    MyFunc func;//仿函数，看起来像函数，但实际上是一个对象（不是仿函数定义，只是一个形象化描述）
    func(&quot;hello world&quot;);
&#125;

class MyAdd
&#123;
public:
    int operator()(int a, int b)
    &#123;
        return a + b;
    &#125;
&#125;;

void test02()
&#123;
    MyAdd myAdd;
    cout &lt;&lt; myAdd(1, 1) &lt;&lt; endl;

    // MyAdd()(10,10) 匿名函数对象
    cout &lt;&lt; MyAdd()(10,10) &lt;&lt; endl;
&#125;
</code></pre>
<h6 id="5-3-不要重载逻辑与和逻辑或符号"><a href="#5-3-不要重载逻辑与和逻辑或符号" class="headerlink" title="5.3 不要重载逻辑与和逻辑或符号"></a>5.3 不要重载逻辑与和逻辑或符号</h6><p>内置版本的&amp;&amp;和||首先计算左边的表达式，如果这完全能决定结果，就无需计算右边的表达式了。而我们若重载&amp;&amp;和||，那么就无此特性了</p>
<p>&#x3D;&#x3D;我们说的运算符重载只是另一种形式的函数调用而已，对于函数调用总是在函数执行之前对所有参数进行求值。&#x3D;&#x3D;</p>
<p>例如：</p>
<pre><code class="cpp">if(complex1 &amp;&amp; (complex1 += complex2))&#123;
    cout &lt;&lt; &quot;真！&quot; &lt;&lt; endl;
&#125;
else&#123;
    cout &lt;&lt; &quot;假！&quot; &lt;&lt; endl;
&#125;
</code></pre>
<h6 id="5-4-重载总结"><a href="#5-4-重载总结" class="headerlink" title="5.4 重载总结"></a>5.4 重载总结</h6><blockquote>
<p>&#x3D;, [], (), -&gt; 操作符只能通过成员函数进行重载；（不然容易出现二义性）</p>
<p>&lt;&lt; 和 &gt;&gt; 只能通过全局函数配合有元函数进行重载；（比如让cout写左边，就要用全局函数）</p>
<p>不要重载 &amp;&amp; 和 || 操作符；（因为无法实现短路规则）</p>
</blockquote>
<p>常规建议：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>建议使用</th>
</tr>
</thead>
<tbody><tr>
<td>所有的一元运算符</td>
<td>成员</td>
</tr>
<tr>
<td>&#x3D; () [] -&gt; -&gt;**</td>
<td>必须是成员</td>
</tr>
<tr>
<td>+&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; *&#x3D; ^&#x3D;等</td>
<td>成员</td>
</tr>
<tr>
<td>其它二元运算符</td>
<td>非成员</td>
</tr>
</tbody></table>
<h6 id="5-5-字符串类封装"><a href="#5-5-字符串类封装" class="headerlink" title="5.5 字符串类封装"></a>5.5 字符串类封装</h6><pre><code class="cpp">//MyString.h
class MyString
&#123;
    //左移运算符配合友元
    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyString&amp; str);
    //左移运算符配合友元
    friend istream&amp; operator&gt;&gt;(istream&amp; cin, MyString&amp; str);
public:
    //有参构造函数
    MyString(const char* str);
    //拷贝构造函数
    MyString(const MyString&amp; str);
    //用户使用方式 MyString str = &quot;aaa&quot;;  MyString str2 = str;
    //重载[]运算符
    char&amp; operator[](int index);
    //重载=运算符
    MyString&amp; operator=(const char* str);
    MyString&amp; operator=(MyString&amp; str);
    //重载+运算符，实现字符串的拼接
    MyString operator+(const char* str);
    MyString operator+(MyString&amp; str);
    //重载==号运算符
    bool operator==(const char* str);
    bool operator==(MyString&amp; str);
    //析构函数
    ~MyString();

private:
    //指向堆区的字符串的指针
    char* pString;

    //字符串长度
    int m_Size;
&#125;;
</code></pre>
<pre><code class="cpp">//MyString.cpp
#include &quot;MyString.h&quot;
//重载&lt;&lt;运算符
ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyString&amp; str)
&#123;
    cout &lt;&lt; str.pString &lt;&lt; endl;

    return cout;
&#125;
//重载&gt;&gt;运算符
istream&amp; operator&gt;&gt;(istream&amp; cin, MyString&amp; str)
&#123;
    //先判断str中是否有数据，如果有 先进行释放
    if (str.pString != NULL)
    &#123;
        delete[] str.pString;
        str.pString = NULL;
    &#125;

    char buf[1024];//缓冲区

    cin &gt;&gt; buf;//将用户输入的数据存放在buf中
    //我要将buf中的数据放入到我内部维护的pString中
    str.pString = new char[strlen(buf) + 1];
    strcpy(str.pString, buf);
    str.m_Size = strlen(buf);

    return cin;
&#125;
MyString::MyString(const char* str)
&#123;
    this-&gt;pString = new char[strlen(str) + 1];//要加1的原因是strlen不统计&#39;\0&#39;
    //strlen接受一个指向以 null 终止的字符串的指针作为参数，
    //并返回字符串的长度，即不包括 null 终止符的字符数。
    strcpy(this-&gt;pString, str);//strcpy是C语言标准库，会复制&#39;\0&#39;

    this-&gt;m_Size = strlen(str);
&#125;

MyString::MyString(const MyString&amp; str)
&#123;
    /*this-&gt;pString = new char[str.m_Size];
    strcpy(this-&gt;pString, str.pString);

    this-&gt;m_Size = str.m_Size;*/
    this-&gt;pString = new char[strlen(str.pString) + 1];
    strcpy(this-&gt;pString, str.pString);

    this-&gt;m_Size = strlen(str.pString);
&#125;

char&amp; MyString::operator[](int index)
&#123;
    return this-&gt;pString[index];
&#125;

MyString&amp; MyString::operator=(const char* str)
&#123;
    //先判断原来是否有数据，如果有先释放
    if (this-&gt;pString != NULL)
    &#123;
        delete[] this-&gt;pString;
        this-&gt;pString = NULL;
    &#125;
    this-&gt;pString = new char[strlen(str) + 1];
    strcpy(this-&gt;pString, str);
    this-&gt;m_Size = strlen(str);

    return *this;
&#125;

MyString&amp; MyString::operator=(MyString&amp; str)
&#123;
    //先判断原来是否有数据，如果有先释放
    if (this-&gt;pString != NULL)
    &#123;
        delete[] this-&gt;pString;
        this-&gt;pString = NULL;
    &#125;
    this-&gt;pString = new char[strlen(str.pString) + 1];
    strcpy(this-&gt;pString, str.pString);
    this-&gt;m_Size = strlen(str.pString);

    return *this;
&#125;

MyString MyString::operator+(const char* str)
&#123;
    int newSize = this-&gt;m_Size + strlen(str) + 1;
    char* temp = new char[newSize];

    //将abc和def放到temp空间下
    memset(temp, 0, newSize);//三个参数，指向内存块的指针，值，字节数
    strcat(temp, this-&gt;pString);//字符串追加，两个参数目标字符串，源字符串
    strcat(temp, str);
    MyString newString(temp);
    delete[] temp;
    return newString;
&#125;

MyString MyString::operator+(MyString&amp; str)
&#123;
    int newSize = this-&gt;m_Size + strlen(str.pString) + 1;
    char* temp = new char[newSize];

    //将abc和def放到temp空间下
    memset(temp, 0, newSize);//三个参数，指向内存块的指针，值，字节数
    strcat(temp, this-&gt;pString);//字符串追加，两个参数目标字符串，源字符串
    strcat(temp, str.pString);
    MyString newString(temp);
    delete[] temp;
    return newString;
&#125;

bool MyString::operator==(const char* str)
&#123;
    //strcmp 函数会按照字典顺序比较两个字符串，并返回一个整数值来表示比较结果：
    //如果 str1 等于 str2，则返回值为 0。
    //如果 str1 小于 str2，则返回值为负数。
    //如果 str1 大于 str2，则返回值为正数。
    if (strcmp(this-&gt;pString, str) == 0)
    &#123;
        return true;
    &#125;
    return false;
&#125;

bool MyString::operator==(MyString&amp; str)
&#123;
    if (strcmp(this-&gt;pString, str.pString) == 0)
    &#123;
        return true;
    &#125;
    return false;
&#125;

MyString::~MyString()
&#123;
    if (this-&gt;pString != NULL)
    &#123;
        delete[] this-&gt;pString;
        this-&gt;pString = NULL;
    &#125;
&#125;
</code></pre>
<h6 id="5-6-继承的基本语法"><a href="#5-6-继承的基本语法" class="headerlink" title="5.6 继承的基本语法"></a>5.6 继承的基本语法</h6><p>语法为 class 子类 : 继承方式 父类</p>
<p>BasePage 基类（父类）  GamePage 派生类（子类）</p>
<p>继承好处：可以减少重复代码的出现</p>
<pre><code class="cpp">//利用继承可以减少重复代码的出现
//BasePage 基类（父类）  GamePage 派生类（子类）
//语法为 class 子类 : 继承方式 父类
class BasePage
&#123;
public:
    void header()
    &#123;
        cout &lt;&lt; &quot;公共头部&quot; &lt;&lt; endl;
    &#125;
    void footer()
    &#123;
        cout &lt;&lt; &quot;公共底部&quot; &lt;&lt; endl;
    &#125;
    void leftList()
    &#123;
        cout &lt;&lt; &quot;公共的左侧列表&quot; &lt;&lt; endl;
    &#125;

&#125;;
class GamePage : public BasePage
&#123;
    void content()
    &#123;
        cout &lt;&lt; &quot;LOL赛事直播&quot; &lt;&lt; endl;
    &#125;
&#125;;
class NewsPage : public BasePage
&#123;
    void content()
    &#123;
        cout &lt;&lt; &quot;两会召开&quot; &lt;&lt; endl;
    &#125;
&#125;;
</code></pre>
<h6 id="5-7-继承方式"><a href="#5-7-继承方式" class="headerlink" title="5.7 继承方式"></a>5.7 继承方式</h6><p><img src="https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306010942357.png" alt="image-20230601094233412"></p>
<h6 id="5-8-继承中的对象模型"><a href="#5-8-继承中的对象模型" class="headerlink" title="5.8 继承中的对象模型"></a>5.8 继承中的对象模型</h6><p>父类中私有的属性，子类继承了，但是编译器给隐藏了，因此访问不到</p>
<pre><code class="cpp">class Base
&#123;
public:
    int m_A;
protected:
    int m_B;
private:
    int m_C;
&#125;;
class Son : public Base
&#123;
public:
    //父类中私有的属性，子类继承了，但是编译器给隐藏了，因此访问不到
    int m_D;
&#125;;

void test01()
&#123;
    cout &lt;&lt; sizeof(Son) &lt;&lt; endl;
&#125;
</code></pre>
<h6 id="5-9-继承中的构造与析构"><a href="#5-9-继承中的构造与析构" class="headerlink" title="5.9 继承中的构造与析构"></a>5.9 继承中的构造与析构</h6><p>&#x3D;&#x3D;在创建子类实例时，子类首先会调用父类的构造函数，以初始化从父类继承的成员。&#x3D;&#x3D;</p>
<pre><code class="cpp">//如果不调用基类的构造函数，可能出现以下后果
class Base &#123;
public:
    int value;
    Base() &#123;
        value = 10;
    &#125;
&#125;;

class Derived : public Base &#123;
public:
    Derived() &#123;
        // 没有调用基类的构造函数
    &#125;
&#125;;

int main() &#123;
    Derived d;
    cout &lt;&lt; d.value &lt;&lt; endl; // 基类成员value的值是未定义的，输出结果不确定
    return 0;
&#125;
</code></pre>
<p>（而在子类的析构时，会先调用子类的析构函数，再调用父类的析构函数。只是因为在继承关系中，子类继承了父类的成员，当子类对象被销毁时，需要先清理子类自身的资源，然后再清理父类的资源。）</p>
<p>&#x3D;&#x3D;可以使用初始化列表语法，显式指出调用父类的哪个构造函数&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;子类不会继承，父类的构造和析构函数&#x3D;&#x3D;</p>
<pre><code class="cpp">class Base2
&#123;
public:
    Base2(int a)
    &#123;
        this-&gt;m_A = a;
    &#125;
    int m_A;
&#125;;
//: 代表继承
class Son2 : public Base2
&#123;
public:
    //: 代表初始化列表
    //可以使用初始化列表语法 显示指出调用父类的哪个构造函数
    Son2(int a=1000):Base2(a)
    &#123;       
    &#125;
    int m_B;
&#125;;

void test02()
&#123;
    Son2 s();
&#125;
//子类不会继承 父类的构造和析构函数。因为只有父类自己才知道如何构造和析构自己的属性
</code></pre>
<h6 id="5-10-继承中的同名成员处理"><a href="#5-10-继承中的同名成员处理" class="headerlink" title="5.10 继承中的同名成员处理"></a>5.10 继承中的同名成员处理</h6><p><strong>为什么允许派生类定义同名成员？</strong></p>
<p><strong>答：这是允许派生类根据自身的需求对继承的成员进行定制化的实现。</strong></p>
<p>（1.通过重写基类成员，派生类可以提供更具体、更适合自身的实现逻辑。2.派生类可以在基类成员的基础上添加额外的功能。3.实现多态性）</p>
<p>&#x3D;&#x3D;如果子类和父类拥有同名成员，优先调用子类的成员，不过可以通过作用域调用父类的成员。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;同名的成员函数，子类会隐藏掉父类中的所有版本（因为是隐藏，所有还是能通过作用域调用的）&#x3D;&#x3D;</p>
<h6 id="5-11-继承中的同名静态成员处理"><a href="#5-11-继承中的同名静态成员处理" class="headerlink" title="5.11 继承中的同名静态成员处理"></a>5.11 继承中的同名静态成员处理</h6><p>其它跟上面是一样的，只不过静态成员的访问方式有两种，一种是通过对象来访问，一种是通过类名来访问</p>
<pre><code class="cpp">class Base
&#123;
public:
    static int m_A;//共享数据，编译阶段分配内存，类内声明，类外初始化

    static void func()
    &#123;
        cout &lt;&lt; &quot;Base中的func调用&quot; &lt;&lt; endl;
    &#125;
&#125;;
int Base::m_A = 10;

class Son :public Base
&#123;
public:
    static int m_A;

    static void func()
    &#123;
        cout &lt;&lt; &quot;Son中的func调用&quot; &lt;&lt; endl;
    &#125;
&#125;;
int Son::m_A = 20;

void test01()
&#123;
    //对m_A进行访问
    Son s;
    cout &lt;&lt; s.Base::m_A &lt;&lt; endl;
    cout &lt;&lt; s.m_A &lt;&lt; endl;

    //通过类名进行访问
    cout &lt;&lt; &quot;通过类名进行访问son中的m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;
    cout &lt;&lt; &quot;通过类名进行访问Base中的m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;

    //同名成员函数 进行调用
    s.func();
    Son::func();

    s.Base::func();
    Son::Base::func();
&#125;
</code></pre>
<h6 id="5-12-多继承的语法"><a href="#5-12-多继承的语法" class="headerlink" title="5.12 多继承的语法"></a>5.12 多继承的语法</h6><p>class 子类 : 继承方式 父类, 继承方式 父类  </p>
<p>如：<code>class Son : public Base1, public Base2</code></p>
<p>当两个父类有同名的成员，被子类继承后，调用时需加作用域进行区分</p>
<h6 id="扩展：基类子对象"><a href="#扩展：基类子对象" class="headerlink" title="扩展：基类子对象"></a>扩展：基类子对象</h6><p>所谓派生，就是对基类做某种拓展。所以派生类对象内部，一定有一份基类对象存在。</p>
<p>派生类对象内部的这份基类对象，本质上是派生类的一个成员，称为基类子对象。直接存放在派生类对象内部。因为不是独立对象，所以称为子对象</p>
<h6 id="5-13-菱形继承问题以及解决"><a href="#5-13-菱形继承问题以及解决" class="headerlink" title="5.13 菱形继承问题以及解决"></a>5.13 菱形继承问题以及解决</h6><p>两个派生类继承同一个基类，而又有某个类同时继承两个派生类，这种继承被称为菱形继承。</p>
<pre><code class="cpp">//比如以下结构
class  B
&#123;
  protected:  int a;
  public: B( )&#123; ...&#125; 
&#125;;
class B1: public  B
&#123;
  public: base1( )&#123;...&#125; 
&#125;;
class B2: public  B
&#123;
  public: B2( )&#123;...&#125; 
&#125;; 
class D:public B1,public B2
&#123;...&#125;
</code></pre>
<img src="https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306021105407.png" alt="image-20230602110548973" style="zoom: 67%;" />

<pre><code class="cpp">//以下程序会报错，因为a具有二义性。
class B &#123;
  protected:
   int a;
  public:
   B( )&#123; a=5; cout&lt;&lt;&quot;B a=&quot;&lt;&lt;a&lt;&lt;endl;&#125;  &#125;;
class B1:public B&#123;
   public:
    B1( )&#123; a=a+10; cout&lt;&lt;&quot;B1 a=&quot;&lt;&lt;a&lt;&lt;endl;&#125; &#125;;
class B2:public B&#123;
  public:
    B2( )&#123; a=a+20; cout&lt;&lt;&quot;B2 a=&quot;&lt;&lt;a&lt;&lt;endl;&#125; &#125;;
class D:public B1,public B2&#123;
  public:
    D( )&#123; cout&lt;&lt;&quot;D a=&quot;&lt;&lt; a&lt;&lt;endl;&#125; &#125;;
    //将D的构造函数改成如下结构能够通过运行
    // D( )&#123; cout&lt;&lt;&quot;B1 a=&quot;&lt;&lt;B1:: a&lt;&lt;endl;  cout&lt;&lt;&quot;B2 a=&quot;&lt;&lt; B2::a&lt;&lt;endl;&#125;  &#125;;
int main( )
&#123; D  obj; return  0;  &#125;
//结果：
//B a=5
//B1 a=15
//B a=5
//B2 a=25
//B1 a=15
//B2 a=25

//能够看到a被初始化了两次，我们希望a只被再第一次初始化以后就不再继续初始化了。那么我们要使用虚基类。
</code></pre>
<p>如果将公共基类说明为虚基类。那么，对同一个虚基类的构造函数只调用一次，这样从不同的路径继承的虚基类的成员在内存中就只拥有一个拷贝。从而解决了以上的二义性问题。</p>
<pre><code class="cpp"> class  派生类名:继承方式 virtual 基类名
 &#123;   … &#125;
 或
 class  派生类名: virtual 继承方式 基类名
 &#123;  … &#125;
</code></pre>
<p>我们将上面的继承结构改成如下所示</p>
<pre><code class="cpp">class B&#123;
  protected:  int a;
  public: B( )&#123; ...&#125; &#125;;
class B1: public virtual B&#123;
  public: B1( )&#123;...&#125; &#125;;
class B2: public virtual B&#123;
  public: B2( )&#123;...&#125; &#125;; 
class D:public B1,public B2&#123; . . .&#125;
</code></pre>
<img src="https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306021115489.png" alt="image-20230602111536411" style="zoom: 67%;" />

<pre><code class="cpp">//改成虚基类后，D obj;的结果为：
//B a=5
//B1 a=15
//B2 a=35
//D a=35
//可以看到a只被初始化了一次。
</code></pre>
<p>注意：如果在虚基类中定义有带形参的构造函数,并且没有定义默认形式的构造函数,则整个继承结构中,所有直接或间接的派生类都必须在构造函数的成员初始化表中列出对虚基类构造函数的调用,以初始化在虚基类中定义的数据成员。</p>
<pre><code class="cpp">class B &#123;  int a;
  public:
   B(int sa)
  &#123; a=sa;  cout&lt;&lt;&quot;Constructing B&quot;&lt;&lt;endl; &#125; &#125;;
class B1:virtual public B&#123;  int b;
  public:
   B1(int sa,int sb):B(sa)
   &#123; b=sb; cout&lt;&lt;&quot;Constructing B1&quot;&lt;&lt;endl; &#125; &#125;;
class B2:virtual public B&#123;  int c;
  public:
   B2(int sa,int sc):B(sa)
  &#123; c=sc; cout&lt;&lt;&quot;Constructing B2&quot;&lt;&lt;endl; &#125; &#125;;
class D:public B1,public B2 &#123;
   int d;
  public:
   D(int sa,int sb,int sc,int sd): B(sa),B1(sa,sb),B2(sa,sc)
   &#123; d=sd; cout&lt;&lt;&quot;Constructing D&quot;&lt;&lt;endl;&#125; &#125;;
 int main()
&#123; D  obj(2,4,6,8); return 0; &#125;
</code></pre>
<p>任何一个类的上层（不一定是直接继承虚基类），只要含有虚基类都要再构造函数中调用虚基类的构造函数。</p>
<pre><code class="cpp">//运行结果
//Constructing B
//Constructing B1
//Constructing B2
//Constructing D
</code></pre>
<p>若同一层次中同时包含虚基类和非虚基类,应先调用虚基类的构造函数,再调用非虚基类的构造函数,最后调用派生类构造函数;</p>
<pre><code class="cpp"> class X∶public Y，virtual public Z&#123;
        //…
    &#125;；
    X  one；
    定义类X的对象one后，将产生如下的调用次序。
    Z( )；
    Y( )；
    X( )；
</code></pre>
<h6 id="扩展：怎么看这个类在内存中的情况"><a href="#扩展：怎么看这个类在内存中的情况" class="headerlink" title="扩展：怎么看这个类在内存中的情况"></a>扩展：怎么看这个类在内存中的情况</h6><p>1.按win，然后点开VS2019的开发者命令提示工具，cd到自己代码的上一级目录</p>
<p>2.通过<code>cl /d1 reportSingleClassLayoutSheepTuo test01.cpp</code>来访问</p>
<pre><code class="cpp">class Animal
&#123;
public:
    int m_Age;
&#125;;
//virtual加上后，继承方式数据虚继承
//Animal类 变为 虚基类
//羊类
class Sheep : virtual public Animal
&#123;...&#125;;
//驼类
class Tuo : virtual public Animal
&#123;...&#125;;
//羊驼类
class SheepTuo : public Sheep, public Tuo
&#123;...&#125;;
//虚继承内部工作原理
void test02()
&#123;
    SheepTuo st;
    st.m_Age = 100;

    //通过sheep找到偏移量的值
    cout &lt;&lt; &quot;通过sheep找到的偏移量为：&quot; &lt;&lt; *(int*)((int*)*(int*)&amp;st + 1) &lt;&lt; endl;

    //通过tuo找到偏移量的值
    cout &lt;&lt; &quot;通过tuo找到的偏移量为：&quot; &lt;&lt; *(int*)((int*)*((int*)&amp;st + 1) + 1) &lt;&lt; endl;

    //通过偏移量求出m_Age的值
    cout &lt;&lt; &quot;通过偏移量求出m_Age的值：&quot; &lt;&lt; ((Animal*)((char*)&amp;st + (*(int*)((int*)*(int*)&amp;st + 1))))-&gt;m_Age &lt;&lt; endl;
&#125;
</code></pre>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>仓中鼠
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2023/06/04/%E9%BB%91%E9%A9%ACcpp(%E4%B8%8A)/" title="黑马C++（上）">http://example.com/2023/06/04/黑马cpp(上)/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

      
      <div>
        
          
        
      </div>

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%B8%B8%E8%AF%86/" rel="tag"><i class="fa fa-tag"></i> 常识</a>
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/15/%E6%97%A5%E8%AE%B0/" rel="prev" title="每日一记">
      <i class="fa fa-chevron-left"></i> 每日一记
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/04/%E9%BB%91%E9%A9%ACcpp(%E4%B8%8B)/" rel="next" title="黑马C++（下）">
      黑马C++（下） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%91%E9%A9%ACC"><span class="nav-number">1.</span> <span class="nav-text">黑马C++</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%AC%AC%E4%B8%80%E5%A4%A9"><span class="nav-number">1.1.</span> <span class="nav-text">一、第一天</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-1-%E5%8F%8C%E5%86%92%E5%8F%B7%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 双冒号作用域运算符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-2-namespace-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 namespace(命名空间)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-3-using%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 using的使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-4-cpp%E5%AF%B9c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A2%9E%E5%BC%BA"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 cpp对c语言的增强</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-5-const-%E5%B8%B8%E9%87%8F"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5 const(常量)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-6-%E5%BC%95%E7%94%A8"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.6 引用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%AC%AC%E4%BA%8C%E5%A4%A9"><span class="nav-number">1.2.</span> <span class="nav-text">二、第二天</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-class"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 class</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-2-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-%E7%94%A8%E4%BA%8E%E4%BB%A3%E6%9B%BFC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 内联函数(用于代替C语言中的预处理宏)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-3-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 函数的默认参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%93%E9%A2%98%EF%BC%9A%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-overload"><span class="nav-number">1.2.4.</span> <span class="nav-text">专题：函数重载(overload)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-4-extern-%E2%80%9CC%E2%80%9D%E6%B5%85%E6%9E%90"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.4 extern “C”浅析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%93%E9%A2%98%EF%BC%9A%E5%B0%81%E8%A3%85"><span class="nav-number">1.2.6.</span> <span class="nav-text">专题：封装</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%AC%AC%E4%B8%89%E5%A4%A9"><span class="nav-number">1.3.</span> <span class="nav-text">三、第三天</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#3-1-%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 分文件编写</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0-%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%B8%8E%E6%9E%90%E6%9E%84-%E6%B8%85%E7%90%86"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 对象的构造(初始化)与析构 (清理)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-3-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 初始化列表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-5-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5 类对象作为类成员</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%93%E9%A2%98%EF%BC%9Aexplicit-%E6%98%BE%E5%BC%8F"><span class="nav-number">1.3.6.</span> <span class="nav-text">专题：explicit(显式)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-6-new%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.3.7.</span> <span class="nav-text">3.6 new关键字</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-7-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">1.3.8.</span> <span class="nav-text">3.7 静态成员变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-8-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.9.</span> <span class="nav-text">3.8 静态成员函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-9-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.10.</span> <span class="nav-text">3.9 静态成员实现单例模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-10-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">1.3.11.</span> <span class="nav-text">3.10 成员变量与函数的存储</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-11-this%E6%8C%87%E9%92%88"><span class="nav-number">1.3.12.</span> <span class="nav-text">3.11 this指针</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-12-%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.13.</span> <span class="nav-text">3.12 空指针访问成员函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-13-%E5%B8%B8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.14.</span> <span class="nav-text">3.13 常函数与常对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-14-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.15.</span> <span class="nav-text">3.14 全局函数作为友元函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%AC%AC%E5%9B%9B%E5%A4%A9"><span class="nav-number">1.4.</span> <span class="nav-text">四、第四天</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#4-1-%E7%B1%BB%E4%BD%9C%E4%B8%BA%E6%9C%89%E5%85%83%E7%B1%BB"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 类作为有元类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-2-%E7%B1%BB%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 类中成员函数作为友元函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-3-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%B0%81%E8%A3%85"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 数组类封装</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-4-%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 加号运算符重载</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-5-%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%BB%BB%E5%8A%A1%E5%B8%83%E7%BD%AE"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5 左移运算符重载任务布置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-6-%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.4.6.</span> <span class="nav-text">4.6 递增运算符重载</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-7-%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.4.7.</span> <span class="nav-text">4.7 指针运算符重载-智能指针</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-8-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.4.8.</span> <span class="nav-text">4.8 赋值运算符重载</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%AC%AC%E4%BA%94%E5%A4%A9"><span class="nav-number">1.5.</span> <span class="nav-text">五、第五天</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#5-1-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 关系运算符重载</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 函数调用运算符重载</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-3-%E4%B8%8D%E8%A6%81%E9%87%8D%E8%BD%BD%E9%80%BB%E8%BE%91%E4%B8%8E%E5%92%8C%E9%80%BB%E8%BE%91%E6%88%96%E7%AC%A6%E5%8F%B7"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3 不要重载逻辑与和逻辑或符号</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-4-%E9%87%8D%E8%BD%BD%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.4.</span> <span class="nav-text">5.4 重载总结</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%B0%81%E8%A3%85"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.5 字符串类封装</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-6-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">1.5.6.</span> <span class="nav-text">5.6 继承的基本语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-7-%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-number">1.5.7.</span> <span class="nav-text">5.7 继承方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-8-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.8.</span> <span class="nav-text">5.8 继承中的对象模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-9-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="nav-number">1.5.9.</span> <span class="nav-text">5.9 继承中的构造与析构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-10-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86"><span class="nav-number">1.5.10.</span> <span class="nav-text">5.10 继承中的同名成员处理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-11-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86"><span class="nav-number">1.5.11.</span> <span class="nav-text">5.11 继承中的同名静态成员处理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-12-%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-number">1.5.12.</span> <span class="nav-text">5.12 多继承的语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%9F%BA%E7%B1%BB%E5%AD%90%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.5.13.</span> <span class="nav-text">扩展：基类子对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-13-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="nav-number">1.5.14.</span> <span class="nav-text">5.13 菱形继承问题以及解决</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E6%80%8E%E4%B9%88%E7%9C%8B%E8%BF%99%E4%B8%AA%E7%B1%BB%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">1.5.15.</span> <span class="nav-text">扩展：怎么看这个类在内存中的情况</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="仓中鼠"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">仓中鼠</p>
  <div class="site-description" itemprop="description">仓中鼠，食积粟，居大庑之下，不见人犬之忧。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/pd0820" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pd0820" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2840156124@qq.com" title="E-Mail → mailto:2840156124@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">仓中鼠</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">28k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">25 分钟</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

