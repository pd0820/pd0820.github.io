[{"title":"C语言基本语法","url":"/2023/01/14/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","content":"<h4 id=\"C语言基本语法\"><a href=\"#C语言基本语法\" class=\"headerlink\" title=\"C语言基本语法\"></a>C语言基本语法</h4><hr>\n<h5 id=\"1、输入与输出\"><a href=\"#1、输入与输出\" class=\"headerlink\" title=\"1、输入与输出\"></a>1、输入与输出</h5><h6 id=\"1-1-printf函数\"><a href=\"#1-1-printf函数\" class=\"headerlink\" title=\"1.1 printf函数\"></a>1.1 printf函数</h6><ul>\n<li><p><code>printf(&quot;字符串&quot;)；</code></p>\n</li>\n<li><p><code>printf(&quot;输出控制符&quot;,输出参数)；</code><mark>（输出控制符：指定计算机中的二进制数以什么形式输出）</mark></p>\n</li>\n</ul>\n<p>eg：<code>printf(&quot;%#X&quot;,x);</code>输出结果是0X2F（假定<code>int x = 47;</code>）</p>\n<h6 id=\"1-2-scanf函数\"><a href=\"#1-2-scanf函数\" class=\"headerlink\" title=\"1.2 scanf函数\"></a>1.2 scanf函数</h6><ul>\n<li>scanf(“输入控制符”,输入参数);<mark>（<code>&amp;i</code>表示<code>i</code>的地址，<code>&amp;</code>为取地址符）</mark></li>\n</ul>\n<p>   <mark> (将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入输入参数的地址对应的存储空间中)</mark></p>\n<p>    <mark>eg:操作系统接收键盘数据的时候都当做字符来接收的</mark></p>\n<ul>\n<li>scanf(“非输入控制符 输入控制符”,输入参数);</li>\n</ul>\n<p>        注意：此用法下，非输入控制符必须原样输入。</p>\n<p>   <mark> 当输入多个数时，可以用非输入控制符隔开</mark></p>\n<h5 id=\"2、运算符\"><a href=\"#2、运算符\" class=\"headerlink\" title=\"2、运算符\"></a>2、运算符</h5><h6 id=\"2-1-算数运算符\"><a href=\"#2-1-算数运算符\" class=\"headerlink\" title=\"2.1 算数运算符\"></a>2.1 算数运算符</h6><pre><code>+     -     *     /(正斜杠)     %\n</code></pre>\n<h6 id=\"2-2-关系运算符\"><a href=\"#2-2-关系运算符\" class=\"headerlink\" title=\"2.2 关系运算符\"></a>2.2 关系运算符</h6><pre><code>&gt;     &gt;=     &lt;     &lt;=     !=     ==\n</code></pre>\n<h6 id=\"2-3-逻辑运算符\"><a href=\"#2-3-逻辑运算符\" class=\"headerlink\" title=\"2.3 逻辑运算符\"></a>2.3 逻辑运算符</h6><pre><code>！     &amp;&amp;     ||\n</code></pre>\n<p><mark><code>&amp;&amp;</code>左边的表达式为假的话，右边就不会执行</mark></p>\n<p>eg：<code>m = (1/2) &amp;&amp; (k=5);</code>中的k&#x3D;5就不会执行。</p>\n<p>（不含分号的是表达式，含有分号的是语句。<mark>语句是必定会执行的，如if···else···只表示一个语句</mark>）</p>\n<p><mark>同样的，<code>||</code>左边的表达式为真的话，右边就不会执行</mark></p>\n<h6 id=\"2-4-赋值运算符\"><a href=\"#2-4-赋值运算符\" class=\"headerlink\" title=\"2.4 赋值运算符\"></a>2.4 赋值运算符</h6><pre><code>=     +=     *=     /=     -=\n</code></pre>\n<h6 id=\"2-5-优先级\"><a href=\"#2-5-优先级\" class=\"headerlink\" title=\"2.5 优先级\"></a>2.5 优先级</h6><p>算数&gt;关系&gt;逻辑&gt;赋值</p>\n<h5 id=\"3、流程控制\"><a href=\"#3、流程控制\" class=\"headerlink\" title=\"3、流程控制\"></a>3、流程控制</h5><p>程序执行的顺序</p>\n<h6 id=\"3-1-if语句\"><a href=\"#3-1-if语句\" class=\"headerlink\" title=\"3.1 if语句\"></a>3.1 if语句</h6><p><mark><code>if(90 &lt; score &lt;=100)</code>永远为真</mark></p>\n<p>两个数替换</p>\n<pre><code>t = a;\na = b;\nb = t;\n\n if (表达式1)\n     A;\n else if (表达式2)\n     B;\n (最后的else可以不要，程序也不会出错，因为逻辑上没有问题)\n</code></pre>\n<h6 id=\"3-2-for语句\"><a href=\"#3-2-for语句\" class=\"headerlink\" title=\"3.2 for语句\"></a>3.2 for语句</h6><pre><code>//for语句的执行顺序\nfor (i=1; i&lt;=4: i++)\n&#123;\n    sum = sum + 1;\n&#125;\ni=1;------1\ni&lt;=4;-----2\ni++;------3\nsum = sum + 1;-----4\n</code></pre>\n<p><mark>先执行1，再执行2，如果成立，再执行4，再执行3(3完了标志一次循环结束)，再执行2···以此类推。</mark></p>\n<h6 id=\"专题：强制类型转化\"><a href=\"#专题：强制类型转化\" class=\"headerlink\" title=\"专题：强制类型转化\"></a>专题：强制类型转化</h6><p>功能：把表达式的值强制转化为前面所执行的数据类型</p>\n<p>eg:<code>(int)(4.5+2.2)</code> 最终值为6</p>\n<pre><code>在求1 + 1/2 + 1/3 + ··· + 1/100中\nsum = sum +1/(float)(i);//OK\nsum = sum +(float)(1/i);//这样写不对，因为(1/i)在i&gt;=2后永远为0\nsum = sum +1.0/i;//也没问题\n</code></pre>\n<p><mark>注意:高精度与低精度一起运算，结果一定是高精度的。</mark></p>\n<p><mark>注意：float与double由于编码机制的问题，都不能保证可以精确的存储一个小数。</mark></p>\n<h6 id=\"专题：三目运算符\"><a href=\"#专题：三目运算符\" class=\"headerlink\" title=\"专题：三目运算符\"></a>专题：三目运算符</h6><p>格式</p>\n<p><code>A ? B : C</code></p>\n<p>等价于</p>\n<pre><code>if (A)\n    B;\nelse\n    C;\n</code></pre>\n<h6 id=\"专题：逗号表达式专题\"><a href=\"#专题：逗号表达式专题\" class=\"headerlink\" title=\"专题：逗号表达式专题\"></a>专题：逗号表达式专题</h6><p>格式</p>\n<p><code>(A, B, C, D)</code></p>\n<p>功能</p>\n<p>从左到右执行</p>\n<p>最终表达式的值是最后一项的值</p>\n<pre><code>eg：\n    int i;\n    int j = 2;\n    i = (j++, ++j, j+2, j-3);\n    printf(&quot;i = %d&quot;,i);\n最终输出结果为：\ni = 1\n</code></pre>\n<h6 id=\"3-3-while语句\"><a href=\"#3-3-while语句\" class=\"headerlink\" title=\"3.3 while语句\"></a>3.3 while语句</h6><p>格式：</p>\n<pre><code>while (表达式)\n    语句；\n</code></pre>\n<h6 id=\"3-4-do…while语句\"><a href=\"#3-4-do…while语句\" class=\"headerlink\" title=\"3.4 do…while语句\"></a>3.4 do…while语句</h6><p>多用于人机交互</p>\n<pre><code>do\n&#123;\n    A;\n&#125; while(表达式);\n</code></pre>\n<h6 id=\"3-5-switch语句\"><a href=\"#3-5-switch语句\" class=\"headerlink\" title=\"3.5 switch语句\"></a>3.5 switch语句</h6><pre><code>switch（表达式）\n&#123;\n    case 标签1：\n        语句1；\n    case 标签2：\n        语句2；\n    default：\n        语句n；\n&#125;\n//根据switch()中表达式的值找到与之匹配的case子句，就从此case子句开始执行下去，不再进行判断\n</code></pre>\n<p>这些标签只能是</p>\n<p>（1）枚举常量 （2）数值常量 （3）字符常量 （4）常变量 （5）宏名的一种（不用记忆，抄着玩的）</p>\n<h6 id=\"3-6-break语句\"><a href=\"#3-6-break语句\" class=\"headerlink\" title=\"3.6 break语句\"></a>3.6 break语句</h6><p>break用于终止循环。</p>\n<p>在多层循环中，只能终止距离它最近的循环</p>\n<h5 id=\"3-7-continue语句\"><a href=\"#3-7-continue语句\" class=\"headerlink\" title=\"3.7 continue语句\"></a>3.7 continue语句</h5><p>用于跳过本次循环剩下的语句，转去判断是否需要执行下一次循环</p>\n<h5 id=\"4、数组\"><a href=\"#4、数组\" class=\"headerlink\" title=\"4、数组\"></a>4、数组</h5><h6 id=\"4-1-数组的使用\"><a href=\"#4-1-数组的使用\" class=\"headerlink\" title=\"4.1 数组的使用\"></a>4.1 数组的使用</h6><p>为什么需要数组？</p>\n<p>用于解决大量同类型数据的存储和使用问题</p>\n<pre><code>eg:\nint a[5] = &#123;1, 2, 3, 4, 5&#125;;\na是数组的名字(代表数组中第一个元素的地址)，5表示数组元素的个数，并且这五个元素分别是a[0],a[1],a[2],a[3],a[4]\n</code></pre>\n<h6 id=\"4-2-一维数组\"><a href=\"#4-2-一维数组\" class=\"headerlink\" title=\"4.2 一维数组\"></a>4.2 一维数组</h6><ul>\n<li><p>为n个变量连续分配内存空间</p>\n</li>\n<li><p>所有变量的数据类型必须相同</p>\n</li>\n<li><p>所有变量所占的字节大小必须相等</p>\n</li>\n</ul>\n<p>完全初始化</p>\n<p>    <code>int a[5] = &#123;1, 2, 3, 4, 5&#125;;</code></p>\n<p>不完全初始化(为未初始化的元素自动为零)</p>\n<p>    <code>int a[5] = &#123;1, 2, 3&#125;;</code></p>\n<p>不初始化,所有元素是垃圾值</p>\n<p>    <code>int a[5];</code></p>\n<p>清零</p>\n<p>    <code>int a[5] = &#123;0&#125;;</code></p>\n<h6 id=\"4-3-二维数组\"><a href=\"#4-3-二维数组\" class=\"headerlink\" title=\"4.3 二维数组\"></a>4.3 二维数组</h6><pre><code>eg：\nint a[3][4];\n共12个元素，可以当做3行4列看待,即\na [0][0] a [0][1] a [0][2] a [0][3]\na [1][0] a [1][1] a [1][2] a [1][3]\na [2][0] a [2][1] a [2][2] a [2][3]\n</code></pre>\n<p><code>a[i][j]</code>表示第<code>i+1</code>行第<code>j+1</code>列的元素</p>\n<p><strong>初始化</strong></p>\n<pre><code>int a[3][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;\n\nint a[3][4] = &#123;\n    &#123;1, 2, 3, 4&#125;,\n    &#123;5, 6, 7, 8&#125;,\n    &#123;9, 10 ,11, 12&#125;,\n&#125;;\n</code></pre>\n<p>输出二维数组内容</p>\n<pre><code>for (i=0; i&lt;3; ++i)\n&#123;\n    for (j=0; j&lt;4; ++j)\n    &#123;\n        printf(&quot;%-5d&quot;,a[i][j]);\n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;\n</code></pre>\n<h6 id=\"4-4-多维数组\"><a href=\"#4-4-多维数组\" class=\"headerlink\" title=\"4.4 多维数组\"></a>4.4 多维数组</h6><p>是否存在多维数组？</p>\n<p>不存在，应为内存是线性一维的。</p>\n<p><mark>n维数组可以当做每个元素是n-1维数组的一维数组</mark></p>\n<p>eg:</p>\n<p><code>int a[3][4][5]</code></p>\n<p>该数组是含有3个元素的一维数组，其中，每个元素都是4行5列的二维数组</p>\n","categories":["C语言","基础知识"],"tags":["C","常识"]},{"title":"C语言基础知识","url":"/2023/01/14/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"<h4 id=\"C语言编程预备知识\"><a href=\"#C语言编程预备知识\" class=\"headerlink\" title=\"C语言编程预备知识\"></a>C语言编程预备知识</h4><hr>\n<h5 id=\"1、基本数据类型\"><a href=\"#1、基本数据类型\" class=\"headerlink\" title=\"1、基本数据类型\"></a>1、基本数据类型</h5><table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th>表示</th>\n<th align=\"center\"><mark>存放字节数</mark></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">整型</td>\n<td>int</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">短整型</td>\n<td>short int</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">长整型</td>\n<td>long int</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">单精度浮点数</td>\n<td>float</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">双精度浮点数</td>\n<td>double</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">字符</td>\n<td>char</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p><mark>注意：一个字节8位，即2^8 &#x3D; 256</mark></p>\n<p>不难得到，两个字节16位，即2^16 &#x3D; 65536</p>\n<p>4个字节32位，有21亿多</p>\n<h5 id=\"2、复合数据类型\"><a href=\"#2、复合数据类型\" class=\"headerlink\" title=\"2、复合数据类型\"></a>2、复合数据类型</h5><ul>\n<li><p>结构体（JAVA里已经没有了）</p>\n</li>\n<li><p><mark>枚举</mark></p>\n</li>\n<li><p>共用体（淘汰）</p>\n</li>\n</ul>\n<h5 id=\"3、变量的本质是内存中的一段存储空间\"><a href=\"#3、变量的本质是内存中的一段存储空间\" class=\"headerlink\" title=\"3、变量的本质是内存中的一段存储空间\"></a>3、变量的本质是内存中的一段存储空间</h5><p><mark><em>定义一个变量，如<code>int i；</code>，就是将内存中的一段空间与<code>i</code>对应。</mark></em></p>\n<p>变量定义：<code>int i=1;</code></p>\n<h5 id=\"4、进制转换\"><a href=\"#4、进制转换\" class=\"headerlink\" title=\"4、进制转换\"></a>4、进制转换</h5><p>C语言规定八进制前面要加0，十六进制前面要加0x或0X<mark>(指数据)</mark>，十进制最为常用则什么都不用加（但在汇编中用D来表示）。</p>\n<p>注意，汇编语言23O（即八进制23）的值&#x3D;2*8+3&#x3D;19（十进制）</p>\n<p><mark>注意：0X36F95FC0表示4个字节</mark></p>\n<p>（一个16进制数如F不是2个字节，F是4位也就是2^4&#x3D;8,所以2个16进制的位数即FF才能表示一个字节，上面共八位16进制数，即4个字节）</p>\n<p>eg：printf的用法</p>\n<ul>\n<li><p>%d表示以十进制输出</p>\n</li>\n<li><p>%x表示以十六进制输出<mark>（指输出控制符）</mark></p>\n</li>\n<li><p>%o表示以八进制输出</p>\n</li>\n</ul>\n<h5 id=\"5、常数的写法\"><a href=\"#5、常数的写法\" class=\"headerlink\" title=\"5、常数的写法\"></a>5、常数的写法</h5><ul>\n<li><p>十进制：传统写法</p>\n</li>\n<li><p>十六进制：前面加0x或0X</p>\n</li>\n<li><p>八进制：前面加0，注意是数字0</p>\n</li>\n<li><p>浮点数_传统写法：<code>float x=3.2</code></p>\n</li>\n<li><p><mark>浮点数_科学计数法</mark>：</p>\n<p><code>float x =3.2e3      //x的值为3200</code></p>\n</li>\n</ul>\n<p>       <code>float x =123.4e-2     //x的值为1.234</code></p>\n<ul>\n<li><p>字符：</p>\n<p>单个字符用单引号括起来：<code>‘AB’</code>错误</p>\n<p>字符串用双引号括起来：<code>“A”</code>正确，因为它表示<code>‘A’</code>与<code>‘\\0’</code>的组合<mark>（<code>‘\\0’</code>作为字符串的结束符）</mark></p>\n</li>\n</ul>\n<h5 id=\"6、常量在计算机中的存储\"><a href=\"#6、常量在计算机中的存储\" class=\"headerlink\" title=\"6、常量在计算机中的存储\"></a>6、常量在计算机中的存储</h5><ul>\n<li><p><mark>整数以补码的形式转换为二进制数 存储在计算机中</mark></p>\n</li>\n<li><p>实数以IEEE754标准转换为二进制代码存住在计算机中</p>\n</li>\n<li><p>字符的本质与整数的存储方式相同（ASCII）</p>\n</li>\n</ul>\n<h5 id=\"7、代码规范化\"><a href=\"#7、代码规范化\" class=\"headerlink\" title=\"7、代码规范化\"></a>7、代码规范化</h5><p> 《高质量C&#x2F;C++编程指南》</p>\n<h5 id=\"8、补码\"><a href=\"#8、补码\" class=\"headerlink\" title=\"8、补码\"></a>8、补码</h5><h6 id=\"补码的优点\"><a href=\"#补码的优点\" class=\"headerlink\" title=\"补码的优点\"></a>补码的优点</h6><ol>\n<li>可以让正数与负数之间进行正确的加法运算</li>\n<li>可以让减法全部变成正数与负数的加法（硬件电路就只需要设计加法器，而不用设计减法器了）</li>\n</ol>\n<p>        <mark>想一想：为什么补码能使0的编码只有一个？</mark></p>\n<h6 id=\"补码的产生\"><a href=\"#补码的产生\" class=\"headerlink\" title=\"补码的产生\"></a>补码的产生</h6><ol>\n<li><p><u>若是直接将数转化为二进制数，则无法表示正负，于是就有了原码。</u></p>\n</li>\n<li><p><u>但是原码在进行正数与负数的加法运算时，计算会出错（如下图，<code>2+（-2）=-4</code>）。</u></p>\n</li>\n</ol>\n<p><img src=\"https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202302192102882.png\" alt=\"image-20230219210226811\"></p>\n<h6 id=\"补码与原码的相互转化\"><a href=\"#补码与原码的相互转化\" class=\"headerlink\" title=\"补码与原码的相互转化\"></a>补码与原码的相互转化</h6><ul>\n<li><p>对于正数：补码与原码相等</p>\n</li>\n<li><p>对于负数：补码是在原码的基础上</p>\n</li>\n</ul>\n<p>            取绝对值，转为二进制</p>\n<p>            按位取反</p>\n<p>            +1</p>\n<h6 id=\"计算机中补码的计算（可能造成疑问的点下图的箭头指名了）\"><a href=\"#计算机中补码的计算（可能造成疑问的点下图的箭头指名了）\" class=\"headerlink\" title=\"计算机中补码的计算（可能造成疑问的点下图的箭头指名了）\"></a>计算机中补码的计算（可能造成疑问的点下图的箭头指名了）</h6><p><img src=\"https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202302192102229.png\" alt=\"image-20230219210252167\"></p>\n<p><mark>eg:对于32位的数来说，有符号数的表示范围为[-2^31, 2^31-1]</mark></p>\n<p><mark>eg:最高位为1，其余位为0，就是最小负数。如：10000000为-128</mark></p>\n<h5 id=\"9、ASCII码\"><a href=\"#9、ASCII码\" class=\"headerlink\" title=\"9、ASCII码\"></a>9、ASCII码</h5><p>eg：<code>printf（“%d”，ch）；（ch是字符型变量）</code>输出结果得67</p>\n<p><mark>原因：ch变量在内存中也是二进制数，上述代码只是将二进制数转化成十进制数输出而已</mark></p>\n<p><mark>0的ASCII码值为48，A为65，a为97。</mark></p>\n<p>&#96;</p>\n","categories":["C语言","基础知识"],"tags":["C","常识"]},{"title":"黑马C++","url":"/2023/01/14/%E9%BB%91%E9%A9%ACcpp/","content":"<h4 id=\"黑马C\"><a href=\"#黑马C\" class=\"headerlink\" title=\"黑马C++\"></a>黑马C++</h4><hr>\n<h5 id=\"一、第一天\"><a href=\"#一、第一天\" class=\"headerlink\" title=\"一、第一天\"></a>一、第一天</h5><pre><code># include &lt;iostream&gt;  //标准的输入输出流 in输入 out输出\nusing namespace std;  //使用命名空间 std 打开一个叫std的房间\n\n//程序入口\nint main(void)\n&#123;\n    // cout 标准的输出\n    // &lt;&lt; 拼接的作用\n    // endl 结束换行\n    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; 123 &lt;&lt; endl;\n    system(&quot;pause&quot;);  //阻塞功能\n    return EXIT_SUCCESS;  //返回正常退出\n&#125;\n</code></pre>\n<h6 id=\"1-1-双冒号作用域运算符\"><a href=\"#1-1-双冒号作用域运算符\" class=\"headerlink\" title=\"1.1 双冒号作用域运算符\"></a>1.1 双冒号作用域运算符</h6><p><code>::</code>:作用域运算符有两种用法</p>\n<p>1、作用域::变量名或其它名</p>\n<pre><code>eg:\nstd::cout (用了这个，就不用using namespace std;了)\n</code></pre>\n<p>2、</p>\n<p>::变量名</p>\n<pre><code>int atk = 200;\nvoid test01(void)\n&#123;\n    int atk = 100;\n    cout &lt;&lt; &quot;攻击力：&quot; &lt;&lt; atk &lt;&lt; endl;\n    // ::双冒号（作用域运算符 :: 全局作用域）\n    cout &lt;&lt; &quot;全局攻击力：&quot; &lt;&lt; ::atk &lt;&lt; endl;\n&#125;\n输出结果：\n----------------\n攻击力：100\n全局攻击力：200\n----------------\n</code></pre>\n<h6 id=\"1-2-namespace-命名空间\"><a href=\"#1-2-namespace-命名空间\" class=\"headerlink\" title=\"1.2 namespace(命名空间)\"></a>1.2 namespace(命名空间)</h6><p><strong>用途</strong>：解决命名冲突问题<strong>注意</strong>：必须在全局作用域下声明<strong>内容</strong>：命名空间中可以放入函数，变量，结构体，类（命名空间还可以嵌套命名空间）<strong>另外</strong>：命名空间是开放的，可以随时加入新的成员；且命名空间可以起别名</p>\n<h6 id=\"1-3-using的使用\"><a href=\"#1-3-using的使用\" class=\"headerlink\" title=\"1.3 using的使用\"></a>1.3 using的使用</h6><p>1、使用using时，要避免局部变量与之冲突</p>\n<p>2、就近原则的优先级高于“打开房间”这个操作</p>\n<p>3、用using打开两个房间，会导致程序不知道用哪个</p>\n<h6 id=\"1-4-cpp对c语言的增强\"><a href=\"#1-4-cpp对c语言的增强\" class=\"headerlink\" title=\"1.4 cpp对c语言的增强\"></a>1.4 cpp对c语言的增强</h6><pre><code>* 全局变量检测增强\n\n* 函数检测增强:形参前必须要有类型;若定义函数名前不是void，则必须要有返回值;函数调用参数检测增强;\n\n* 类型转换检测增强\n\n* 结构体(struct)增强:cpp中结构体可以放函数,C语言中构造结构体用struct Person p1;cpp中可以直接用Person p1;\n\n* 相比C语言新增bool类型:bool flag = true;\n\n* 三目运算符的增强a&gt;b ? a : b = 100; b的值会被改成100(三目运算符中C语言返回的是值，cpp返回的是变量)\n</code></pre>\n<h6 id=\"1-5-const-常量\"><a href=\"#1-5-const-常量\" class=\"headerlink\" title=\"1.5 const(常量)\"></a>1.5 const(常量)</h6><p><strong>1、const不分配内存，但取地址会分配临时内存</strong></p>\n<p>c语言中，const修饰的变量，是伪常量，编译器是会分配内存的（可以用指针修改）</p>\n<p>cpp中，const不会分配内存，而是放在符号表中</p>\n<p>eg: <code>const int n_a = 10；</code><strong>（基本上只有这个方式，不会分配内存，而是放到符号表中）</strong></p>\n<table>\n<thead>\n<tr>\n<th>key(键值)</th>\n<th>value(实值)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>n_a</td>\n<td>10</td>\n</tr>\n</tbody></table>\n<pre><code>const int b = 20;\nint* p = (int*)&amp;b;\n*p = 200;\ncout &lt;&lt; b &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n输出结果：\n20\n200\n\n为什么会输出200？\n在int* p = (int*)&amp;b;中编译器会临时开辟一块内存空间；\n相当于：\nint tmp = b;  //给tmp分配了一块内存空间，将b的值赋给它\nint* p = (int *)&amp;tmp;  //*p指向的是临时的那块空间\n</code></pre>\n<p><strong>2、用extern 编译器也会给const变量分配内存</strong></p>\n<p>C语言中，默认const是外部链接</p>\n<p>cpp中，默认const是内部链接（即只有在当前文件夹内才能访问）</p>\n<p>如果想提高const的作用域，用<code>extern</code></p>\n<p><code>extern const int a = 10;</code>(可将const转换为外部链接)</p>\n<p><strong>3、用变量初始化const变量</strong></p>\n<pre><code>int a = 10;\nconst int b = a;  //会分配内存\n</code></pre>\n<p><strong>注意：只要是分配内存的，都能用指针修改它</strong></p>\n<p><strong>4、自定义数据类型分配内存</strong></p>\n<pre><code>struct Person\n&#123;\n    string m_Name;\n    int m_Age;\n&#125;\n</code></pre>\n<p><strong>5、尽量用const来代替#define</strong></p>\n<pre><code>在旧版本c中，如果想建立一个常量，必须使用预处理器\n#define MAX 1024;\n我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX都已经被替换为了1024\n因此，并没有将MAX加入到符号表中。但如果我们使用这个常量获得一个错误的编译错误信息时，\n我们看到的是1024而非MAX。若MAX被定义在一个不是我写的头文件中，我可能不知道1024意味着什么，\n为了解决这个问题可能要花费很长时间。\n解决办法就是用一个常量替换上面的宏\nconst MAX = 1024;\n1.const有类型，可进行编译器安全检查\n2.const有作用域，而#define默认是从定义处到程序结束\n</code></pre>\n<h6 id=\"1-6-引用\"><a href=\"#1-6-引用\" class=\"headerlink\" title=\"1.6 引用\"></a>1.6 引用</h6><p><strong>1、引用的实质就是起别名(<code>类型 &amp;别名 = 原名;</code>)</strong></p>\n<pre><code>int a = 10;\nint &amp;b = a;就是给变量a取一个别名b(实质：int* const b = &amp;a ;b存放的是a的地址)\n(当使用b时,eg:b = 10;实质上是:*b = 10;)\n(&amp;写到等号左侧，叫引用；写到右侧，就是取地址符)\n</code></pre>\n<p><strong>2、引用初始化后不可修改</strong></p>\n<p>即b做了a的别名以后，不能再做c的别名</p>\n<ul>\n<li><p>对数组建立引用</p>\n<p>  int arr[10];<br>  for (int i&#x3D;0; i&lt;10; ++i)<br>  {</p>\n<pre><code>  arr[i] = i;\n</code></pre>\n<p>  }<br>  &#x2F;&#x2F;第一种方式<br>  int (&amp;pArr)[10] &#x3D; arr;<br>  for (int i; i&lt;10; ++i)<br>  {</p>\n<pre><code>  cout &lt;&lt; pArr[i] &lt;&lt; &quot; &quot;;\n</code></pre>\n<p>  }<br>  cout &lt;&lt; endl;<br>  &#x2F;&#x2F;第二种方式<br>  typedef int(ARRAYREF)[10];  &#x2F;&#x2F;一个具有十个元素的int类型数组<br>  ARRAYREF &amp;pArr2 &#x3D; arr;<br>  for (int i &#x3D; 0; i &lt; 10; ++i)<br>  {<br>      cout &lt;&lt; pArr2[i] &lt;&lt; “ “;<br>  }<br>  cout &lt;&lt; endl;</p>\n</li>\n</ul>\n<p><strong>3、引用的注意事项</strong></p>\n<ul>\n<li><p>引用必须引一块合法(存在、能引用)的内存空间</p>\n</li>\n<li><p>不要返回局部变量的引用</p>\n</li>\n</ul>\n<p><strong>4、引用的本质(是一个指针常量)</strong></p>\n<pre><code>int a = 10;\nint&amp; aRef = a;  //自动转换为int* const aRef = &amp;a;这也能说明为什么必须初始化\naRef = 20;  //内部发现aRef是引用，自动帮我们转换为：*aRef = 20；`````````````````````\n</code></pre>\n<p><strong>5、常量引用</strong></p>\n<pre><code>//int&amp; ref = 10;  //引用了不合法的内存\nconst int&amp; ref = 10;  //加入const后，编译器处理方式为：int tmp = 10;const int &amp;ref = tmp;\n//ref = 10;\nint* p = (int*)&amp;ref;\n*p = 1000;\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\n输出结果：\n----------------\nref = 1000\n----------------\n</code></pre>\n<p><strong>6、用一级指针引用可以代替二级指针</strong></p>\n<pre><code>void f(int &amp;p)  //主调函数传过来一个值，用&amp;能直接提取该值的地址\n&#123;\n    ;\n&#125;\n</code></pre>\n<p><strong>7、使用场景：修饰形参为只读（防君子不防小人）</strong></p>\n<pre><code>void showValue(const int &amp;val)\n&#123;\n    val += 1000;  //如果只是想显示内容，而不修改内容，那么就用const修饰这个形参\n    cout &lt;&lt; &quot;val = &quot; &lt;&lt; val &lt;&lt; endl;\n&#125;\n</code></pre>\n<p><strong>8、注意：const int &amp;a &#x3D; 10;会分配内存</strong></p>\n<h5 id=\"二、第二天\"><a href=\"#二、第二天\" class=\"headerlink\" title=\"二、第二天\"></a>二、第二天</h5><h6 id=\"2-1-class\"><a href=\"#2-1-class\" class=\"headerlink\" title=\"2.1 class\"></a>2.1 class</h6><pre><code>类的创建\nclass 类名\n&#123;\npublic:  //公共权限\n//设置成员属性\n//设置成员函数\n&#125;\n实例化对象\n类名 对象名;\n通过对象来设置属性，调用成员函数\n</code></pre>\n<p><strong>类是对对象的抽象对象是对类的实例</strong></p>\n<h6 id=\"2-2-内联函数-用于代替C语言中的预处理宏\"><a href=\"#2-2-内联函数-用于代替C语言中的预处理宏\" class=\"headerlink\" title=\"2.2 内联函数(用于代替C语言中的预处理宏)\"></a>2.2 内联函数(用于代替C语言中的预处理宏)</h6><p>宏：</p>\n<pre><code>C语言为什么要用宏？\n答：我们在编程时，有一些很短但是执行频繁的计算；因为太短了，我不想写成函数，又可以避免函数调用的开销，所以用宏。\n\n但是宏有不小的缺点，宏的缺点如下：\n1、运行结果与预想的不符(宏看起来像一个函数调用，但会隐藏一些难以发现的错误)\neg:\n定义一个加法\n#define MyADD(x, y) x+y\nvoid test01()\n&#123;\n    int ret = MyADD(10, 20) * 20;\n    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;\n&#125;\n输出结果：\n-------------\nret = 410\n-------------\n可以预想到实际运行的是x+y*20 = 410\n\n优化一下（把括号加上，避免算数优先级导致问题）：\n#define MyCompare(a, b) ((a) &lt; (b)) ? (a) : (b)\nvoid test02()\n&#123;\n    int a = 10;\n    int b = 20;\n    int ret = MyCompare(++a, b);\n\n    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;\n&#125;\n输出结果：\n-------------\nret = 12\n-------------\n还是与预想的11不符\n\n2、在cpp中，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类的成员函数\n</code></pre>\n<p>内联函数：</p>\n<pre><code>内联函数定义\ninline 函数定义\neg：\ninline void mycompare(int a, int b)\n&#123;\n    int ret = a &lt; b ? a : b\n    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;\n&#125;\n\n内联函数注意事项：\ninline void func();  //内联函数声明\ninline void func()\n&#123; \n    ; \n&#125;  //如果函数实现的时候，没有加inline关键字，那么这个函数依然不算内联函数\n\n内联函数的优点：\n&quot;以空间换时间&quot;（内联函数除了没有宏的缺点外，基本可以当做宏来使用）\n\n内联函数与class：\n在class(类)中，成员函数默认都是加了内联函数关键字(inline)的\n\n内联函数与编译器：\n内联函数只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有\n将函数声明为内联函数，编译器也可能将小的，简单的函数声明为内联函数；\n在这些情况下，编译器不会将inline关键字修饰的函数当内联函数处理\n1.不能存在任何形式的循环语句\n2.不能存在过多的条件判断语句\n3.函数体不能过于庞大\n4.不能对函数进行取址操作\n</code></pre>\n<h6 id=\"2-3-函数的默认参数\"><a href=\"#2-3-函数的默认参数\" class=\"headerlink\" title=\"2.3 函数的默认参数\"></a>2.3 函数的默认参数</h6><pre><code>//函数的默认参数 参数后面 = ......\n//函数参数的注意事项，如果有一个位置有了默认参数，那么从这个位置开始，从左往右都必须有默认参数\nvoid func(int a =10, int b, int c =1)  //a有了默认参数，a右边的b没有，报错\n&#123;\n    cout &lt;&lt; &quot;ａ+ b + c = &quot; &lt;&lt; a + b + c&lt;&lt; endl;\n&#125;\nvoid test01()\n&#123;\n    func(1, 2, 3);\n&#125;\n注意:\n//函数声明里面有了默认参数，那么函数实现的时候必须没有\n//函数声明和实现中，只能有一个默认参数，不要同时出现，因为我可能写的不一样，编译器不知道用哪个\nvoid myFunc(int a = 10, int b = 10);\nvoid myFunc(int a = 10, int b = 10)&#123;&#125;\n报错：重定义默认参数\n</code></pre>\n<p>附加：占位参数</p>\n<pre><code>//函数 占位参数\n//如果有了占位参数，函数调用时候必须要提供这个参数，但是用不到这个参数\n//占位参数 没有什么用 只有后面重载 ++符号才有一点用\n//占位参数 可以有默认值\nvoid func2(int a, int)\n&#123;\n\n&#125;\nvoid test02()\n&#123;\n    func2(10, 1);\n&#125;\n</code></pre>\n<h6 id=\"专题：函数重载-overload\"><a href=\"#专题：函数重载-overload\" class=\"headerlink\" title=\"专题：函数重载(overload)\"></a>专题：函数重载(overload)</h6><p>实现函数重载的条件</p>\n<p>1、同一个作用域</p>\n<p>2、参数个数不同or参数类型不同or参数顺序不同</p>\n<p>3、返回值类型不能作为函数重载的条件（因为调用函数时eg：func(a,b);无法区分到底用不用返回值）</p>\n<p>4、当函数重载碰到了默认参数时，要注意避免二义性问题</p>\n<pre><code>eg:\nvoid func2(int a, int b = 10)\n&#123;\n\n&#125;\nvoid func2(int a)\n&#123;\n\n&#125;\n</code></pre>\n<p>5、const也可以作为重载的条件</p>\n<pre><code>void func3(const int &amp;a)  //引用必须要引合法的内存空间//const也可以作为重载的条件\n&#123;\n\n&#125;\nvoid test03()\n&#123;\n    int a = 10;\n    func3(10);\n&#125;\n</code></pre>\n<p>函数重载的原理</p>\n<pre><code>为实现函数重载，不同的编译器会用不同的机制来修饰函数名\n如：void func(),编译器内部可能会将其修饰为_func;\nvoid func(int x),编译器内部可能将其修饰为_func_int;\nvoid func(int x, cahr c),编译器内部可能将其修饰为_func_int_char\n</code></pre>\n<h6 id=\"2-4-extern-“C”浅析\"><a href=\"#2-4-extern-“C”浅析\" class=\"headerlink\" title=\"2.4 extern “C”浅析\"></a>2.4 extern “C”浅析</h6><pre><code>解决的问题 在C++中调用C语言的函数(由于函数重载，C++中编译器可能会把函数名改掉)\n(C++比C语言多了些特性，所以直接调用可能会出问题，用下面的方式能屏蔽C++的特性，用C语言的语法规则使用函数)\n\n调用多个：\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n......(C语言的函数 eg: void func(); )\n#ifdef __cplusplus\n&#125;\n#endif\n\n调用单个:\nextern &quot;C&quot; void func();\n</code></pre>\n<h6 id=\"专题：封装\"><a href=\"#专题：封装\" class=\"headerlink\" title=\"专题：封装\"></a>专题：封装</h6><p><strong>1、属性和行为作为一个整体来表示生活中的事物</strong></p>\n<p>（与C语言相区分，C语言中strucrt中不能放函数，就可能造成“人”的行为作用到“狗”的属性上）</p>\n<p><strong>2、在c++中struct和class是一个意思，唯一的不同，默认权限， struct是public，而class默认权限是private</strong></p>\n<p><strong>3、私有权限(private) 就是私有成员，在类内部可以访问，类外部不可访问公共权限(public) 在类内部和外部都可以访问保护权限(protected) 类内部可以访问（以及当前类子类可以访问），类外部不可以访问</strong></p>\n<p><strong>建议：将所有成员变量都设置为private，对外提供读或写的接口</strong></p>\n<h5 id=\"三、第三天\"><a href=\"#三、第三天\" class=\"headerlink\" title=\"三、第三天\"></a>三、第三天</h5><h6 id=\"3-1-分文件编写\"><a href=\"#3-1-分文件编写\" class=\"headerlink\" title=\"3.1 分文件编写\"></a>3.1 分文件编写</h6><p><code>.h</code>中写类的成员函数的申明</p>\n<p><code>.cpp</code>中写成员函数的实现</p>\n<h6 id=\"3-2-对象的构造-初始化-与析构-清理\"><a href=\"#3-2-对象的构造-初始化-与析构-清理\" class=\"headerlink\" title=\"3.2 对象的构造(初始化)与析构 (清理)\"></a>3.2 对象的构造(初始化)与析构 (清理)</h6><p>1、对象的初始化与清理</p>\n<pre><code>当定义了一个类后\nPerson p1;  \n程序员若没有提供构造函数和析构函数\n编译器就默认调用了构造函数和析构函数，但此时构造函数和析构函数是系统提供的两个空实现的函数\n\n构造函数：\n1.与类名相同,没有返回值，不写void，可以发生重载（即可以有参数，可以有多个构造函数）\n2.构造函数由编译器自动调用，而不是手动，而且只会调用一次\n\n3.\neg:\nPerson()\n&#123;\n    cout &lt;&lt; &quot;构造函数的调用&quot; &lt;&lt; endl;\n&#125;\n\n析构函数：\n1.与类名相同，类名前面加一个符号 &quot;~&quot;，也没有返回值，不写void，不可以有参数（不能发生函数重载）\n2.析构函数由编译器自动调用，而不是手动，而且只会调用一次\n3.构函数调用于主调函数结束之后。所以如果是在main函数中调用，要等函数全部执行完才调用，我们就看不到。\n4.\neg:\n~Person()\n&#123;\n    cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;\n&#125;\n注意：构造和析构必须写在public下\n</code></pre>\n<p>2、构造函数的分类及调用</p>\n<pre><code>1.按照参数有无进行分类:\n无参构造函数的写法：\nPerson()  //无参构造函数又叫默认构造函数\n&#123;\n    cout &lt;&lt; &quot;无参构造函数调用&quot; &lt;&lt; endl;\n&#125;\n无参构造函数的调用：\nPerson p1;(注意：不要写成 Person p1(); 编译器会把这个当做是函数声明\n有参构造函数的写法：\nPerson(int a)\n&#123;\n    cout &lt;&lt; &quot;有参构造函数调用&quot; &lt;&lt; endl;\n&#125;\n有参构造函数的调用：\nPerson p2(10);   or   Person p2 = Person(10);\n\n**附加知识点**\nPerson(10)； 匿名对象，执行当前行后就会释放这个对象（注意与上面的区分）\n\n2.按照类型进行分类\n普通构造函数（就是上面的无参和有参）\n拷贝构造函数的写法\nPerson(const Person&amp; p)//因为是“拷贝”，不让修改，所以加const\n&#123;\n    m_Age = p.m_Age;\n    cout &lt;&lt; &quot;拷贝构造函数调用&quot; &lt;&lt; endl;\n&#125;\n拷贝构造函数的调用\nPerson p1(p2);   or   Person p1 = Person(p2);\n\n注意：不能用拷贝构造函数初始化匿名对象\neg：\nPerson(p5);  //如果这么写，编译器会认为你写的是 Person p5; 即对象的声明\n</code></pre>\n<p>注意：隐式类型转换</p>\n<pre><code>Person p7 = 100;  //相当于调用了Person p7 = Person(100);  隐式类型转换\nPerson p8 = p7;  //相当于调用了Person p8 = Person(p7);  隐式类型转换\n</code></pre>\n<p>3、拷贝构造函数调用时机</p>\n<p>（1）用已经创建好的对象来初始化新的对象</p>\n<pre><code>void test01()\n&#123;\n    Person p1;\n    p1.m_Age = 10;\n    Person p2 = Person(p1);\n&#125;\n</code></pre>\n<p>（2）以值传递的方式给函数的参数传值</p>\n<pre><code>void doWork(Person p1)  //Person p1 = Person(p);\n&#123;\n\n&#125;\nvoid test02()\n&#123;\n    Person p;\n    p.m_Age = 10;\n    doWork(p);\n&#125;\n</code></pre>\n<p>（3）以值方式返回局部对象</p>\n<pre><code>Person doWork2()\n&#123;\n    Person p1;\n    return p1;\n&#125;\nvoid test03()\n&#123;\n    Person p = doWork2();\n&#125;\n</code></pre>\n<p>4、构造函数的调用规则</p>\n<p>默认情况下，c++编译器至少为我们写的类提供三个函数</p>\n<p>1.默认构造函数（无参，函数体为空）</p>\n<p>2.默认析构函数（无参，函数体为空）</p>\n<p>3.默认拷贝构造函数，对类中非静态成员属性简单值拷贝</p>\n<p>注意：当用户定义了有参的构造，系统就不会提供默认构造函数，但是会提供拷贝构造函数</p>\n<p>注意：当用户定义了拷贝构造，c++就不会提供其它构造函数</p>\n<h6 id=\"3-3-深拷贝和浅拷贝\"><a href=\"#3-3-深拷贝和浅拷贝\" class=\"headerlink\" title=\"3.3 深拷贝和浅拷贝\"></a>3.3 深拷贝和浅拷贝</h6><p>系统默认提供的拷贝构造，会进行简单的值拷贝</p>\n<p>如果属性里有指向堆区空间的数据，那么简单的浅拷贝会导致重复释放内存的异常</p>\n<p>解决上述问题，需要我们自己提供拷贝构造函数，进行深拷贝</p>\n<h6 id=\"3-4-初始化列表\"><a href=\"#3-4-初始化列表\" class=\"headerlink\" title=\"3.4 初始化列表\"></a>3.4 初始化列表</h6><p>在构造函数后面 + ： 属性（值 or 参数），属性（值 or 参数）…</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","categories":["cpp","基础知识"],"tags":["常识","cpp"]},{"title":"函数与指针","url":"/2023/01/14/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8C%87%E9%92%88/","content":"<h4 id=\"函数与指针\"><a href=\"#函数与指针\" class=\"headerlink\" title=\"函数与指针\"></a>函数与指针</h4><hr>\n<h5 id=\"1、函数\"><a href=\"#1、函数\" class=\"headerlink\" title=\"1、函数\"></a>1、函数</h5><h6 id=\"1-1-为什么需要函数\"><a href=\"#1-1-为什么需要函数\" class=\"headerlink\" title=\"1.1 为什么需要函数\"></a>1.1 为什么需要函数</h6><ul>\n<li><p>避免了重复性操作</p>\n</li>\n<li><p>有利于程序的模块化（一个main函数的功能通过调用的几个函数实现，这几个函数又通过调用一些函数实现）</p>\n</li>\n</ul>\n<h6 id=\"1-2-什么叫函数\"><a href=\"#1-2-什么叫函数\" class=\"headerlink\" title=\"1.2 什么叫函数\"></a>1.2 什么叫函数</h6><p>逻辑上：能够完成特定功能的独立的代码块</p>\n<p>物理上：</p>\n<p>能够接收数据（也可以不接收）</p>\n<p>能够对接收的数据进行处理（也可以不处理）</p>\n<p>能够将数据处理的结果返回（也可以不返回）</p>\n<p>总结：函数是个用于解决大量类似问题的工具。</p>\n<h6 id=\"1-3-如何定义函数\"><a href=\"#1-3-如何定义函数\" class=\"headerlink\" title=\"1.3 如何定义函数\"></a>1.3 如何定义函数</h6><p>格式：</p>\n<pre><code>函数的返回值 函数的名字（函数的形参列表）\n&#123;\n    函数的执行体\n&#125;\n函数定义的本质是详细描述函数实现某个特定功能的具体方法\n</code></pre>\n<p><mark>已知的语言全是用压栈的方式进行函数调用</mark></p>\n<pre><code>//main调用f，就要为f分配空间，怎么分配空间？就是在一个栈里面为它分配。那f调用期间用调用g，是不是要把g的空间也压栈呀！所以g里面的形参包括里面的局部变量统统都是以栈的方式来分配的。所以为什么它不能跨函数使用？为什么g函数终止之后，g里面的空间不能被f使用？因为你这函数一终止，这个东西就出栈了（就是把栈中为g分配的空间抛出去）。\n</code></pre>\n<h6 id=\"专题：return表达式\"><a href=\"#专题：return表达式\" class=\"headerlink\" title=\"专题：return表达式\"></a>专题：return表达式</h6><p><mark>函数返回值的类型也称为函数的类型</mark>（当函数返回值的数据类型与函数名前面数据类型冲突时，以函数名前面的数据类型为准）</p>\n<pre><code>eg：\nint f()\n&#123;\n    return 10.5;\n&#125;\n最后的返回值为10\n</code></pre>\n<p>return表达式的作用</p>\n<p><mark>终止被调函数，向主调函数返回表达式的值</mark></p>\n<p>注意:主函数是程序的入口，也是程序的出口（一个程序只能有一个主函数）</p>\n<p><mark>函数内部定义的变量只在本函数中使用</mark></p>\n<h6 id=\"1-4-函数的声明\"><a href=\"#1-4-函数的声明\" class=\"headerlink\" title=\"1.4 函数的声明\"></a>1.4 函数的声明</h6><pre><code>eg：\nvoid f(void);\n</code></pre>\n<p><mark>作用：告诉编译器<code>f</code>是个函数名</mark></p>\n<p>为什么要函数的声明？</p>\n<p><mark>避免调用函数的语句放在了定义函数的语句的前面</mark></p>\n<p><mark>对库函数的声明已通过<code> # include &lt;库函数所在文件的名字.h&gt;</code>声明了</mark></p>\n<h6 id=\"专题：递归\"><a href=\"#专题：递归\" class=\"headerlink\" title=\"专题：递归\"></a>专题：递归</h6><ol>\n<li><p>函数自己调用自己</p>\n</li>\n<li><p>只递不归会导致程序崩溃</p>\n</li>\n<li><p>要在适当的时候终止递归</p>\n</li>\n</ol>\n<h6 id=\"专题：变量的作用域和存储方式\"><a href=\"#专题：变量的作用域和存储方式\" class=\"headerlink\" title=\"专题：变量的作用域和存储方式\"></a>专题：变量的作用域和存储方式</h6><p><strong>按作用域分：</strong></p>\n<p>全局变量</p>\n<p><mark>在所有函数外部定义的变量，就叫全局变量</mark></p>\n<p>全局变量使用范围：</p>\n<p><mark>从定义位置开始到整个程序结束</mark></p>\n<p>局部变量</p>\n<p><mark>在一个函数内部定义的或者说函数的形参，都统称为局部变量</mark></p>\n<p>局部变量使用范围：</p>\n<p><mark>只能在本函数内部使用</mark></p>\n<pre><code>eg：\nvoid f(int i)\n&#123;\n    int j = 100;\n&#125;\ni（形参）和j（内部定义的变量）都属于局部变量\n注意：一旦函数运行完毕，为这个函数分配的所有静态空间都会释放，（避免重复调用函数造成内存占用）\n</code></pre>\n<p>当全局变量与局部变量命名冲突时：</p>\n<p><u>在一个函数内部，如果定义的局部变量的名字与全局变量的名字一样时，局部变量会屏蔽到全局变量（C语言设计时这样规定的）</u></p>\n<p><strong>按变量的存储方式分：</strong></p>\n<p>静态变量</p>\n<p>自动变量</p>\n<p>寄存器变量</p>\n<h5 id=\"2、指针\"><a href=\"#2、指针\" class=\"headerlink\" title=\"2、指针\"></a>2、指针</h5><h6 id=\"2-1-理解指针-重要\"><a href=\"#2-1-理解指针-重要\" class=\"headerlink\" title=\"2.1 理解指针(重要)\"></a>2.1 理解指针(重要)</h6><pre><code>int * p;\nint i = 3;\np = i;   //错误，因为类型不一致，p只能存放int类型变量的地址，不能存放int类型的变量\np = 55；  //错误，原因同上\np = &amp;i;   //正确\n</code></pre>\n<p>注意：<mark>指针就是地址，地址就是指针。<code>i</code>的指针也可以叫<code>i</code>的地址</mark>（所以指针是一个值，指针变量是一个变量，但是请注意，那些牛马在叙述时会把指针变量简称为指针，实际上，它们的含义并不一样）</p>\n<p>地址就是内存单元的编号</p>\n<p>指针变量是存放地址的变量</p>\n<p>指针的本质就是一个操作受限的非负整数（指针只能进行减法运算）</p>\n<pre><code>int main(void)\n&#123;\n    int* p;  //p是变量的名字，int* 表示p变量存放的是int类型变量的地址（相当于p是变量的名字，p变量的数据类型是 int* 类型， ）\n             //所谓 int* 类型：就是存放 int型变量的 地址的类型\n    int i = 3；\n    int j；    ·\n\n    p = &amp;i;\n    /* \n        p保存了i的地址，因此p指向i（因为p里面有i的地址，通过p可以找到i，我们有一个专有词叫‘指向’）\n        p不是i，i也不是p，更准确的说，修改p的值不影响i的值，修改i的值也不会影响p\n        p是一个特殊的变量（可以存放整数类型的变量的地址），但它仍然是个变量\n        如果一个指针变量指向了某个普通变量，则 *指针变量 就完全等同于普通变量\n\n        例子：\n            如果p是个指针变量，并且p存放了普通变量i的地址\n            则p指向了普通变量i\n            *p 就完全等同于 i   （*表示取地址的逆运算）\n            或者说： 在所有出现*p的地方都可以替换成i\n                    在所有出现i的地方都可以替换成*p\n            *p 就是以p的内容为地址的变量\n     */\n    j = *p;\n    printf(&quot;i = %d, j = %d, *p = %d\\n&quot;, i, j, *p);\n\n    return 0;\n&#125;\n输出值为：\ni = 3, j = 3, *p = 3\n</code></pre>\n<h6 id=\"2-2-指针的重要性\"><a href=\"#2-2-指针的重要性\" class=\"headerlink\" title=\"2.2 指针的重要性\"></a>2.2 指针的重要性</h6><ul>\n<li><p>能够表示一些复杂的数据结构</p>\n</li>\n<li><p>能够快速的传递数据，减少了内存的耗用</p>\n</li>\n<li><p>能够使函数返回一个以上的值(不然只能用return返回一个值)</p>\n</li>\n<li><p>能够直接访问硬件</p>\n</li>\n<li><p>能够方便的处理字符串</p>\n</li>\n<li><p>是理解面向对象语言中引用的基础</p>\n</li>\n</ul>\n<p>总结：指针是C语言的灵魂</p>\n<h6 id=\"专题：-的含义\"><a href=\"#专题：-的含义\" class=\"headerlink\" title=\"专题：*的含义\"></a>专题：*的含义</h6><ul>\n<li><p>乘法</p>\n</li>\n<li><p>定义指针变量</p>\n<p>  int* p;<br>  定义了一个名字叫p的变量，int*表示p只能存放int类型变量的地址</p>\n</li>\n<li><p>指针运算符</p>\n<p> 如果p是一个已经定义好的指针变量，则<mark>*p表示以p的内容为地址的变量</mark></p>\n<p>  如何通过被调函数修改主调函数普通变量的值：<br>  1.实参必须为该普通变量的地址<br>  2.形参必须为指针变量<br>  3.在被调函数中通过<br>      *形参名<br>  的方式就可以修改主调函数相关变量的值</p>\n</li>\n</ul>\n<h6 id=\"2-3-指针和数组\"><a href=\"#2-3-指针和数组\" class=\"headerlink\" title=\"2.3 指针和数组\"></a>2.3 指针和数组</h6><p><mark>一维数组名是个指针常量，它存放的是一维数组第一个元素的地址</mark></p>\n<p>（因为是指针<mark>常量</mark>，所以数组名的值不可更改）</p>\n<p>如果p是个指针变量，则</p>\n<p><mark><code>p[i]</code>永远等价于<code>*(p+i)</code></mark></p>\n<pre><code>eg:\nprintf(&quot;%d\\n&quot;,*c);  //输出第一个元素的值\nprintf(&quot;%d\\n&quot;, *(c+3));  //输出第4个元素的值\n//c+3完成了向后移动三个地址单元\n</code></pre>\n<p>补充：数组元素<code>a[i]</code>就是当作<code>*(a+i)</code>去处理的，先通过数组名<code>a</code>找到数组的首地址，然后首地址<code>a+i</code>得到<code>a[i]</code>的地址</p>\n<p>函数要处理一个一元数组，需要两个参数，即</p>\n<p>数组的第一个元素的地址和数组的长度</p>\n<h6 id=\"2-4-指针变量的运算\"><a href=\"#2-4-指针变量的运算\" class=\"headerlink\" title=\"2.4 指针变量的运算\"></a>2.4 指针变量的运算</h6><p>指针变量不能相加，不能相乘，不能相除</p>\n<p>如果两个指针变量指向的是同一块连续空间中的不同存储单元，则这两个指针变量才可以相减</p>\n<h6 id=\"专题：一个指针变量到底占几个字节\"><a href=\"#专题：一个指针变量到底占几个字节\" class=\"headerlink\" title=\"专题：一个指针变量到底占几个字节\"></a>专题：一个指针变量到底占几个字节</h6><pre><code>预备知识：\nsizeof(数据类型)\n功能：返回值就是该数据类型所占的字节数\neg:\nsizeof(int) = 4\nsizeof(char) = 1\nsizeof(double) = 8\n\nsizeof(变量)\n功能：返回值就是该变量所占的字节数\n</code></pre>\n<p>假设p指向char类型变量（1个字节）</p>\n<p>假设q指向int类型变量（4个字节）</p>\n<p>假设r指向double类型变量（8个字节）</p>\n<p><code>p q r </code>本身所占字节数是否一样?</p>\n<pre><code>char ch = &#39;A&#39;;\nint i = 99;\ndouble x = 66.6;\nchar* p = &amp;ch;\nint* q = &amp;i;\ndouble* r = &amp;x;\nprintf(&quot;%d %d %d\\n&quot;, sizeof(p), sizeof(q), sizeof(r));\n//在VScode的输出结果为：\n---------------------\n8 8 8\n---------------------\n即 p q r 本身所占字节数是一样的。\n根据郝斌P139的讲解，得出结论：\n在p,q,r中，它只保存ch,i,x的第一个字节的地址。\n\n问：但既然*q=i，q只知道i第一个字节地址的话，但是i如果占好几个字节呢,它如何知道i占几个字节呢？\n答：这在int* q = &amp;i;中给出了，就是定义了是int*类型的指针变量\n\n问：那既然p,q,r只保存了ch,i,x的第一个字节地址，为什么它们又都占8个字节(64GB)呢？\n答：虽然只保存了第一个字节地址，但这个地址是编号啊，这个编号本身就要8个字节来保存（就像造了一亿个房子，这个房子的容量虽然只有这么大，但是房子很多，它的编号就会很大）可能这个VScode认为的那个计算机是64根地址总线，刚好控制2^64个内存单元，即64GB\n</code></pre>\n<p><mark>注意：一个变量的地址使用该变量首个内存单元的地址来表示</mark>（因为一个内存单元就是一个字节，一个变量的地址使用该变量首字节的地址来表示）</p>\n<h6 id=\"专题：动态内存分配-重要\"><a href=\"#专题：动态内存分配-重要\" class=\"headerlink\" title=\"专题：动态内存分配(重要)\"></a>专题：动态内存分配(重要)</h6><p><strong>传统数组的缺点：</strong></p>\n<p>1.数组长度必须事先指定，且只能是常整数，不能是变量</p>\n<pre><code>eg:\nint a[5];  //OK\nint len = 5;int a[len]; //error\n</code></pre>\n<p>2.传统形式定义的数组，该数组的内存程序员无法手动释放</p>\n<p>(在一个函数运行期间，系统为该函数中数组所分配的空间会一直存在，直到该函数运行完毕时，数组的空间才会释放)</p>\n<p>3.数组的长度一旦定义，其长度就不能再更改</p>\n<p>(数组的长度不能在函数的运行的过程中动态的扩充或缩小)</p>\n<p>4.A函数定义的数组，在A函数运行期间可以被其它函数使用；但A函数运行完毕之后，A函数中的数组将无法再被其它函数使用（为什么能使用？因为用到数组的函数的形参都是地址啊）</p>\n<pre><code>void g(int* pArr, int len)\n&#123;\n    pArr[2] = 88;\n&#125;\n\nvoid f(void)\n&#123;\n    int a[5] = &#123;1,2,3,4,5&#125;;  //20个字节的存储空间程序员无法手动编程释放，它只能在本函数运行完毕时由系统自动释放\n    g(a, 5);\n    printf(&quot;%d\\n&quot;, a[2]);\n&#125;\n\nint main(void)\n&#123;\n    f();\n    return 0;\n&#125;\n</code></pre>\n<h6 id=\"为什么需要动态分配内存：\"><a href=\"#为什么需要动态分配内存：\" class=\"headerlink\" title=\"为什么需要动态分配内存：\"></a>为什么需要动态分配内存：</h6><p>动态数组很好的解决了传统数组的四个缺陷(传统数组也叫静态数组)</p>\n<p><strong>动态内存分配举例_动态数组的构造</strong></p>\n<pre><code>int i = 5;  //分配了4个字节 静态分配\nint* p = (int *)malloc(4);  //4表示分配4个字节，malloc函数返回第一个字节地址，是个地址，\n                            //所以要用(int *)强制类型转换把它定义为int* 类型的地址变量\n/* \n    1.要使用malloc函数，必须添加malloc.h这个头文件\n    2.malloc函数只有一个形参，并且形参是整型\n    3.4表示请求系统为本程序分配4个字节\n    4.malloc函数只能返回第一个字节的地址\n    5.12行分配了12个字节，p变量占8个字节，p指向的内存占4个字节\n    6.p本身所占的内存是静态分配的，p所指向的内存是动态分配的\n*/\n*p = 5;  //*p代表的就是一个int变量，只不过*p这个类型变量的内存分配方式和11行的i变量的分配方式不同\nfree(p);  //free(p)表示把p指向的内存释放掉,p本身的内存是静态的，不能由程序员手动释放，只能在p变量所在的函数运行终止时由系统自动释放\n</code></pre>\n<p><strong>静态内存和动态内存的比较</strong></p>\n<ul>\n<li>静态内存是由系统自动分配的，由系统自动释放</li>\n</ul>\n<p>(静态内存是在栈分配的)</p>\n<ul>\n<li>动态内存是程序员手动分配的，手动释放</li>\n</ul>\n<p>(动态内存是在堆分配的)</p>\n<p><strong>多级指针</strong></p>\n<pre><code>int i = 10;\nint* p = &amp;i;\nint** q = &amp;p;\nint*** r = &amp;q;\n// r = &amp;p;  //error 因为r是 int*** 类型，r只能存放 int** 类型变量的地址\n//*是指针运算符，***r就是连续用*算三次，最后得到结果i = ***r = 10\nprintf(&quot;i = %d\\n&quot;, ***r);\n在VScode的输出结果是：\n------------------\ni = 10\n------------------\n</code></pre>\n<p><strong>跨函数使用内存的问题(重要)</strong></p>\n<pre><code>eg：(静态)\nvoid f(int** q)\n&#123;\n    int i = 5;\n    //*q等价于p\n    // *q = i;  //error 因为*q = i;等价于p = i;int类型赋值给int*类型，这样写是错误的\n    *q = &amp;i;\n&#125;\n\nint main(void)\n&#123;\n    int* p;\n\n    f(&amp;p);\n    printf(&quot;%d\\n&quot;, *p);  //16行  本语句语法没有问题，但逻辑上有问题(因为f函数的i空间已经释放了)\n\n    return 0;\n&#125;\n\neg:(动态)\nvoid f(int** q)\n&#123;\n    *q = (int*)malloc(sizeof(int));  //并没有规定int类型就必须要占4个字节，不同机器是不一样的\n                                     //C语言只规定了短整型不能大于整型，整型不能大于长整型\n                                     //所以用sizeof()可增加程序的可移植性\n    // q = 5;  //error\n    // *q = 5;  //p = 5;\n    **q = 5;  //*p = 5;\n&#125;\nint main(void)\n&#123;\n    int* p;\n\n    f(&amp;p);\n    printf(&quot;%d\\n&quot;, *p);\n\n    return 0;\n&#125;\n</code></pre>\n<h5 id=\"3、结构体\"><a href=\"#3、结构体\" class=\"headerlink\" title=\"3、结构体\"></a>3、结构体</h5><p><em>为什么需要结构体？</em></p>\n<p>为了表示一些复杂的事物，而普通的基本数据类型无法满足实际需求</p>\n<p><em>什么叫结构体？</em></p>\n<p>把一些基本数据类型组合在一起形成一个复合的新的数据类型，这个叫做结构体</p>\n<h6 id=\"3-1-如何定义结构体？\"><a href=\"#3-1-如何定义结构体？\" class=\"headerlink\" title=\"3.1 如何定义结构体？\"></a>3.1 如何定义结构体？</h6><pre><code>3种方式，推荐使用第一种：\n//第一种方式\nstruct Student1  //相当于造出了一个新的数据类型\n&#123;\n    int age;\n    float score;\n    char sex;\n&#125;;\n\n//第二种方式\nstruct Student2\n&#123;\n    int age;\n    float score;\n    char sex;\n&#125; st2;\n\n//第三种方式\nstruct\n&#123;\n    int age;\n    float score;\n    char sex;\n&#125; st3;\n</code></pre>\n<p><em>怎样使用结构体变量？</em></p>\n<p><em>赋值和初始化</em></p>\n<p>定义的同时可以整体赋初值</p>\n<p>如果定义完之后，则只能单个的赋初值</p>\n<h6 id=\"3-2-如何取出结构体变量中的每一个成员\"><a href=\"#3-2-如何取出结构体变量中的每一个成员\" class=\"headerlink\" title=\"3.2 如何取出结构体变量中的每一个成员\"></a>3.2 如何取出结构体变量中的每一个成员</h6><p>1.结构体变量名.成员名</p>\n<p>2.指针变量名-&gt;成员名(第二种更加常用)</p>\n<pre><code>    struct student st = &#123;80, 66.6, &#39;F&#39;&#125;;  \n    //初始化，定义的同时赋初值\n    struct student* pst = &amp;st;\n\n    st.age = 10;  //第一种方式\n    pst-&gt;age = 88;  //第二种方式\n\npst-&gt;age在计算机内部会被转化成(*pst).age(这就是 -&gt; 的2含义，这是一种硬性规定)\npst-&gt;age的含义：\npst所指向的那个结构体变量中的age这个成员\n</code></pre>\n<h6 id=\"3-3-结构体变量的运算\"><a href=\"#3-3-结构体变量的运算\" class=\"headerlink\" title=\"3.3 结构体变量的运算\"></a>3.3 结构体变量的运算</h6><p>结构体变量不能相加，不能相减，也不能相互乘除，但结构体变量可以相互赋值</p>\n<pre><code>struct Student\n&#123;\n    int age;\n    char sex;\n    char name[100];\n&#125;;  //分号不能省\nstruct Student st1,st2;\nst1+st2 st1*st2 st1/st2 都是错误的\nst1 = st2 或者 st2 = st1 都是正确的\n</code></pre>\n<h6 id=\"3-4-结构体变量和结构体变量指针作为函数参数传递的问题\"><a href=\"#3-4-结构体变量和结构体变量指针作为函数参数传递的问题\" class=\"headerlink\" title=\"3.4 结构体变量和结构体变量指针作为函数参数传递的问题\"></a>3.4 结构体变量和结构体变量指针作为函数参数传递的问题</h6><pre><code>void OutputStudent(struct Student ss)\n&#123;\n    printf(&quot;%d %c %s\\n&quot;,ss.age, ss.sex, ss.name);\n&#125;\nvoid InputStudent(struct Student * pstu)\n&#123;\n    pstu-&gt;age = 10;\n    strcpy(pstu-&gt;name, &quot;张三&quot;);\n    pstu-&gt;sex = &#39;F&#39;;\n&#125;\nstruct Student st;\nInputStudent(&amp;st);  //对结构体变量输入,必须发送st的地址\nOutputStudent(st);  //对结构体变量输出,可以发送st的地址，也可以发送st的内容\n\n//推荐使用结构体指针变量作为函数参数来传递\n</code></pre>\n<h6 id=\"专题：枚举\"><a href=\"#专题：枚举\" class=\"headerlink\" title=\"专题：枚举\"></a>专题：枚举</h6><p>什么是枚举</p>\n<p>把一个事物所有可能的取值一一列举出来</p>\n<p>怎么使用枚举</p>\n<pre><code>//只定义了一个数据类型，并没有定义变量，该数据类型的名字是enum WeekDay\nenum WeekDay\n&#123;\n    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday\n&#125;;\n\nint main(void)\n&#123;\n    enum WeekDay day = Wednesday;\n    printf(&quot;%d\\n&quot;, day);  //输出结果是2,在计算机内部认为Wednesday是2\n\n    return 0;\n&#125;\n</code></pre>\n<p>枚举的优缺点</p>\n<p>代码更安全</p>\n<p>书写麻烦</p>\n<h6 id=\"专题：链表\"><a href=\"#专题：链表\" class=\"headerlink\" title=\"专题：链表\"></a>专题：链表</h6><pre><code>算法\n通俗定义：解题的方法和步骤\n狭义定义：对存储数据的操作\n对不同的数据结构，要完成某一个功能所执行的操作是不一样的\n比如：\n要输出数组中所有元素的操作 和\n要输出链表中所有元素的操作肯定是不一样的\n这说明：\n    算法是依附于存储结构的\n    不同的存储结构所执行的算法是不一样的\n广义定义：广义的算法也叫泛型\n无论数据是如何存储的，对给数据的操作都是一样的\n</code></pre>\n<p>我们至少可以通过两种结构来存储数据</p>\n<pre><code>*数组*\n优点：存取速度快\n缺点：\n1.需要一个连续的很大的内存\n2.插入和删除元素的效率很低\n\n专业术语：\n头节点:\n1.头节点的数据类型和首节点的数据类型是一模一样的\n2.头节点是首节点前面的那个节点\n3.头节点并不存放有效数据\n4.设置头节点的目的是为了方便对链表的操作\n头指针:\n存放头节点的地址的指针变量\n首节点:\n存放第一个有效数据的节点\n尾节点:\n存放最后一个有效数据的节点\n\n*链表*\n优点：\n1.插入删除元素效率高\n2.不需要一个连续的很大的内容\n缺点：查找某个位置的元素效率低\n</code></pre>\n<h6 id=\"专题：位运算符\"><a href=\"#专题：位运算符\" class=\"headerlink\" title=\"专题：位运算符\"></a>专题：位运算符</h6><p><code>&amp;</code>:按位与</p>\n<p><code>|</code>:按位或</p>\n<p><code>~</code>:按位取反</p>\n<p><code>^</code>:按位异或</p>\n<p><code>&lt;&lt;</code>:按位左移</p>\n<p><code>&gt;&gt;</code>:按位右移</p>\n<p><code>i&lt;&lt;1</code> 表示把i的所有二进制位左移一位</p>\n<p><strong>左移n为相当于乘以2的n次方</strong></p>\n<p><code>i&gt;&gt;3</code>表示把i的所有二进制位右移3位，左边一般是补0，当然也可能补1</p>\n<p><strong>右移相当于除以2的n次方，前提是数据不能够丢失</strong></p>\n<p><em>通过位运算符我们可以对数据的操作精确到每一位</em></p>\n<h6 id=\"专题：NULL\"><a href=\"#专题：NULL\" class=\"headerlink\" title=\"专题：NULL\"></a>专题：NULL</h6><p>二进制全部为零的含义 —00000000000000000000的含义</p>\n<p>1.数值零</p>\n<p>2.字符串结束标记符 ‘\\0’</p>\n<p>3.空指针NULL</p>\n<p>NULL表示的是零，而这个零不代表数字零，而表示的是内存单元的编号零</p>\n<p>计算机规定了，以零为编号的存储单元的内容不可读，不可写</p>\n","categories":["C语言","基础知识"],"tags":["C","常识"]},{"title":"每日一记","url":"/2023/01/15/%E6%97%A5%E8%AE%B0/","content":"<p>2023年1月15日 07:22:04 </p>\n<p>今天美滋滋</p>\n","categories":["日记"],"tags":["日记"]}]