[{"title":"C语言基本语法","url":"/2023/01/14/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","content":"<h4 id=\"C语言基本语法\"><a href=\"#C语言基本语法\" class=\"headerlink\" title=\"C语言基本语法\"></a>C语言基本语法</h4><hr>\n<h5 id=\"1、输入与输出\"><a href=\"#1、输入与输出\" class=\"headerlink\" title=\"1、输入与输出\"></a>1、输入与输出</h5><h6 id=\"1-1-printf函数\"><a href=\"#1-1-printf函数\" class=\"headerlink\" title=\"1.1 printf函数\"></a>1.1 printf函数</h6><ul>\n<li><p><code>printf(&quot;字符串&quot;)；</code></p>\n</li>\n<li><p><code>printf(&quot;输出控制符&quot;,输出参数)；</code><mark>（输出控制符：指定计算机中的二进制数以什么形式输出）</mark></p>\n</li>\n</ul>\n<p>eg：<code>printf(&quot;%#X&quot;,x);</code>输出结果是0X2F（假定<code>int x = 47;</code>）</p>\n<h6 id=\"1-2-scanf函数\"><a href=\"#1-2-scanf函数\" class=\"headerlink\" title=\"1.2 scanf函数\"></a>1.2 scanf函数</h6><ul>\n<li>scanf(“输入控制符”,输入参数);<mark>（<code>&amp;i</code>表示<code>i</code>的地址，<code>&amp;</code>为取地址符）</mark></li>\n</ul>\n<p>   <mark> (将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入输入参数的地址对应的存储空间中)</mark></p>\n<p>    <mark>eg:操作系统接收键盘数据的时候都当做字符来接收的</mark></p>\n<ul>\n<li>scanf(“非输入控制符 输入控制符”,输入参数);</li>\n</ul>\n<p>        注意：此用法下，非输入控制符必须原样输入。</p>\n<p>   <mark> 当输入多个数时，可以用非输入控制符隔开</mark></p>\n<h5 id=\"2、运算符\"><a href=\"#2、运算符\" class=\"headerlink\" title=\"2、运算符\"></a>2、运算符</h5><h6 id=\"2-1-算数运算符\"><a href=\"#2-1-算数运算符\" class=\"headerlink\" title=\"2.1 算数运算符\"></a>2.1 算数运算符</h6><pre><code>+     -     *     /(正斜杠)     %\n</code></pre>\n<h6 id=\"2-2-关系运算符\"><a href=\"#2-2-关系运算符\" class=\"headerlink\" title=\"2.2 关系运算符\"></a>2.2 关系运算符</h6><pre><code>&gt;     &gt;=     &lt;     &lt;=     !=     ==\n</code></pre>\n<h6 id=\"2-3-逻辑运算符\"><a href=\"#2-3-逻辑运算符\" class=\"headerlink\" title=\"2.3 逻辑运算符\"></a>2.3 逻辑运算符</h6><pre><code>！     &amp;&amp;     ||\n</code></pre>\n<p><mark><code>&amp;&amp;</code>左边的表达式为假的话，右边就不会执行</mark></p>\n<p>eg：<code>m = (1/2) &amp;&amp; (k=5);</code>中的k&#x3D;5就不会执行。</p>\n<p>（不含分号的是表达式，含有分号的是语句。<mark>语句是必定会执行的，如if···else···只表示一个语句</mark>）</p>\n<p><mark>同样的，<code>||</code>左边的表达式为真的话，右边就不会执行</mark></p>\n<h6 id=\"2-4-赋值运算符\"><a href=\"#2-4-赋值运算符\" class=\"headerlink\" title=\"2.4 赋值运算符\"></a>2.4 赋值运算符</h6><pre><code>=     +=     *=     /=     -=\n</code></pre>\n<h6 id=\"2-5-优先级\"><a href=\"#2-5-优先级\" class=\"headerlink\" title=\"2.5 优先级\"></a>2.5 优先级</h6><p>算数&gt;关系&gt;逻辑&gt;赋值</p>\n<h5 id=\"3、流程控制\"><a href=\"#3、流程控制\" class=\"headerlink\" title=\"3、流程控制\"></a>3、流程控制</h5><p>程序执行的顺序</p>\n<h6 id=\"3-1-if语句\"><a href=\"#3-1-if语句\" class=\"headerlink\" title=\"3.1 if语句\"></a>3.1 if语句</h6><p><mark><code>if(90 &lt; score &lt;=100)</code>永远为真</mark></p>\n<p>两个数替换</p>\n<pre><code>t = a;\na = b;\nb = t;\n\n if (表达式1)\n     A;\n else if (表达式2)\n     B;\n (最后的else可以不要，程序也不会出错，因为逻辑上没有问题)\n</code></pre>\n<h6 id=\"3-2-for语句\"><a href=\"#3-2-for语句\" class=\"headerlink\" title=\"3.2 for语句\"></a>3.2 for语句</h6><pre><code>//for语句的执行顺序\nfor (i=1; i&lt;=4: i++)\n&#123;\n    sum = sum + 1;\n&#125;\ni=1;------1\ni&lt;=4;-----2\ni++;------3\nsum = sum + 1;-----4\n</code></pre>\n<p><mark>先执行1，再执行2，如果成立，再执行4，再执行3(3完了标志一次循环结束)，再执行2···以此类推。</mark></p>\n<h6 id=\"专题：强制类型转化\"><a href=\"#专题：强制类型转化\" class=\"headerlink\" title=\"专题：强制类型转化\"></a>专题：强制类型转化</h6><p>功能：把表达式的值强制转化为前面所执行的数据类型</p>\n<p>eg:<code>(int)(4.5+2.2)</code> 最终值为6</p>\n<pre><code>在求1 + 1/2 + 1/3 + ··· + 1/100中\nsum = sum +1/(float)(i);//OK\nsum = sum +(float)(1/i);//这样写不对，因为(1/i)在i&gt;=2后永远为0\nsum = sum +1.0/i;//也没问题\n</code></pre>\n<p><mark>注意:高精度与低精度一起运算，结果一定是高精度的。</mark></p>\n<p><mark>注意：float与double由于编码机制的问题，都不能保证可以精确的存储一个小数。</mark></p>\n<h6 id=\"专题：三目运算符\"><a href=\"#专题：三目运算符\" class=\"headerlink\" title=\"专题：三目运算符\"></a>专题：三目运算符</h6><p>格式</p>\n<p><code>A ? B : C</code></p>\n<p>等价于</p>\n<pre><code>if (A)\n    B;\nelse\n    C;\n</code></pre>\n<h6 id=\"专题：逗号表达式专题\"><a href=\"#专题：逗号表达式专题\" class=\"headerlink\" title=\"专题：逗号表达式专题\"></a>专题：逗号表达式专题</h6><p>格式</p>\n<p><code>(A, B, C, D)</code></p>\n<p>功能</p>\n<p>从左到右执行</p>\n<p>最终表达式的值是最后一项的值</p>\n<pre><code>eg：\n    int i;\n    int j = 2;\n    i = (j++, ++j, j+2, j-3);\n    printf(&quot;i = %d&quot;,i);\n最终输出结果为：\ni = 1\n</code></pre>\n<h6 id=\"3-3-while语句\"><a href=\"#3-3-while语句\" class=\"headerlink\" title=\"3.3 while语句\"></a>3.3 while语句</h6><p>格式：</p>\n<pre><code>while (表达式)\n    语句；\n</code></pre>\n<h6 id=\"3-4-do…while语句\"><a href=\"#3-4-do…while语句\" class=\"headerlink\" title=\"3.4 do…while语句\"></a>3.4 do…while语句</h6><p>多用于人机交互</p>\n<pre><code>do\n&#123;\n    A;\n&#125; while(表达式);\n</code></pre>\n<h6 id=\"3-5-switch语句\"><a href=\"#3-5-switch语句\" class=\"headerlink\" title=\"3.5 switch语句\"></a>3.5 switch语句</h6><pre><code>switch（表达式）\n&#123;\n    case 标签1：\n        语句1；\n    case 标签2：\n        语句2；\n    default：\n        语句n；\n&#125;\n//根据switch()中表达式的值找到与之匹配的case子句，就从此case子句开始执行下去，不再进行判断\n</code></pre>\n<p>这些标签只能是</p>\n<p>（1）枚举常量 （2）数值常量 （3）字符常量 （4）常变量 （5）宏名的一种（不用记忆，抄着玩的）</p>\n<h6 id=\"3-6-break语句\"><a href=\"#3-6-break语句\" class=\"headerlink\" title=\"3.6 break语句\"></a>3.6 break语句</h6><p>break用于终止循环。</p>\n<p>在多层循环中，只能终止距离它最近的循环</p>\n<h5 id=\"3-7-continue语句\"><a href=\"#3-7-continue语句\" class=\"headerlink\" title=\"3.7 continue语句\"></a>3.7 continue语句</h5><p>用于跳过本次循环剩下的语句，转去判断是否需要执行下一次循环</p>\n<h5 id=\"4、数组\"><a href=\"#4、数组\" class=\"headerlink\" title=\"4、数组\"></a>4、数组</h5><h6 id=\"4-1-数组的使用\"><a href=\"#4-1-数组的使用\" class=\"headerlink\" title=\"4.1 数组的使用\"></a>4.1 数组的使用</h6><p>为什么需要数组？</p>\n<p>用于解决大量同类型数据的存储和使用问题</p>\n<pre><code>eg:\nint a[5] = &#123;1, 2, 3, 4, 5&#125;;\na是数组的名字(代表数组中第一个元素的地址)，5表示数组元素的个数，并且这五个元素分别是a[0],a[1],a[2],a[3],a[4]\n</code></pre>\n<h6 id=\"4-2-一维数组\"><a href=\"#4-2-一维数组\" class=\"headerlink\" title=\"4.2 一维数组\"></a>4.2 一维数组</h6><ul>\n<li><p>为n个变量连续分配内存空间</p>\n</li>\n<li><p>所有变量的数据类型必须相同</p>\n</li>\n<li><p>所有变量所占的字节大小必须相等</p>\n</li>\n</ul>\n<p>完全初始化</p>\n<p>    <code>int a[5] = &#123;1, 2, 3, 4, 5&#125;;</code></p>\n<p>不完全初始化(为未初始化的元素自动为零)</p>\n<p>    <code>int a[5] = &#123;1, 2, 3&#125;;</code></p>\n<p>不初始化,所有元素是垃圾值</p>\n<p>    <code>int a[5];</code></p>\n<p>清零</p>\n<p>    <code>int a[5] = &#123;0&#125;;</code></p>\n<h6 id=\"4-3-二维数组\"><a href=\"#4-3-二维数组\" class=\"headerlink\" title=\"4.3 二维数组\"></a>4.3 二维数组</h6><pre><code>eg：\nint a[3][4];\n共12个元素，可以当做3行4列看待,即\na [0][0] a [0][1] a [0][2] a [0][3]\na [1][0] a [1][1] a [1][2] a [1][3]\na [2][0] a [2][1] a [2][2] a [2][3]\n</code></pre>\n<p><code>a[i][j]</code>表示第<code>i+1</code>行第<code>j+1</code>列的元素</p>\n<p><strong>初始化</strong></p>\n<pre><code>int a[3][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;\n\nint a[3][4] = &#123;\n    &#123;1, 2, 3, 4&#125;,\n    &#123;5, 6, 7, 8&#125;,\n    &#123;9, 10 ,11, 12&#125;,\n&#125;;\n</code></pre>\n<p>输出二维数组内容</p>\n<pre><code>for (i=0; i&lt;3; ++i)\n&#123;\n    for (j=0; j&lt;4; ++j)\n    &#123;\n        printf(&quot;%-5d&quot;,a[i][j]);\n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;\n</code></pre>\n<h6 id=\"4-4-多维数组\"><a href=\"#4-4-多维数组\" class=\"headerlink\" title=\"4.4 多维数组\"></a>4.4 多维数组</h6><p>是否存在多维数组？</p>\n<p>不存在，应为内存是线性一维的。</p>\n<p><mark>n维数组可以当做每个元素是n-1维数组的一维数组</mark></p>\n<p>eg:</p>\n<p><code>int a[3][4][5]</code></p>\n<p>该数组是含有3个元素的一维数组，其中，每个元素都是4行5列的二维数组</p>\n","categories":["C语言","基础知识"],"tags":["C","常识"]},{"title":"C语言基础知识","url":"/2023/01/14/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"<h4 id=\"C语言编程预备知识\"><a href=\"#C语言编程预备知识\" class=\"headerlink\" title=\"C语言编程预备知识\"></a>C语言编程预备知识</h4><hr>\n<h5 id=\"1、基本数据类型\"><a href=\"#1、基本数据类型\" class=\"headerlink\" title=\"1、基本数据类型\"></a>1、基本数据类型</h5><table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th>表示</th>\n<th align=\"center\"><mark>存放字节数</mark></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">整型</td>\n<td>int</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">短整型</td>\n<td>short int</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">长整型</td>\n<td>long int</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">单精度浮点数</td>\n<td>float</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">双精度浮点数</td>\n<td>double</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">字符</td>\n<td>char</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p><mark>注意：一个字节8位，即2^8 &#x3D; 256</mark></p>\n<p>不难得到，两个字节16位，即2^16 &#x3D; 65536</p>\n<p>4个字节32位，有21亿多</p>\n<h5 id=\"2、复合数据类型\"><a href=\"#2、复合数据类型\" class=\"headerlink\" title=\"2、复合数据类型\"></a>2、复合数据类型</h5><ul>\n<li><p>结构体（JAVA里已经没有了）</p>\n</li>\n<li><p><mark>枚举</mark></p>\n</li>\n<li><p>共用体（淘汰）</p>\n</li>\n</ul>\n<h5 id=\"3、变量的本质是内存中的一段存储空间\"><a href=\"#3、变量的本质是内存中的一段存储空间\" class=\"headerlink\" title=\"3、变量的本质是内存中的一段存储空间\"></a>3、变量的本质是内存中的一段存储空间</h5><p><mark><em>定义一个变量，如<code>int i；</code>，就是将内存中的一段空间与<code>i</code>对应。</mark></em></p>\n<p>变量定义：<code>int i=1;</code></p>\n<h5 id=\"4、进制转换\"><a href=\"#4、进制转换\" class=\"headerlink\" title=\"4、进制转换\"></a>4、进制转换</h5><p>C语言规定八进制前面要加0，十六进制前面要加0x或0X<mark>(指数据)</mark>，十进制最为常用则什么都不用加（但在汇编中用D来表示）。</p>\n<p>注意，汇编语言23O（即八进制23）的值&#x3D;2*8+3&#x3D;19（十进制）</p>\n<p><mark>注意：0X36F95FC0表示4个字节</mark></p>\n<p>（一个16进制数如F不是2个字节，F是4位也就是2^4&#x3D;8,所以2个16进制的位数即FF才能表示一个字节，上面共八位16进制数，即4个字节）</p>\n<p>eg：printf的用法</p>\n<ul>\n<li><p>%d表示以十进制输出</p>\n</li>\n<li><p>%x表示以十六进制输出<mark>（指输出控制符）</mark></p>\n</li>\n<li><p>%o表示以八进制输出</p>\n</li>\n</ul>\n<h5 id=\"5、常数的写法\"><a href=\"#5、常数的写法\" class=\"headerlink\" title=\"5、常数的写法\"></a>5、常数的写法</h5><ul>\n<li><p>十进制：传统写法</p>\n</li>\n<li><p>十六进制：前面加0x或0X</p>\n</li>\n<li><p>八进制：前面加0，注意是数字0</p>\n</li>\n<li><p>浮点数_传统写法：<code>float x=3.2</code></p>\n</li>\n<li><p><mark>浮点数_科学计数法</mark>：</p>\n<p><code>float x =3.2e3      //x的值为3200</code></p>\n</li>\n</ul>\n<p>       <code>float x =123.4e-2     //x的值为1.234</code></p>\n<ul>\n<li><p>字符：</p>\n<p>单个字符用单引号括起来：<code>‘AB’</code>错误</p>\n<p>字符串用双引号括起来：<code>“A”</code>正确，因为它表示<code>‘A’</code>与<code>‘\\0’</code>的组合<mark>（<code>‘\\0’</code>作为字符串的结束符）</mark></p>\n</li>\n</ul>\n<h5 id=\"6、常量在计算机中的存储\"><a href=\"#6、常量在计算机中的存储\" class=\"headerlink\" title=\"6、常量在计算机中的存储\"></a>6、常量在计算机中的存储</h5><ul>\n<li><p><mark>整数以补码的形式转换为二进制数 存储在计算机中</mark></p>\n</li>\n<li><p>实数以IEEE754标准转换为二进制代码存住在计算机中</p>\n</li>\n<li><p>字符的本质与整数的存储方式相同（ASCII）</p>\n</li>\n</ul>\n<h5 id=\"7、代码规范化\"><a href=\"#7、代码规范化\" class=\"headerlink\" title=\"7、代码规范化\"></a>7、代码规范化</h5><p> 《高质量C&#x2F;C++编程指南》</p>\n<h5 id=\"8、补码\"><a href=\"#8、补码\" class=\"headerlink\" title=\"8、补码\"></a>8、补码</h5><h6 id=\"补码的优点\"><a href=\"#补码的优点\" class=\"headerlink\" title=\"补码的优点\"></a>补码的优点</h6><ol>\n<li>可以让正数与负数之间进行正确的加法运算</li>\n<li>可以让减法全部变成正数与负数的加法（硬件电路就只需要设计加法器，而不用设计减法器了）</li>\n</ol>\n<p>        <mark>想一想：为什么补码能使0的编码只有一个？</mark></p>\n<h6 id=\"补码的产生\"><a href=\"#补码的产生\" class=\"headerlink\" title=\"补码的产生\"></a>补码的产生</h6><ol>\n<li><p><u>若是直接将数转化为二进制数，则无法表示正负，于是就有了原码。</u></p>\n</li>\n<li><p><u>但是原码在进行正数与负数的加法运算时，计算会出错（如下图，<code>2+（-2）=-4</code>）。</u></p>\n</li>\n</ol>\n<p><img src=\"https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202302192102882.png\" alt=\"image-20230219210226811\"></p>\n<h6 id=\"补码与原码的相互转化\"><a href=\"#补码与原码的相互转化\" class=\"headerlink\" title=\"补码与原码的相互转化\"></a>补码与原码的相互转化</h6><ul>\n<li><p>对于正数：补码与原码相等</p>\n</li>\n<li><p>对于负数：补码是在原码的基础上</p>\n</li>\n</ul>\n<p>            取绝对值，转为二进制</p>\n<p>            按位取反</p>\n<p>            +1</p>\n<h6 id=\"计算机中补码的计算（可能造成疑问的点下图的箭头指名了）\"><a href=\"#计算机中补码的计算（可能造成疑问的点下图的箭头指名了）\" class=\"headerlink\" title=\"计算机中补码的计算（可能造成疑问的点下图的箭头指名了）\"></a>计算机中补码的计算（可能造成疑问的点下图的箭头指名了）</h6><p><img src=\"https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202302192102229.png\" alt=\"image-20230219210252167\"></p>\n<p><mark>eg:对于32位的数来说，有符号数的表示范围为[-2^31, 2^31-1]</mark></p>\n<p><mark>eg:最高位为1，其余位为0，就是最小负数。如：10000000为-128</mark></p>\n<h5 id=\"9、ASCII码\"><a href=\"#9、ASCII码\" class=\"headerlink\" title=\"9、ASCII码\"></a>9、ASCII码</h5><p>eg：<code>printf（“%d”，ch）；（ch是字符型变量）</code>输出结果得67</p>\n<p><mark>原因：ch变量在内存中也是二进制数，上述代码只是将二进制数转化成十进制数输出而已</mark></p>\n<p><mark>0的ASCII码值为48，A为65，a为97。</mark></p>\n<p>&#96;</p>\n","categories":["C语言","基础知识"],"tags":["C","常识"]},{"title":"函数与指针","url":"/2023/01/14/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8C%87%E9%92%88/","content":"<h4 id=\"函数与指针\"><a href=\"#函数与指针\" class=\"headerlink\" title=\"函数与指针\"></a>函数与指针</h4><hr>\n<h5 id=\"1、函数\"><a href=\"#1、函数\" class=\"headerlink\" title=\"1、函数\"></a>1、函数</h5><h6 id=\"1-1-为什么需要函数\"><a href=\"#1-1-为什么需要函数\" class=\"headerlink\" title=\"1.1 为什么需要函数\"></a>1.1 为什么需要函数</h6><ul>\n<li><p>避免了重复性操作</p>\n</li>\n<li><p>有利于程序的模块化（一个main函数的功能通过调用的几个函数实现，这几个函数又通过调用一些函数实现）</p>\n</li>\n</ul>\n<h6 id=\"1-2-什么叫函数\"><a href=\"#1-2-什么叫函数\" class=\"headerlink\" title=\"1.2 什么叫函数\"></a>1.2 什么叫函数</h6><p>逻辑上：能够完成特定功能的独立的代码块</p>\n<p>物理上：</p>\n<p>能够接收数据（也可以不接收）</p>\n<p>能够对接收的数据进行处理（也可以不处理）</p>\n<p>能够将数据处理的结果返回（也可以不返回）</p>\n<p>总结：函数是个用于解决大量类似问题的工具。</p>\n<h6 id=\"1-3-如何定义函数\"><a href=\"#1-3-如何定义函数\" class=\"headerlink\" title=\"1.3 如何定义函数\"></a>1.3 如何定义函数</h6><p>格式：</p>\n<pre><code>函数的返回值 函数的名字（函数的形参列表）\n&#123;\n    函数的执行体\n&#125;\n函数定义的本质是详细描述函数实现某个特定功能的具体方法\n</code></pre>\n<p><mark>已知的语言全是用压栈的方式进行函数调用</mark></p>\n<pre><code>//main调用f，就要为f分配空间，怎么分配空间？就是在一个栈里面为它分配。那f调用期间用调用g，是不是要把g的空间也压栈呀！所以g里面的形参包括里面的局部变量统统都是以栈的方式来分配的。所以为什么它不能跨函数使用？为什么g函数终止之后，g里面的空间不能被f使用？因为你这函数一终止，这个东西就出栈了（就是把栈中为g分配的空间抛出去）。\n</code></pre>\n<h6 id=\"专题：return表达式\"><a href=\"#专题：return表达式\" class=\"headerlink\" title=\"专题：return表达式\"></a>专题：return表达式</h6><p><mark>函数返回值的类型也称为函数的类型</mark>（当函数返回值的数据类型与函数名前面数据类型冲突时，以函数名前面的数据类型为准）</p>\n<pre><code>eg：\nint f()\n&#123;\n    return 10.5;\n&#125;\n最后的返回值为10\n</code></pre>\n<p>return表达式的作用</p>\n<p><mark>终止被调函数，向主调函数返回表达式的值</mark></p>\n<p>注意:主函数是程序的入口，也是程序的出口（一个程序只能有一个主函数）</p>\n<p><mark>函数内部定义的变量只在本函数中使用</mark></p>\n<h6 id=\"1-4-函数的声明\"><a href=\"#1-4-函数的声明\" class=\"headerlink\" title=\"1.4 函数的声明\"></a>1.4 函数的声明</h6><pre><code>eg：\nvoid f(void);\n</code></pre>\n<p><mark>作用：告诉编译器<code>f</code>是个函数名</mark></p>\n<p>为什么要函数的声明？</p>\n<p><mark>避免调用函数的语句放在了定义函数的语句的前面</mark></p>\n<p><mark>对库函数的声明已通过<code> # include &lt;库函数所在文件的名字.h&gt;</code>声明了</mark></p>\n<h6 id=\"专题：递归\"><a href=\"#专题：递归\" class=\"headerlink\" title=\"专题：递归\"></a>专题：递归</h6><ol>\n<li><p>函数自己调用自己</p>\n</li>\n<li><p>只递不归会导致程序崩溃</p>\n</li>\n<li><p>要在适当的时候终止递归</p>\n</li>\n</ol>\n<h6 id=\"专题：变量的作用域和存储方式\"><a href=\"#专题：变量的作用域和存储方式\" class=\"headerlink\" title=\"专题：变量的作用域和存储方式\"></a>专题：变量的作用域和存储方式</h6><p><strong>按作用域分：</strong></p>\n<p>全局变量</p>\n<p><mark>在所有函数外部定义的变量，就叫全局变量</mark></p>\n<p>全局变量使用范围：</p>\n<p><mark>从定义位置开始到整个程序结束</mark></p>\n<p>局部变量</p>\n<p><mark>在一个函数内部定义的或者说函数的形参，都统称为局部变量</mark></p>\n<p>局部变量使用范围：</p>\n<p><mark>只能在本函数内部使用</mark></p>\n<pre><code>eg：\nvoid f(int i)\n&#123;\n    int j = 100;\n&#125;\ni（形参）和j（内部定义的变量）都属于局部变量\n注意：一旦函数运行完毕，为这个函数分配的所有静态空间都会释放，（避免重复调用函数造成内存占用）\n</code></pre>\n<p>当全局变量与局部变量命名冲突时：</p>\n<p><u>在一个函数内部，如果定义的局部变量的名字与全局变量的名字一样时，局部变量会屏蔽到全局变量（C语言设计时这样规定的）</u></p>\n<p><strong>按变量的存储方式分：</strong></p>\n<p>静态变量</p>\n<p>自动变量</p>\n<p>寄存器变量</p>\n<h5 id=\"2、指针\"><a href=\"#2、指针\" class=\"headerlink\" title=\"2、指针\"></a>2、指针</h5><h6 id=\"2-1-理解指针-重要\"><a href=\"#2-1-理解指针-重要\" class=\"headerlink\" title=\"2.1 理解指针(重要)\"></a>2.1 理解指针(重要)</h6><pre><code>int * p;\nint i = 3;\np = i;   //错误，因为类型不一致，p只能存放int类型变量的地址，不能存放int类型的变量\np = 55；  //错误，原因同上\np = &amp;i;   //正确\n</code></pre>\n<p>注意：<mark>指针就是地址，地址就是指针。<code>i</code>的指针也可以叫<code>i</code>的地址</mark>（所以指针是一个值，指针变量是一个变量，但是请注意，那些牛马在叙述时会把指针变量简称为指针，实际上，它们的含义并不一样）</p>\n<p>地址就是内存单元的编号</p>\n<p>指针变量是存放地址的变量</p>\n<p>指针的本质就是一个操作受限的非负整数（指针只能进行减法运算）</p>\n<pre><code>int main(void)\n&#123;\n    int* p;  //p是变量的名字，int* 表示p变量存放的是int类型变量的地址（相当于p是变量的名字，p变量的数据类型是 int* 类型， ）\n             //所谓 int* 类型：就是存放 int型变量的 地址的类型\n    int i = 3；\n    int j；    ·\n\n    p = &amp;i;\n    /* \n        p保存了i的地址，因此p指向i（因为p里面有i的地址，通过p可以找到i，我们有一个专有词叫‘指向’）\n        p不是i，i也不是p，更准确的说，修改p的值不影响i的值，修改i的值也不会影响p\n        p是一个特殊的变量（可以存放整数类型的变量的地址），但它仍然是个变量\n        如果一个指针变量指向了某个普通变量，则 *指针变量 就完全等同于普通变量\n\n        例子：\n            如果p是个指针变量，并且p存放了普通变量i的地址\n            则p指向了普通变量i\n            *p 就完全等同于 i   （*表示取地址的逆运算）\n            或者说： 在所有出现*p的地方都可以替换成i\n                    在所有出现i的地方都可以替换成*p\n            *p 就是以p的内容为地址的变量\n     */\n    j = *p;\n    printf(&quot;i = %d, j = %d, *p = %d\\n&quot;, i, j, *p);\n\n    return 0;\n&#125;\n输出值为：\ni = 3, j = 3, *p = 3\n</code></pre>\n<h6 id=\"2-2-指针的重要性\"><a href=\"#2-2-指针的重要性\" class=\"headerlink\" title=\"2.2 指针的重要性\"></a>2.2 指针的重要性</h6><ul>\n<li><p>能够表示一些复杂的数据结构</p>\n</li>\n<li><p>能够快速的传递数据，减少了内存的耗用</p>\n</li>\n<li><p>能够使函数返回一个以上的值(不然只能用return返回一个值)</p>\n</li>\n<li><p>能够直接访问硬件</p>\n</li>\n<li><p>能够方便的处理字符串</p>\n</li>\n<li><p>是理解面向对象语言中引用的基础</p>\n</li>\n</ul>\n<p>总结：指针是C语言的灵魂</p>\n<h6 id=\"专题：-的含义\"><a href=\"#专题：-的含义\" class=\"headerlink\" title=\"专题：*的含义\"></a>专题：*的含义</h6><ul>\n<li><p>乘法</p>\n</li>\n<li><p>定义指针变量</p>\n<p>  int* p;<br>  定义了一个名字叫p的变量，int*表示p只能存放int类型变量的地址</p>\n</li>\n<li><p>指针运算符</p>\n<p> 如果p是一个已经定义好的指针变量，则<mark>*p表示以p的内容为地址的变量</mark></p>\n<p>  如何通过被调函数修改主调函数普通变量的值：<br>  1.实参必须为该普通变量的地址<br>  2.形参必须为指针变量<br>  3.在被调函数中通过<br>      *形参名<br>  的方式就可以修改主调函数相关变量的值</p>\n</li>\n</ul>\n<h6 id=\"2-3-指针和数组\"><a href=\"#2-3-指针和数组\" class=\"headerlink\" title=\"2.3 指针和数组\"></a>2.3 指针和数组</h6><p><mark>一维数组名是个指针常量，它存放的是一维数组第一个元素的地址</mark></p>\n<p>（因为是指针<mark>常量</mark>，所以数组名的值不可更改）</p>\n<p>如果p是个指针变量，则</p>\n<p><mark><code>p[i]</code>永远等价于<code>*(p+i)</code></mark></p>\n<pre><code>eg:\nprintf(&quot;%d\\n&quot;,*c);  //输出第一个元素的值\nprintf(&quot;%d\\n&quot;, *(c+3));  //输出第4个元素的值\n//c+3完成了向后移动三个地址单元\n</code></pre>\n<p>补充：数组元素<code>a[i]</code>就是当作<code>*(a+i)</code>去处理的，先通过数组名<code>a</code>找到数组的首地址，然后首地址<code>a+i</code>得到<code>a[i]</code>的地址</p>\n<p>函数要处理一个一元数组，需要两个参数，即</p>\n<p>数组的第一个元素的地址和数组的长度</p>\n<h6 id=\"2-4-指针变量的运算\"><a href=\"#2-4-指针变量的运算\" class=\"headerlink\" title=\"2.4 指针变量的运算\"></a>2.4 指针变量的运算</h6><p>指针变量不能相加，不能相乘，不能相除</p>\n<p>如果两个指针变量指向的是同一块连续空间中的不同存储单元，则这两个指针变量才可以相减</p>\n<h6 id=\"专题：一个指针变量到底占几个字节\"><a href=\"#专题：一个指针变量到底占几个字节\" class=\"headerlink\" title=\"专题：一个指针变量到底占几个字节\"></a>专题：一个指针变量到底占几个字节</h6><pre><code>预备知识：\nsizeof(数据类型)\n功能：返回值就是该数据类型所占的字节数\neg:\nsizeof(int) = 4\nsizeof(char) = 1\nsizeof(double) = 8\n\nsizeof(变量)\n功能：返回值就是该变量所占的字节数\n</code></pre>\n<p>假设p指向char类型变量（1个字节）</p>\n<p>假设q指向int类型变量（4个字节）</p>\n<p>假设r指向double类型变量（8个字节）</p>\n<p><code>p q r </code>本身所占字节数是否一样?</p>\n<pre><code>char ch = &#39;A&#39;;\nint i = 99;\ndouble x = 66.6;\nchar* p = &amp;ch;\nint* q = &amp;i;\ndouble* r = &amp;x;\nprintf(&quot;%d %d %d\\n&quot;, sizeof(p), sizeof(q), sizeof(r));\n//在VScode的输出结果为：\n---------------------\n8 8 8\n---------------------\n即 p q r 本身所占字节数是一样的。\n根据郝斌P139的讲解，得出结论：\n在p,q,r中，它只保存ch,i,x的第一个字节的地址。\n\n问：但既然*q=i，q只知道i第一个字节地址的话，但是i如果占好几个字节呢,它如何知道i占几个字节呢？\n答：这在int* q = &amp;i;中给出了，就是定义了是int*类型的指针变量\n\n问：那既然p,q,r只保存了ch,i,x的第一个字节地址，为什么它们又都占8个字节(64GB)呢？\n答：虽然只保存了第一个字节地址，但这个地址是编号啊，这个编号本身就要8个字节来保存（就像造了一亿个房子，这个房子的容量虽然只有这么大，但是房子很多，它的编号就会很大）可能这个VScode认为的那个计算机是64根地址总线，刚好控制2^64个内存单元，即64GB\n</code></pre>\n<p><mark>注意：一个变量的地址使用该变量首个内存单元的地址来表示</mark>（因为一个内存单元就是一个字节，一个变量的地址使用该变量首字节的地址来表示）</p>\n<h6 id=\"专题：动态内存分配-重要\"><a href=\"#专题：动态内存分配-重要\" class=\"headerlink\" title=\"专题：动态内存分配(重要)\"></a>专题：动态内存分配(重要)</h6><p><strong>传统数组的缺点：</strong></p>\n<p>1.数组长度必须事先指定，且只能是常整数，不能是变量</p>\n<pre><code>eg:\nint a[5];  //OK\nint len = 5;int a[len]; //error\n</code></pre>\n<p>2.传统形式定义的数组，该数组的内存程序员无法手动释放</p>\n<p>(在一个函数运行期间，系统为该函数中数组所分配的空间会一直存在，直到该函数运行完毕时，数组的空间才会释放)</p>\n<p>3.数组的长度一旦定义，其长度就不能再更改</p>\n<p>(数组的长度不能在函数的运行的过程中动态的扩充或缩小)</p>\n<p>4.A函数定义的数组，在A函数运行期间可以被其它函数使用；但A函数运行完毕之后，A函数中的数组将无法再被其它函数使用（为什么能使用？因为用到数组的函数的形参都是地址啊）</p>\n<pre><code>void g(int* pArr, int len)\n&#123;\n    pArr[2] = 88;\n&#125;\n\nvoid f(void)\n&#123;\n    int a[5] = &#123;1,2,3,4,5&#125;;  //20个字节的存储空间程序员无法手动编程释放，它只能在本函数运行完毕时由系统自动释放\n    g(a, 5);\n    printf(&quot;%d\\n&quot;, a[2]);\n&#125;\n\nint main(void)\n&#123;\n    f();\n    return 0;\n&#125;\n</code></pre>\n<h6 id=\"为什么需要动态分配内存：\"><a href=\"#为什么需要动态分配内存：\" class=\"headerlink\" title=\"为什么需要动态分配内存：\"></a>为什么需要动态分配内存：</h6><p>动态数组很好的解决了传统数组的四个缺陷(传统数组也叫静态数组)</p>\n<p><strong>动态内存分配举例_动态数组的构造</strong></p>\n<pre><code>int i = 5;  //分配了4个字节 静态分配\nint* p = (int *)malloc(4);  //4表示分配4个字节，malloc函数返回第一个字节地址，是个地址，\n                            //所以要用(int *)强制类型转换把它定义为int* 类型的地址变量\n/* \n    1.要使用malloc函数，必须添加malloc.h这个头文件\n    2.malloc函数只有一个形参，并且形参是整型\n    3.4表示请求系统为本程序分配4个字节\n    4.malloc函数只能返回第一个字节的地址\n    5.12行分配了12个字节，p变量占8个字节，p指向的内存占4个字节\n    6.p本身所占的内存是静态分配的，p所指向的内存是动态分配的\n*/\n*p = 5;  //*p代表的就是一个int变量，只不过*p这个类型变量的内存分配方式和11行的i变量的分配方式不同\nfree(p);  //free(p)表示把p指向的内存释放掉,p本身的内存是静态的，不能由程序员手动释放，只能在p变量所在的函数运行终止时由系统自动释放\n</code></pre>\n<p><strong>静态内存和动态内存的比较</strong></p>\n<ul>\n<li>静态内存是由系统自动分配的，由系统自动释放</li>\n</ul>\n<p>(静态内存是在栈分配的)</p>\n<ul>\n<li>动态内存是程序员手动分配的，手动释放</li>\n</ul>\n<p>(动态内存是在堆分配的)</p>\n<p><strong>多级指针</strong></p>\n<pre><code>int i = 10;\nint* p = &amp;i;\nint** q = &amp;p;\nint*** r = &amp;q;\n// r = &amp;p;  //error 因为r是 int*** 类型，r只能存放 int** 类型变量的地址\n//*是指针运算符，***r就是连续用*算三次，最后得到结果i = ***r = 10\nprintf(&quot;i = %d\\n&quot;, ***r);\n在VScode的输出结果是：\n------------------\ni = 10\n------------------\n</code></pre>\n<p><strong>跨函数使用内存的问题(重要)</strong></p>\n<pre><code>eg：(静态)\nvoid f(int** q)\n&#123;\n    int i = 5;\n    //*q等价于p\n    // *q = i;  //error 因为*q = i;等价于p = i;int类型赋值给int*类型，这样写是错误的\n    *q = &amp;i;\n&#125;\n\nint main(void)\n&#123;\n    int* p;\n\n    f(&amp;p);\n    printf(&quot;%d\\n&quot;, *p);  //16行  本语句语法没有问题，但逻辑上有问题(因为f函数的i空间已经释放了)\n\n    return 0;\n&#125;\n\neg:(动态)\nvoid f(int** q)\n&#123;\n    *q = (int*)malloc(sizeof(int));  //并没有规定int类型就必须要占4个字节，不同机器是不一样的\n                                     //C语言只规定了短整型不能大于整型，整型不能大于长整型\n                                     //所以用sizeof()可增加程序的可移植性\n    // q = 5;  //error\n    // *q = 5;  //p = 5;\n    **q = 5;  //*p = 5;\n&#125;\nint main(void)\n&#123;\n    int* p;\n\n    f(&amp;p);\n    printf(&quot;%d\\n&quot;, *p);\n\n    return 0;\n&#125;\n</code></pre>\n<h5 id=\"3、结构体\"><a href=\"#3、结构体\" class=\"headerlink\" title=\"3、结构体\"></a>3、结构体</h5><p><em>为什么需要结构体？</em></p>\n<p>为了表示一些复杂的事物，而普通的基本数据类型无法满足实际需求</p>\n<p><em>什么叫结构体？</em></p>\n<p>把一些基本数据类型组合在一起形成一个复合的新的数据类型，这个叫做结构体</p>\n<h6 id=\"3-1-如何定义结构体？\"><a href=\"#3-1-如何定义结构体？\" class=\"headerlink\" title=\"3.1 如何定义结构体？\"></a>3.1 如何定义结构体？</h6><pre><code>3种方式，推荐使用第一种：\n//第一种方式\nstruct Student1  //相当于造出了一个新的数据类型\n&#123;\n    int age;\n    float score;\n    char sex;\n&#125;;\n\n//第二种方式\nstruct Student2\n&#123;\n    int age;\n    float score;\n    char sex;\n&#125; st2;\n\n//第三种方式\nstruct\n&#123;\n    int age;\n    float score;\n    char sex;\n&#125; st3;\n</code></pre>\n<p><em>怎样使用结构体变量？</em></p>\n<p><em>赋值和初始化</em></p>\n<p>定义的同时可以整体赋初值</p>\n<p>如果定义完之后，则只能单个的赋初值</p>\n<h6 id=\"3-2-如何取出结构体变量中的每一个成员\"><a href=\"#3-2-如何取出结构体变量中的每一个成员\" class=\"headerlink\" title=\"3.2 如何取出结构体变量中的每一个成员\"></a>3.2 如何取出结构体变量中的每一个成员</h6><p>1.结构体变量名.成员名</p>\n<p>2.指针变量名-&gt;成员名(第二种更加常用)</p>\n<pre><code>    struct student st = &#123;80, 66.6, &#39;F&#39;&#125;;  \n    //初始化，定义的同时赋初值\n    struct student* pst = &amp;st;\n\n    st.age = 10;  //第一种方式\n    pst-&gt;age = 88;  //第二种方式\n\npst-&gt;age在计算机内部会被转化成(*pst).age(这就是 -&gt; 的2含义，这是一种硬性规定)\npst-&gt;age的含义：\npst所指向的那个结构体变量中的age这个成员\n</code></pre>\n<h6 id=\"3-3-结构体变量的运算\"><a href=\"#3-3-结构体变量的运算\" class=\"headerlink\" title=\"3.3 结构体变量的运算\"></a>3.3 结构体变量的运算</h6><p>结构体变量不能相加，不能相减，也不能相互乘除，但结构体变量可以相互赋值</p>\n<pre><code>struct Student\n&#123;\n    int age;\n    char sex;\n    char name[100];\n&#125;;  //分号不能省\nstruct Student st1,st2;\nst1+st2 st1*st2 st1/st2 都是错误的\nst1 = st2 或者 st2 = st1 都是正确的\n</code></pre>\n<h6 id=\"3-4-结构体变量和结构体变量指针作为函数参数传递的问题\"><a href=\"#3-4-结构体变量和结构体变量指针作为函数参数传递的问题\" class=\"headerlink\" title=\"3.4 结构体变量和结构体变量指针作为函数参数传递的问题\"></a>3.4 结构体变量和结构体变量指针作为函数参数传递的问题</h6><pre><code>void OutputStudent(struct Student ss)\n&#123;\n    printf(&quot;%d %c %s\\n&quot;,ss.age, ss.sex, ss.name);\n&#125;\nvoid InputStudent(struct Student * pstu)\n&#123;\n    pstu-&gt;age = 10;\n    strcpy(pstu-&gt;name, &quot;张三&quot;);\n    pstu-&gt;sex = &#39;F&#39;;\n&#125;\nstruct Student st;\nInputStudent(&amp;st);  //对结构体变量输入,必须发送st的地址\nOutputStudent(st);  //对结构体变量输出,可以发送st的地址，也可以发送st的内容\n\n//推荐使用结构体指针变量作为函数参数来传递\n</code></pre>\n<h6 id=\"专题：枚举\"><a href=\"#专题：枚举\" class=\"headerlink\" title=\"专题：枚举\"></a>专题：枚举</h6><p>什么是枚举</p>\n<p>把一个事物所有可能的取值一一列举出来</p>\n<p>怎么使用枚举</p>\n<pre><code>//只定义了一个数据类型，并没有定义变量，该数据类型的名字是enum WeekDay\nenum WeekDay\n&#123;\n    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday\n&#125;;\n\nint main(void)\n&#123;\n    enum WeekDay day = Wednesday;\n    printf(&quot;%d\\n&quot;, day);  //输出结果是2,在计算机内部认为Wednesday是2\n\n    return 0;\n&#125;\n</code></pre>\n<p>枚举的优缺点</p>\n<p>代码更安全</p>\n<p>书写麻烦</p>\n<h6 id=\"专题：链表\"><a href=\"#专题：链表\" class=\"headerlink\" title=\"专题：链表\"></a>专题：链表</h6><pre><code>算法\n通俗定义：解题的方法和步骤\n狭义定义：对存储数据的操作\n对不同的数据结构，要完成某一个功能所执行的操作是不一样的\n比如：\n要输出数组中所有元素的操作 和\n要输出链表中所有元素的操作肯定是不一样的\n这说明：\n    算法是依附于存储结构的\n    不同的存储结构所执行的算法是不一样的\n广义定义：广义的算法也叫泛型\n无论数据是如何存储的，对给数据的操作都是一样的\n</code></pre>\n<p>我们至少可以通过两种结构来存储数据</p>\n<pre><code>*数组*\n优点：存取速度快\n缺点：\n1.需要一个连续的很大的内存\n2.插入和删除元素的效率很低\n\n专业术语：\n头节点:\n1.头节点的数据类型和首节点的数据类型是一模一样的\n2.头节点是首节点前面的那个节点\n3.头节点并不存放有效数据\n4.设置头节点的目的是为了方便对链表的操作\n头指针:\n存放头节点的地址的指针变量\n首节点:\n存放第一个有效数据的节点\n尾节点:\n存放最后一个有效数据的节点\n\n*链表*\n优点：\n1.插入删除元素效率高\n2.不需要一个连续的很大的内容\n缺点：查找某个位置的元素效率低\n</code></pre>\n<h6 id=\"专题：位运算符\"><a href=\"#专题：位运算符\" class=\"headerlink\" title=\"专题：位运算符\"></a>专题：位运算符</h6><p><code>&amp;</code>:按位与</p>\n<p><code>|</code>:按位或</p>\n<p><code>~</code>:按位取反</p>\n<p><code>^</code>:按位异或</p>\n<p><code>&lt;&lt;</code>:按位左移</p>\n<p><code>&gt;&gt;</code>:按位右移</p>\n<p><code>i&lt;&lt;1</code> 表示把i的所有二进制位左移一位</p>\n<p><strong>左移n为相当于乘以2的n次方</strong></p>\n<p><code>i&gt;&gt;3</code>表示把i的所有二进制位右移3位，左边一般是补0，当然也可能补1</p>\n<p><strong>右移相当于除以2的n次方，前提是数据不能够丢失</strong></p>\n<p><em>通过位运算符我们可以对数据的操作精确到每一位</em></p>\n<h6 id=\"专题：NULL\"><a href=\"#专题：NULL\" class=\"headerlink\" title=\"专题：NULL\"></a>专题：NULL</h6><p>二进制全部为零的含义 —00000000000000000000的含义</p>\n<p>1.数值零</p>\n<p>2.字符串结束标记符 ‘\\0’</p>\n<p>3.空指针NULL</p>\n<p>NULL表示的是零，而这个零不代表数字零，而表示的是内存单元的编号零</p>\n<p>计算机规定了，以零为编号的存储单元的内容不可读，不可写</p>\n","categories":["C语言","基础知识"],"tags":["C","常识"]},{"title":"每日一记","url":"/2023/01/15/%E6%97%A5%E8%AE%B0/","content":"<p>2023年1月15日 07:22:04 </p>\n<p>今天美滋滋</p>\n","categories":["日记"],"tags":["日记"]},{"title":"总结cpp中最基础的操作，以便忘了一看就能记起来。","url":"/20223/06/04/%E9%BB%91%E9%A9%ACcpp(%E4%B8%8B)/","content":"<h4 id=\"黑马C\"><a href=\"#黑马C\" class=\"headerlink\" title=\"黑马C++\"></a>黑马C++</h4><hr>\n<h5 id=\"一、第六天\"><a href=\"#一、第六天\" class=\"headerlink\" title=\"一、第六天\"></a>一、第六天</h5><h6 id=\"1-1-静态联编和动态联编\"><a href=\"#1-1-静态联编和动态联编\" class=\"headerlink\" title=\"1.1 静态联编和动态联编\"></a>1.1 静态联编和动态联编</h6><p>联编（Binding）是将程序中的函数、变量与相应的内存地址或存储位置关联起来的过程。</p>\n<blockquote>\n<p>C++中的多态主要指：动态多态</p>\n<p>静态多态：函数重载，运算符重载</p>\n<p>动态多态：父子继承 + 虚函数</p>\n</blockquote>\n<p>动态多态需满足条件：</p>\n<ol>\n<li>父类中有虚函数</li>\n<li>子类重写父类的虚函数</li>\n<li>父类的指针或引用,指向子类的对象</li>\n</ol>\n<p>**重写：子类重新实现父类中的虚函数，必须返回值，函数名，参数一致才称为重写</p>\n<p>**子类在做重写的时候，可以不加关键字virtual</p>\n<pre><code class=\"cpp\">class Animal\n&#123;\npublic:\n    virtual void speak()\n    &#123;\n        cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Cat:public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Dog :public Animal\n&#123;\npublic:\n    void speak()\n    &#123;\n        cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n//对于有父子关系的两个类，C++可以不需要通过类型强转\n//静态联编 --- 地址早绑定\n//动态联编 --- 地址晚绑定\n\n//多态的满足条件\n//1.父类中有虚函数\n//2.子类重写父类的虚函数\n//3.父类的指针或引用，指向子类的对象\n\n//重写：子类重新实现父类中的虚函数，必须返回值，函数名，参数一致才称为重写\n//子类在做重写的时候，可以不加关键字virtual\nvoid doSpeak(Animal&amp; animal)\n&#123;\n    animal.speak();\n&#125;\n\nvoid test01()\n&#123;\n    Cat cat;\n    doSpeak(cat);\n\n    Dog dog;\n    doSpeak(dog);\n&#125;\n</code></pre>\n<h6 id=\"1-2-多态原理\"><a href=\"#1-2-多态原理\" class=\"headerlink\" title=\"1.2 多态原理\"></a>1.2 多态原理</h6><p>当父类存在虚函数后，内部发生结构变化：</p>\n<p>多了指针vfptr（虚函数指针）指向vftable（虚函数表），虚函数内部记录着虚函数的地址。当子类重写后，会修改子类中虚函数表中记录的地址。注意：这并不会影响到父类的虚函数表</p>\n<img src=\"https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306021248036.png\" alt=\"image-20230602124829928\" style=\"zoom: 67%;\" />\n\n<h6 id=\"1-3-多态的深度剖析\"><a href=\"#1-3-多态的深度剖析\" class=\"headerlink\" title=\"1.3 多态的深度剖析\"></a>1.3 多态的深度剖析</h6><pre><code class=\"cpp\">//接上面的代码\nvoid test02()\n&#123;\n    Animal* animal = new Cat;\n    //animal-&gt;speak();\n    //*(int*)*(int*)animal speak函数的地址\n    ((void (*)())(*(int*)*(int*)animal))();\n\n    //C++的默认调用惯例 __stdcall\n    //下面的写法 调用惯例 __cdecl，我们要指定惯例为stdcall\n    typedef void(__stdcall*FUNC)(int);\n    (FUNC (*((int*)*(int*)animal + 1)))(10);\n&#125;\n</code></pre>\n<h6 id=\"1-4-多态案例-计算器\"><a href=\"#1-4-多态案例-计算器\" class=\"headerlink\" title=\"1.4 多态案例-计算器\"></a>1.4 多态案例-计算器</h6><pre><code class=\"cpp\">//利用多态实现计算器\nclass AbstractCalculator\n&#123;\npublic:\n\n    virtual int getResult()\n    &#123;\n        return 0;\n    &#125;\n    int m_A;\n    int m_B;\n&#125;;\n//加法计算器\nclass AddCalculator:public AbstractCalculator\n&#123;\n    virtual int getResult()\n    &#123;\n        return m_A + m_B;\n    &#125;\n&#125;;\n//减法计算器\nclass SubCalculator :public AbstractCalculator\n&#123;\n    virtual int getResult()\n    &#123;\n        return m_A - m_B;\n    &#125;\n&#125;;\n//乘法计算器\nclass MultiCalculator :public AbstractCalculator\n&#123;\n    virtual int getResult()\n    &#123;\n        return m_A * m_B;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    //加法计算器\n    AbstractCalculator* calculator = new AddCalculator;\n    calculator-&gt;m_A = 20;\n    calculator-&gt;m_B = 20;\n    cout &lt;&lt; calculator-&gt;getResult() &lt;&lt; endl;\n\n    delete calculator;\n\n    //减法计算器\n    calculator = new SubCalculator;\n    calculator-&gt;m_A = 20;\n    calculator-&gt;m_B = 20;\n    cout &lt;&lt; calculator-&gt;getResult() &lt;&lt; endl;\n\n&#125;\n//多态的好处 对扩展性提高、组织性强、可读性强\n//如果父类中有了虚函数，子类并没有重写子类的虚函数，那么这样的代码是毫无意义的\n//如果子类不重写父类虚函数，那么没有用到多态带来的好处，而且内部结构还变得更为复杂了\n</code></pre>\n<h6 id=\"1-5-抽象类和纯虚函数\"><a href=\"#1-5-抽象类和纯虚函数\" class=\"headerlink\" title=\"1.5 抽象类和纯虚函数\"></a>1.5 抽象类和纯虚函数</h6><p>纯虚函数语法 <code>virtual int getResult() = 0;</code>（告诉编译器，在vtable中为函数保留一个位置，但在这个特定位置不放地址）</p>\n<p>如果类中有了纯虚函数，那么这个类也称为抽象类，抽象类是无法实例化对象的</p>\n<p>继承了抽象类的子类，必须要重写父类中的纯虚函数，否则的话，子类也是属于抽象类，无法实例化对象了</p>\n<h6 id=\"1-6-虚析构与纯虚析构\"><a href=\"#1-6-虚析构与纯虚析构\" class=\"headerlink\" title=\"1.6 虚析构与纯虚析构\"></a>1.6 虚析构与纯虚析构</h6><p>如果子类中有数据创建在堆区，那么多态情况下，不会调用子类的析构代码</p>\n<p>解决方案：利用虚析构&#x2F;纯虚析构</p>\n<p>虚析构在析构前加关键字virtual即可</p>\n<p>纯虚析构 <code>virtual ~函数名（）= 0；</code>纯虚析构，类内声明，必须类外实现</p>\n<p>如果一个类中有了纯虚析构函数，那么这个类属于抽象类</p>\n<h6 id=\"1-7-向上向下类型转换\"><a href=\"#1-7-向上向下类型转换\" class=\"headerlink\" title=\"1.7 向上向下类型转换\"></a>1.7 向上向下类型转换</h6><img src=\"https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306021603117.png\" alt=\"image-20230602160324000\" style=\"zoom:67%;\" />\n\n<h6 id=\"1-8-重载重写重定义概念\"><a href=\"#1-8-重载重写重定义概念\" class=\"headerlink\" title=\"1.8 重载重写重定义概念\"></a>1.8 重载重写重定义概念</h6><p><strong>重载：</strong></p>\n<p>1.同一个作用域，函数名相同</p>\n<p>2.参数个数、参数类型、参数顺序不同</p>\n<p>3.返回值不可以作为重载条件</p>\n<p>4.const也可以作为重载条件</p>\n<p><strong>重写：</strong></p>\n<p>1.继承关系</p>\n<p>2.子类重写父类的虚函数</p>\n<p>3.函数返回值、函数名、参数列表与父类都一致</p>\n<p><strong>重定义（重定义）：</strong></p>\n<p>1.继承关系</p>\n<p>2.非虚函数，子类重新定义父类的同名成员</p>\n<h6 id=\"1-9-电脑组装案例\"><a href=\"#1-9-电脑组装案例\" class=\"headerlink\" title=\"1.9 电脑组装案例\"></a>1.9 电脑组装案例</h6><pre><code class=\"cpp\">//抽象层\n//抽象的CPU\nclass CPU\n&#123;\npublic:\n    virtual void calculate() = 0;\n&#125;;\n\n//抽象的显卡\nclass VideoCard\n&#123;\npublic:\n    virtual void display() = 0;\n&#125;;\n\n//抽象的内存\nclass Memory\n&#123;\npublic:\n    virtual void storge() = 0;\n&#125;;\n\n//电脑类\nclass computer\n&#123;\npublic:\n    computer(CPU* cpu, VideoCard* card, Memory* memory)\n    &#123;\n        this-&gt;cpu = cpu;\n        this-&gt;card = card;\n        this-&gt;memory = memory;\n    &#125;\n\n    //让电脑工作\n    void doWork()\n    &#123;\n        cpu-&gt;calculate();\n        card-&gt;display();\n        memory-&gt;storge();\n    &#125;\n\n    ~computer()\n    &#123;\n        if (this-&gt;cpu != NULL)\n        &#123;\n            delete this-&gt;cpu;\n            this-&gt;cpu = NULL;\n        &#125;\n        if (this-&gt;card != NULL)\n        &#123;\n            delete this-&gt;card;\n            this-&gt;card = NULL;\n        &#125;\n        if (this-&gt;memory != NULL)\n        &#123;\n            delete this-&gt;memory;\n            this-&gt;memory = NULL;\n        &#125;\n    &#125;\n\n    CPU* cpu;\n    VideoCard* card;\n    Memory* memory;\n&#125;;\n\n//实现层\n//intel的CPU\nclass intelCPU :public CPU\n&#123;\npublic:\n    virtual void calculate()\n    &#123;\n        cout &lt;&lt; &quot;intel的CPU开始计算了&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n//intel的显卡\nclass intelVideoCard :public VideoCard\n&#123;\n    virtual void display()\n    &#123;\n        cout &lt;&lt; &quot;intel的显卡开始显示了&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n//intel的内存\nclass intelMemory :public Memory\n&#123;\n    virtual void storge()\n    &#123;\n        cout &lt;&lt; &quot;intel的内存开始存储了&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    //第一台电脑组装\n    cout &lt;&lt; &quot;第一台电脑组装后：&quot; &lt;&lt; endl;\n    CPU* intel1 = new intelCPU;\n    VideoCard* card1 = new intelVideoCard;\n    Memory* mem1 = new intelMemory;\n\n    computer* computer1 = new computer(intel1, card1, mem1);\n    computer1-&gt;doWork();\n\n    delete computer1;\n&#125;\n</code></pre>\n<h5 id=\"二、第二天\"><a href=\"#二、第二天\" class=\"headerlink\" title=\"二、第二天\"></a>二、第二天</h5><h6 id=\"2-1-函数模板基础语法\"><a href=\"#2-1-函数模板基础语法\" class=\"headerlink\" title=\"2.1 函数模板基础语法\"></a>2.1 函数模板基础语法</h6><p><code>template&lt;typename T&gt;</code>告诉编译器T是万能数据类型，下面紧跟着的函数或者类中出现了这个T类型，不要报错</p>\n<p>调用模板函数的两种方式：</p>\n<p>1.自动类型推导—-必须让编译器推导一致T类型才能使用模板</p>\n<p>2.显示指定类型—-显示的告诉编译器T的类型 <code>mySwap&lt;int&gt;(a,b);</code></p>\n<p>即：模板使用的时候必须要告诉编译器T是什么类型，否则无法使用</p>\n<pre><code class=\"cpp\">//利用模板实现通用的交换\ntemplate&lt;typename T&gt; //T是一个通用类型，告诉编译器后面紧跟着的函数或类中出现了T，不要报错\nvoid mySwap(T&amp; a, T&amp; b)\n&#123;\n    T temp = a;\n    a = b;\n    b = temp;\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid mySwap2()\n&#123;\n\n&#125;\n\nvoid test01() \n&#123;\n    int a = 10;\n    int b = 20;\n    char x = &#39;x&#39;;\n    //1.自动类型推导，必须让编译器推导出一致的T，才能使用模板\n    // mySwap(a, x);错误的//a,x不能推出一致的T类型\n    //mySwap(a, b);\n\n    //2.显示指定类型\n    //mySwap&lt;int&gt;(a, x);//显示指定类型，可以进行隐式类型转换，如果转不成功，那么也不可以使用模板\n    mySwap&lt;int&gt;(a, b);\n\n    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot; b = &quot; &lt;&lt; b &lt;&lt; endl;\n\n    mySwap2&lt;double&gt;();//模板必须要指定T的类型，才能使用\n&#125;\n</code></pre>\n<h6 id=\"2-2-函数模板案例之int和char的数组排序\"><a href=\"#2-2-函数模板案例之int和char的数组排序\" class=\"headerlink\" title=\"2.2 函数模板案例之int和char的数组排序\"></a>2.2 函数模板案例之int和char的数组排序</h6><pre><code class=\"cpp\">//利用选择排序实现对int和char数组排序\ntemplate &lt;class T&gt;\nvoid mySwap(T&amp; a, T&amp; b) \n&#123;\n    T temp = a;\n    a = b;\n    b = temp;\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid mySort(T arr[],int len)\n&#123;\n    for (int i = 0; i &lt; len; ++i)\n    &#123;\n        int min = i;\n        for (int j = i + 1; j &lt; len; ++j)\n        &#123;\n            if (arr[min] &gt; arr[j])\n            &#123;\n                min = j;\n            &#125;\n        &#125;\n        //判断最小值下标和开始认定的i是否相等，如果不等，交换i和min下标的数据\n        if (min != i)\n        &#123;\n            mySwap(arr[i], arr[min]);\n        &#125;\n    &#125;\n&#125;\n\ntemplate &lt;class T&gt;\nvoid printArray(T arr[], int len)\n&#123;\n    for (int i = 0; i &lt; len; ++i)\n    &#123;\n        cout &lt;&lt; arr[i] &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid test01()\n&#123;\n    int arr[] = &#123; 15,2,6,23,61 &#125;;\n    int len = sizeof(arr) / sizeof(int);\n    mySort(arr, len);\n\n    //打印数组\n    printArray(arr, len);\n\n    char charArr[] = &quot;helloworld&quot;;\n    len = sizeof(charArr) / sizeof(char);\n    mySort(charArr, len);\n    printArray(charArr, len);\n&#125;\n</code></pre>\n<h6 id=\"2-3-函数模板与普通函数的区别及调用规则\"><a href=\"#2-3-函数模板与普通函数的区别及调用规则\" class=\"headerlink\" title=\"2.3 函数模板与普通函数的区别及调用规则\"></a>2.3 函数模板与普通函数的区别及调用规则</h6><p>普通函数可以隐式类型转换</p>\n<p>函数模板如果是自动类型推导，是不可以发生隐式类型转换的</p>\n<p>调用规则：</p>\n<p>1.如果函数模板和普通函数都可以实现调用，那么优先调用的是普通函数</p>\n<p>2.可以通过空参数列表语法来强制调用函数模板</p>\n<p>3.函数模板也可以发生函数重载</p>\n<p>4.如果函数模板可以产生更好的匹配，那么优先使用函数模板</p>\n<pre><code class=\"cpp\">int myPlus(int a, int b)\n&#123;\n    return a + b;\n&#125;\ntemplate&lt;class T&gt;\nT myPlus2(T a, T b)\n&#123;\n    return a + b;\n&#125;\nvoid test01()\n&#123;\n    int a = 10;\n    int b = 20;\n    char c = &#39;c&#39;;\n    cout &lt;&lt; myPlus(a, c) &lt;&lt; endl;//隐式类型转换，将char转为int类型\n    //myPlus2(a, c);//自动类型推导的方式是不能进行隐士类型转换的，但是显示指定类型的方式可以\n&#125;\n//普通函数与函数模板的调用规则\ntemplate&lt;class T&gt;\nvoid myPrint(T a, T b)\n&#123;\n    cout &lt;&lt; &quot;函数模板调用&quot; &lt;&lt; endl;\n&#125;\n/*\n//假设传入的T是int类型，生成一个下面的函数，这个函数称为模板函数（注意：一个是函数模板，一个是模板函数）\n//根据这个函数模板产生的函数叫模板函数\nvoid myPrint(int a, int b)\n&#123;\n    cout &lt;&lt; &quot;函数模板调用&quot; &lt;&lt; endl;\n&#125;\n*/\ntemplate&lt;class T&gt;\nvoid myPrint(T a, T b, T c)\n&#123;\n    cout &lt;&lt; &quot;函数模板调用myPrint(T a, T b，T c)&quot; &lt;&lt; endl;\n&#125;\n\nvoid myPrint(int a, int b)\n&#123;\n    cout &lt;&lt; &quot;普通函数调用&quot; &lt;&lt; endl;\n&#125;\nvoid test02()\n&#123;\n    //1.如果普通函数与函数模板可以同时调用，优先使用普通函数\n    int a = 0;\n    int b = 0;\n    myPrint(a, b);\n    //2.如果想强制使用函数模板中的内容，可以使用空参数列表\n    myPrint&lt;&gt;(a, b);\n    //3.函数模板也可以发生函数重载\n    myPrint(a, b, 10);\n    //4.如果函数模板可以产生更好的匹配，优先使用函数模板\n    char c = &#39;c&#39;;\n    char d = &#39;d&#39;;\n    myPrint(c, d);\n&#125;\n</code></pre>\n<h6 id=\"2-4-模板机制\"><a href=\"#2-4-模板机制\" class=\"headerlink\" title=\"2.4 模板机制\"></a>2.4 模板机制</h6><p>1.编译器并不是把函数模板处理成能够处理任何类型的函数</p>\n<p>2.函数模板通过具体类型产生不同的函数（产生了模板函数，见上面的代码）</p>\n<p>3.编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译</p>\n<h6 id=\"2-5-模板的局限性以及解决\"><a href=\"#2-5-模板的局限性以及解决\" class=\"headerlink\" title=\"2.5 模板的局限性以及解决\"></a>2.5 模板的局限性以及解决</h6><p>模板并不是真正的通用代码，对于一些自定义数据类型，模板有时候不能实现效果</p>\n<p>可以通过具体化实现对自定义数据类型进行操作</p>\n<p><code>template&lt;&gt;bool myCompare&lt;Person&gt;(Person&amp; a, Person&amp; b)</code></p>\n<pre><code class=\"cpp\">#include&lt;string&gt;\nclass Person\n&#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Age = age;\n        this-&gt;m_Name = name;\n    &#125;\n\n    string m_Name;\n    int m_Age;\n&#125;;\n//通过模板进行两个数据的比较\ntemplate&lt;class T&gt;\nbool myCompare(T&amp; a, T&amp; b)\n&#123;\n    if (a == b)\n    &#123;\n        return true;\n    &#125;\n    return false;\n&#125;\n//利用具体化Person函数，告诉编译器走Person对比代码\ntemplate&lt;&gt;bool myCompare&lt;Person&gt;(Person&amp; a, Person&amp; b)\n&#123;\n    if (a.m_Age == b.m_Age &amp;&amp; a.m_Name == b.m_Name)\n    &#123;\n        return true;\n    &#125;\n    return false;\n&#125;\nvoid test01()\n&#123;\n    Person p1(&quot;Tom&quot;, 19);\n    Person p2(&quot;Jerry&quot;, 20);\n\n    bool ret = myCompare(p1, p2);\n    if (ret)\n    &#123;\n        cout &lt;&lt; &quot;p1和p2相等&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;p1和p2不相等&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"2-6-类模板的基本语法\"><a href=\"#2-6-类模板的基本语法\" class=\"headerlink\" title=\"2.6 类模板的基本语法\"></a>2.6 类模板的基本语法</h6><p>&#x3D;&#x3D;泛型编程：类型参数化&#x3D;&#x3D;</p>\n<p>template下面紧跟着的是个类，那么这个类成为类模板。</p>\n<p>类模板与函数模板区别：</p>\n<p>1.类模板使用时不可以使用类型推导，必须是显示指定类型</p>\n<p>2.类模板中的类型，可以有默认参数</p>\n<pre><code class=\"cpp\">//template下面紧跟着的内容是类，那么这个类称为类模板\n//类模板中的类型也可以有默认参数\n//泛型编程：类型参数化\ntemplate&lt;class NAMETYPE,class AGETYPE=int&gt;\nclass Person\n&#123;\npublic:\n    Person(NAMETYPE name, AGETYPE age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n    NAMETYPE m_Name;\n    AGETYPE m_Age;\n&#125;;\nvoid test01()\n&#123;\n    //Persom p1(&quot;Tom,11&quot;);//对于类模板，使用时不能用自动类型推导\n    Person&lt;string&gt; p1(&quot;Tom&quot;, 11);//必须使用显示指定类型\n    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p1.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p1.m_Age &lt;&lt; endl;\n&#125;\n</code></pre>\n<h6 id=\"2-7-类模板中的成员函数创建时机\"><a href=\"#2-7-类模板中的成员函数创建时机\" class=\"headerlink\" title=\"2.7 类模板中的成员函数创建时机\"></a>2.7 类模板中的成员函数创建时机</h6><p>&#x3D;&#x3D;类模板中的成员函数并不是一开始就创建出来的，而是在运行阶段才创建出来&#x3D;&#x3D;</p>\n<pre><code class=\"cpp\">class Person1\n&#123;\npublic:\n    void showPerson1()\n    &#123;\n        cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\nclass Person2\n&#123;\npublic:\n    void showPerson2()\n    &#123;\n        cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n//类模板中的成员函数并不是一开始就创建出来的，而是在运行阶段才创建出来\ntemplate&lt;class T&gt;\nclass myClass\n&#123;\npublic:\n\n    void func1()\n    &#123;\n        obj.showPerson1();\n    &#125;\n    void func2()\n    &#123;\n        obj.showPerson2();\n    &#125;\n    T obj;\n&#125;;\n\nvoid test01()\n&#123;\n    myClass&lt;Person1&gt; p1;\n    p1.func1();//运行成功\n    p1.func2();//&quot;showPerson2&quot;: 不是 &quot;Person1&quot; 的成员\n&#125;\n</code></pre>\n<h6 id=\"扩展：typeid-T1-name\"><a href=\"#扩展：typeid-T1-name\" class=\"headerlink\" title=\"扩展：typeid(T1).name()\"></a>扩展：<code>typeid(T1).name()</code></h6><p>用于查看T类型名称</p>\n<h6 id=\"2-8-类模板作为函数参数\"><a href=\"#2-8-类模板作为函数参数\" class=\"headerlink\" title=\"2.8 类模板作为函数参数\"></a>2.8 类模板作为函数参数</h6><p>1.指定传入类型</p>\n<p>2.参数模板化</p>\n<p>3.整个类模板化</p>\n<pre><code class=\"cpp\">#include&lt;string&gt;\ntemplate&lt;class NAMETYPE,class AGETYPE&gt;\nclass Person\n&#123;\npublic:\n    Person(NAMETYPE name, AGETYPE age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n\n    NAMETYPE m_Name;\n    AGETYPE m_Age;\n&#125;;\n//1.指定传入的类型\nvoid doWork(Person&lt;string,int&gt;&amp; p)\n&#123;\n    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;\n&#125;\nvoid test01()\n&#123;\n    Person&lt;string, int&gt; p1(&quot;aaa&quot;, 10);\n    doWork(p1);\n&#125;\n\n//2.参数模板化\ntemplate&lt;class T1,class T2&gt;\nvoid doWork2(Person&lt;T1,T2&gt;&amp; p)\n&#123;\n    cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;\n    cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;\n    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;\n&#125;\nvoid test02()\n&#123;\n    Person&lt;string, int&gt; p1(&quot;bbb&quot;, 10);\n    doWork2(p1);\n&#125;\n\n//3.整个类模板化\ntemplate&lt;class T&gt;\nvoid doWork3(T&amp; p)\n&#123;\n    cout &lt;&lt; typeid(T).name() &lt;&lt; endl;\n    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;\n&#125;\nvoid test03()\n&#123;\n    Person&lt;string, int&gt; p1(&quot;ccc&quot;, 10);\n    doWork3(p1);\n&#125;\n</code></pre>\n<h6 id=\"2-9-类模板碰到继承的问题以及解决\"><a href=\"#2-9-类模板碰到继承的问题以及解决\" class=\"headerlink\" title=\"2.9 类模板碰到继承的问题以及解决\"></a>2.9 类模板碰到继承的问题以及解决</h6><p>如果父类是一个类模板，子类在做继承时，必须指出父类中T的类型，否则无法给父类中的T分配内存</p>\n<p>语法：<code>class Son :public Base&lt;T2&gt;</code></p>\n<pre><code class=\"cpp\">template&lt;class T&gt;\nclass Base\n&#123;\n    T m_A;//子类创建时，必须要知道T的类型，才能给父类中的m_A分配内存\n&#125;;\n\ntemplate&lt;class T1, class T2&gt;\nclass Son :public Base&lt;T2&gt;\n&#123;\n    T1 m_B;\n&#125;;\n\nvoid test01()\n&#123;\n    Son&lt;int, double&gt; s;\n&#125;\n</code></pre>\n<h6 id=\"2-10-类模板的类外实现\"><a href=\"#2-10-类模板的类外实现\" class=\"headerlink\" title=\"2.10 类模板的类外实现\"></a>2.10 类模板的类外实现</h6><p><code>template&lt;class T1, class T2&gt;</code></p>\n<p><code>void Person&lt;T1, T2&gt;::showPerson()&#123;&#125;</code></p>\n<pre><code class=\"cpp\">#include&lt;string&gt;\ntemplate&lt;class T1, class T2&gt;\nclass Person\n&#123;\npublic:\n    Person(T1 name, T2 age);\n\n    void showPerson();\n\n    T1 m_Name;\n    T2 m_Age;\n&#125;;\n\ntemplate&lt;class T1,class T2&gt;\nPerson&lt;T1,T2&gt;::Person(T1 name, T2 age)\n&#123;\n    this-&gt;m_Name = name;\n    this-&gt;m_Age = age;\n&#125;\ntemplate&lt;class T1, class T2&gt;\nvoid Person&lt;T1, T2&gt;::showPerson()\n&#123;\n    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    Person&lt;string, int&gt; p(&quot;aaa&quot;, 10);\n    p.showPerson();\n&#125;\n</code></pre>\n<h6 id=\"2-11-类模板的分文件编写问题以及解决\"><a href=\"#2-11-类模板的分文件编写问题以及解决\" class=\"headerlink\" title=\"2.11 类模板的分文件编写问题以及解决\"></a>2.11 类模板的分文件编写问题以及解决</h6><p>类模板不建议做分文件编写，因为成员函数创建在运行阶段，使用时必须包含.cpp才可以</p>\n<p>解决方案：将类中成员函数的声明和实现都写到一个文件中，并且将文件的后缀名改成.hpp（约定俗成）</p>\n<h6 id=\"2-12-类模板碰到友元函数\"><a href=\"#2-12-类模板碰到友元函数\" class=\"headerlink\" title=\"2.12 类模板碰到友元函数\"></a>2.12 类模板碰到友元函数</h6><p>全局函数做友元的类内实现</p>\n<p>全局函数做友元的类外实现</p>\n<p>1.模板函数的声明 2.模板函数的实现</p>\n<pre><code class=\"cpp\"># include&lt;string&gt;\n//（属于2/3方法）告诉编译器有个Person模板类，先不要报错\ntemplate&lt;class T1, class T2&gt; class Person;\n//（属于2方法）告诉编译器有一个模板函数的声明\ntemplate&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt;&amp; p);\n//（属于3方法）将模板函数的声明和实现写在一起\ntemplate&lt;class T1, class T2&gt;\nvoid printPerson3(Person&lt;T1, T2&gt;&amp; p)\n&#123;\n    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;\n&#125;\n\ntemplate&lt;class T1, class T2&gt;\nclass Person\n&#123;\n    //1.全局函数配合友元做类内实现\n    friend void printPerson(Person&lt;T1, T2&gt;&amp; p)\n    &#123;\n        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;\n    &#125;\n    //2.全局函数配合友元做类外实现\n    friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt;&amp; p);\n    //3.全局函数配合友元做类外实现\n    friend void printPerson3&lt;&gt;(Person&lt;T1, T2&gt;&amp; p);\n\npublic:\n    Person(T1 name, T2 age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\nprivate:\n    T1 m_Name;\n    T2 m_Age;\n&#125;;\n\ntemplate&lt;class T1, class T2&gt;\nvoid printPerson2(Person&lt;T1, T2&gt;&amp; p)\n&#123;\n    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    Person&lt;string, int&gt; p(&quot;aaa&quot;, 10);\n    printPerson2(p);\n&#125;\n</code></pre>\n<h5 id=\"三、第三天\"><a href=\"#三、第三天\" class=\"headerlink\" title=\"三、第三天\"></a>三、第三天</h5><h6 id=\"3-1-静态类型和动态类型转换\"><a href=\"#3-1-静态类型和动态类型转换\" class=\"headerlink\" title=\"3.1 静态类型和动态类型转换\"></a>3.1 静态类型和动态类型转换</h6><p>1.静态类型转换 static_cast</p>\n<p>语法：static_cast&lt;目标类型&gt;(原对象);对于内置数据类型是可以转换的，对于自定义数据类型，必须是父子之间的指针或者引用可以转换成功</p>\n<p>2.动态类型转换 dynamic_cast</p>\n<p>对于内置数据类型不可以转换，对于自定义数据类型：父转子，不安全，转换失败；子转父，安全，转换成功；如果发生多态，那么总是安全的，成功。</p>\n<pre><code class=\"cpp\">//1.静态类型转换\nvoid test01()\n&#123;\n    //内置数据类型\n    char a = &#39;a&#39;;\n\n    //static_cast&lt;目标类型&gt;(原对象)\n    double d = static_cast&lt;double&gt;(a);\n\n    cout &lt;&lt; d &lt;&lt; endl;\n&#125;\nclass Base\n&#123;\npublic:\n    virtual void func()\n    &#123;\n        ;\n    &#125;\n&#125;;\nclass Son : public Base\n&#123;\npublic:\n    void func()\n    &#123;\n        ;\n    &#125;\n&#125;;\nclass Other\n&#123;&#125;;\nvoid test02()\n&#123;\n    //自定义的数据类型\n    Base* base = NULL;\n    Son* son = NULL;\n\n    //将base转为son*类型，向下类型转换，不安全\n    //Son* son2 = static_cast&lt;Son*&gt;(base);\n    //将son转为base*类型，向上类型转换，安全\n    Base* base2 = static_cast&lt;Base*&gt;(son);\n\n    //base转为Other\n    //没有父子关系的两个类型无法转换成功\n    //Other* other = static_cast&lt;Other*&gt;(base);\n&#125;\n//2.动态类型转换\nvoid test03()\n&#123;\n    //内置数据类型，不允许内置数据类型之间的转换\n    //char c = &#39;c&#39;;\n    //double d = dynamic_cast&lt;double&gt;(c);\n    Base* base = NULL;\n    Son* son = NULL;\n\n    //将base转为son*类型，向下类型转换，不安全\n    //不安全，转换失败\n    //Son* son2 = dynamic_cast&lt;Son*&gt;(base);\n    //将son转为base*类型，向上类型转换，安全\n    Base* base2 = dynamic_cast&lt;Base*&gt;(son);\n\n    //如果发生了多态，父子之间的转换总是安全的\n    Base* base3 = new Son;\n    //将Base3转为Son*\n    Son* son3 = dynamic_cast&lt;Son*&gt;(base3);\n&#125;\n</code></pre>\n<h6 id=\"3-2-常量转换及重新解释转换\"><a href=\"#3-2-常量转换及重新解释转换\" class=\"headerlink\" title=\"3.2 常量转换及重新解释转换\"></a>3.2 常量转换及重新解释转换</h6><p>1.常量类型转换 const_cast</p>\n<p>只能对指针&#x2F;引用使用</p>\n<p>2.重新解释类型转换 reinterpret_cast</p>\n<p>不建议使用，不安全</p>\n<pre><code class=\"cpp\">//3.常量转换\nvoid test04()\n&#123;\n    //指针之间的转换\n    const int* p = NULL;\n    //将const int*转为int*\n    int* p2 = const_cast&lt;int*&gt; (p);\n    //将int*转为const int*\n    const int* p3 = const_cast&lt;const int*&gt;(p2);\n\n    //引用之间的转换\n    const int a = 10;\n    const int&amp; aRef = a;\n\n    int&amp; aRef2 = const_cast&lt;int&amp;&gt;(aRef);\n\n    //不可以对非指针或非引用做const_cast转换\n    //int b = const_cast&lt;int&gt;(a);\n&#125;\n//4.重新解释转换，最不安全，不建议用\nvoid test05()\n&#123;\n    int a = 10;\n    int* p = reinterpret_cast&lt;int*&gt;(a);\n    //将base*转为Other*\n    Base* base = NULL;\n    //两个类的成员函数，属性一点都不一样，还是能转换成功\n    Other* other = reinterpret_cast&lt;Other*&gt;(base);\n&#125;\n</code></pre>\n<h6 id=\"3-3-异常的基本语法\"><a href=\"#3-3-异常的基本语法\" class=\"headerlink\" title=\"3.3 异常的基本语法\"></a>3.3 异常的基本语法</h6>","categories":["C++","基础知识"],"tags":["常识","C++"]},{"title":"总结cpp中最基础的操作，以便忘了一看就能记起来。","url":"/20223/06/04/%E9%BB%91%E9%A9%ACcpp(%E4%B8%8A)/","content":"<h4 id=\"黑马C\"><a href=\"#黑马C\" class=\"headerlink\" title=\"黑马C++\"></a>黑马C++</h4><hr>\n<h5 id=\"一、第一天\"><a href=\"#一、第一天\" class=\"headerlink\" title=\"一、第一天\"></a>一、第一天</h5><pre><code class=\"cpp\"># include &lt;iostream&gt;  //标准的输入输出流 in输入 out输出\nusing namespace std;  //使用命名空间 std 打开一个叫std的房间\n\n//程序入口\nint main(void)\n&#123;\n    // cout 标准的输出\n    // &lt;&lt; 拼接的作用\n    // endl 结束换行并刷新缓冲区\n    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; 123 &lt;&lt; endl;\n    system(&quot;pause&quot;);  //阻塞功能\n    return EXIT_SUCCESS;  //返回正常退出\n&#125;\n</code></pre>\n<h6 id=\"1-1-双冒号作用域运算符\"><a href=\"#1-1-双冒号作用域运算符\" class=\"headerlink\" title=\"1.1 双冒号作用域运算符\"></a>1.1 双冒号作用域运算符</h6><p><code>::</code>:作用域运算符有两种用法</p>\n<p>1、作用域::变量名或其它名</p>\n<pre><code class=\"cpp\">eg:\nstd::cout (用了这个，就不用using namespace std;了)\n</code></pre>\n<p>2、</p>\n<p>::变量名</p>\n<pre><code class=\"cpp\">int atk = 200;\nvoid test01(void)\n&#123;\n    int atk = 100;\n    cout &lt;&lt; &quot;攻击力：&quot; &lt;&lt; atk &lt;&lt; endl;\n    // ::双冒号（作用域运算符 :: 全局作用域）\n    cout &lt;&lt; &quot;全局攻击力：&quot; &lt;&lt; ::atk &lt;&lt; endl;\n&#125;\n输出结果：\n----------------\n攻击力：100\n全局攻击力：200\n----------------\n</code></pre>\n<h6 id=\"1-2-namespace-命名空间\"><a href=\"#1-2-namespace-命名空间\" class=\"headerlink\" title=\"1.2 namespace(命名空间)\"></a>1.2 namespace(命名空间)</h6><p><strong>用途</strong>：解决命名冲突问题<br>        <strong>注意</strong>：必须在全局作用域下声明<br>        <strong>内容</strong>：命名空间中可以放入函数，变量，结构体，类（命名空间还可以嵌套命名空间）<br>        <strong>另外</strong>：命名空间是开放的，可以随时加入新的成员；且命名空间可以起别名</p>\n<h6 id=\"1-3-using的使用\"><a href=\"#1-3-using的使用\" class=\"headerlink\" title=\"1.3 using的使用\"></a>1.3 using的使用</h6><p>1、使用using时，要避免局部变量与之冲突</p>\n<p>2、就近原则的优先级高于“打开房间”这个操作</p>\n<p>3、用using打开两个房间，会导致程序不知道用哪个</p>\n<h6 id=\"1-4-cpp对c语言的增强\"><a href=\"#1-4-cpp对c语言的增强\" class=\"headerlink\" title=\"1.4 cpp对c语言的增强\"></a>1.4 cpp对c语言的增强</h6><pre><code class=\"cpp\">* 全局变量检测增强\n\n* 函数检测增强:形参前必须要有类型;若定义函数名前不是void，则必须要有返回值;函数调用参数检测增强;\n\n* 类型转换检测增强\n\n* 结构体(struct)增强:cpp中结构体可以放函数,C语言中构造结构体用struct Person p1;cpp中可以直接用Person p1;\n\n* 相比C语言新增bool类型:bool flag = true;\n\n* 三目运算符的增强a&gt;b ? a : b = 100; b的值会被改成100(三目运算符中C语言返回的是值，cpp返回的是变量)\n</code></pre>\n<h6 id=\"1-5-const-常量\"><a href=\"#1-5-const-常量\" class=\"headerlink\" title=\"1.5 const(常量)\"></a>1.5 const(常量)</h6><p><strong>1、const不分配内存，但取地址会分配临时内存</strong></p>\n<p>c语言中，const修饰的变量，是伪常量，编译器是会分配内存的（可以用指针修改）</p>\n<p>cpp中，const不会分配内存，而是放在符号表中</p>\n<p>eg: <code>const int n_a = 10；</code><strong>（基本上只有这个方式，不会分配内存，而是放到符号表中）</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">key(键值)</th>\n<th align=\"center\">value(实值)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">n_a</td>\n<td align=\"center\">10</td>\n</tr>\n</tbody></table>\n<pre><code class=\"cpp\">const int b = 20;\nint* p = (int*)&amp;b;\n*p = 200;\ncout &lt;&lt; b &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n输出结果：\n20\n200\n\n为什么会输出200？\n在int* p = (int*)&amp;b;中编译器会临时开辟一块内存空间；\n相当于：\nint tmp = b;  //给tmp分配了一块内存空间，将b的值赋给它\nint* p = (int *)&amp;tmp;  //*p指向的是临时的那块空间\n</code></pre>\n<p><strong>2、用extern  编译器也会给const变量分配内存</strong></p>\n<p>C语言中，默认const是外部链接</p>\n<p>cpp中，默认const是内部链接（即只有在当前文件夹内才能访问）</p>\n<p>如果想提高const的作用域，用<code>extern</code></p>\n<p><code>extern const int a = 10;</code>(可将const转换为外部链接)</p>\n<p><strong>3、用变量初始化const变量</strong></p>\n<pre><code class=\"cpp\">int a = 10;\nconst int b = a;  //会分配内存\n</code></pre>\n<p><strong>注意：只要是分配内存的，都能用指针修改它</strong></p>\n<p><strong>4、自定义数据类型分配内存</strong></p>\n<pre><code class=\"cpp\">struct Person\n&#123;\n    string m_Name;\n    int m_Age;\n&#125;\n</code></pre>\n<p><strong>5、尽量用const来代替#define</strong></p>\n<pre><code class=\"cpp\">在旧版本c中，如果想建立一个常量，必须使用预处理器\n#define MAX 1024;\n我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX都已经被替换为了1024\n因此，并没有将MAX加入到符号表中。但如果我们使用这个常量获得一个错误的编译错误信息时，\n我们看到的是1024而非MAX。若MAX被定义在一个不是我写的头文件中，我可能不知道1024意味着什么，\n为了解决这个问题可能要花费很长时间。\n解决办法就是用一个常量替换上面的宏\nconst MAX = 1024;\n1.const有类型，可进行编译器安全检查\n2.const有作用域，而#define默认是从定义处到程序结束\n</code></pre>\n<h6 id=\"1-6-引用\"><a href=\"#1-6-引用\" class=\"headerlink\" title=\"1.6 引用\"></a>1.6 引用</h6><p><strong>1、引用的实质就是起别名(<code>类型 &amp;别名 = 原名;</code>)</strong></p>\n<pre><code class=\"cpp\">int a = 10;\nint &amp;b = a;就是给变量a取一个别名b(实质：int* const b = &amp;a ;b存放的是a的地址)\n(当使用b时,eg:b = 10;实质上是:*b = 10;)\n(&amp;写到等号左侧，叫引用；写到右侧，就是取地址符)\n</code></pre>\n<p><strong>2、引用初始化后不可修改</strong></p>\n<p>即b做了a的别名以后，不能再做c的别名</p>\n<ul>\n<li>对数组建立引用</li>\n</ul>\n<pre><code class=\"cpp\">int arr[10];\nfor (int i=0; i&lt;10; ++i)\n&#123;\n    arr[i] = i;\n&#125;\n//第一种方式\nint (&amp;pArr)[10] = arr;\nfor (int i; i&lt;10; ++i)\n&#123;\n    cout &lt;&lt; pArr[i] &lt;&lt; &quot; &quot;;\n&#125;\ncout &lt;&lt; endl;\n//第二种方式\ntypedef int(ARRAYREF)[10];  //一个具有十个元素的int类型数组\nARRAYREF &amp;pArr2 = arr;\nfor (int i = 0; i &lt; 10; ++i)\n&#123;\n    cout &lt;&lt; pArr2[i] &lt;&lt; &quot; &quot;;\n&#125;\ncout &lt;&lt; endl;\n</code></pre>\n<p><strong>3、引用的注意事项</strong></p>\n<ul>\n<li><p>引用必须引一块合法(存在、能引用)的内存空间</p>\n</li>\n<li><p>不要返回局部变量的引用</p>\n</li>\n</ul>\n<p><strong>4、引用的本质(是一个指针常量)</strong></p>\n<pre><code class=\"cpp\">int a = 10;\nint&amp; aRef = a;  //自动转换为int* const aRef = &amp;a;这也能说明为什么必须初始化\naRef = 20;  //内部发现aRef是引用，自动帮我们转换为：*aRef = 20；`````````````````````\n</code></pre>\n<p><strong>5、常量引用</strong></p>\n<pre><code class=\"cpp\">//int&amp; ref = 10;  //引用了不合法的内存\nconst int&amp; ref = 10;  //加入const后，编译器处理方式为：int tmp = 10;const int &amp;ref = tmp;\n//ref = 10;\nint* p = (int*)&amp;ref;\n*p = 1000;\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\n输出结果：\n----------------\nref = 1000\n----------------\n</code></pre>\n<p><strong>6、用一级指针引用可以代替二级指针</strong></p>\n<pre><code class=\"cpp\">void f(int &amp;p)  //主调函数传过来一个值，用&amp;能直接提取该值的地址\n&#123;\n    ;\n&#125;\n//在C++中，当我们将一个值作为参数传递给函数时，实际上会发生参数的复制。复制操作会创建一个新的变量，该变量具有与原始值相同的值。\n//当我们在函数参数中使用&amp;（取地址符）时，它表示取得该变量的内存地址。通过使用&amp;，我们可以获取原始值的地址，而不是复制后的值的地址。\n//这种通过引用获取原始值地址的机制称为引用传递（pass by reference），它允许函数在不进行复制的情况下直接访问和修改原始值。\n</code></pre>\n<p><strong>7、使用场景：修饰形参为只读（防君子不防小人）</strong></p>\n<pre><code class=\"cpp\">void showValue(const int &amp;val)\n&#123;\n    val += 1000;  //如果只是想显示内容，而不修改内容，那么就用const修饰这个形参\n    cout &lt;&lt; &quot;val = &quot; &lt;&lt; val &lt;&lt; endl;\n&#125;\n</code></pre>\n<p><strong>8、注意：const int &amp;a &#x3D; 10;会分配内存</strong></p>\n<h5 id=\"二、第二天\"><a href=\"#二、第二天\" class=\"headerlink\" title=\"二、第二天\"></a>二、第二天</h5><h6 id=\"2-1-class\"><a href=\"#2-1-class\" class=\"headerlink\" title=\"2.1 class\"></a>2.1 class</h6><pre><code class=\"cpp\">类的创建\nclass 类名\n&#123;\npublic:  //公共权限\n//设置成员属性\n//设置成员函数\n&#125;;\n实例化对象\n类名 对象名;\n通过对象来设置属性，调用成员函数\n    **类是对对象的抽象\n对象是对类的实例**\n</code></pre>\n<h6 id=\"2-2-内联函数-用于代替C语言中的预处理宏\"><a href=\"#2-2-内联函数-用于代替C语言中的预处理宏\" class=\"headerlink\" title=\"2.2 内联函数(用于代替C语言中的预处理宏)\"></a>2.2 内联函数(用于代替C语言中的预处理宏)</h6><p>宏：</p>\n<pre><code class=\"cpp\">C语言为什么要用宏？\n答：我们在编程时，有一些很短但是执行频繁的计算；因为太短了，我不想写成函数，又可以避免函数调用的开销，所以用宏。\n\n但是宏有不小的缺点，宏的缺点如下：\n1、运行结果与预想的不符(宏看起来像一个函数调用，但会隐藏一些难以发现的错误)\neg:\n定义一个加法\n#define MyADD(x, y) x+y\nvoid test01()\n&#123;\n    int ret = MyADD(10, 20) * 20;\n    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;\n&#125;\n输出结果：\n-------------\nret = 410\n-------------\n可以预想到实际运行的是x+y*20 = 410\n\n优化一下（把括号加上，避免算数优先级导致问题）：\n#define MyCompare(a, b) ((a) &lt; (b)) ? (a) : (b)\nvoid test02()\n&#123;\n    int a = 10;\n    int b = 20;\n    int ret = MyCompare(++a, b);\n\n    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;\n&#125;\n输出结果：\n-------------\nret = 12\n-------------\n还是与预想的11不符\n\n2、在cpp中，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类的成员函数\n</code></pre>\n<p>内联函数：</p>\n<pre><code class=\"cpp\">内联函数定义\ninline 函数定义\neg：\ninline void mycompare(int a, int b)\n&#123;\n    int ret = a &lt; b ? a : b\n    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;\n&#125;\n\n内联函数注意事项：\ninline void func();  //内联函数声明\ninline void func()\n&#123; \n    ; \n&#125;  //如果函数实现的时候，没有加inline关键字，那么这个函数依然不算内联函数\n\n内联函数的优点：\n&quot;以空间换时间&quot;（内联函数除了没有宏的缺点外，基本可以当做宏来使用）\n\n内联函数与class：\n在class(类)中，成员函数默认都是加了内联函数关键字(inline)的\n\n内联函数与编译器：\n内联函数只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有\n将函数声明为内联函数，编译器也可能将小的，简单的函数声明为内联函数；\n在这些情况下，编译器不会将inline关键字修饰的函数当内联函数处理\n1.不能存在任何形式的循环语句\n2.不能存在过多的条件判断语句\n3.函数体不能过于庞大\n4.不能对函数进行取址操作\n</code></pre>\n<h6 id=\"2-3-函数的默认参数\"><a href=\"#2-3-函数的默认参数\" class=\"headerlink\" title=\"2.3 函数的默认参数\"></a>2.3 函数的默认参数</h6><pre><code class=\"cpp\">//函数的默认参数 参数后面 = ......\n//函数参数的注意事项，如果有一个位置有了默认参数，那么从这个位置开始，从左往右都必须有默认参数\nvoid func(int a =10, int b, int c =1)  //a有了默认参数，a右边的b没有，报错\n&#123;\n    cout &lt;&lt; &quot;ａ+ b + c = &quot; &lt;&lt; a + b + c&lt;&lt; endl;\n&#125;\nvoid test01()\n&#123;\n    func(1, 2, 3);\n&#125;\n注意:\n//函数声明里面有了默认参数，那么函数实现的时候必须没有\n//函数声明和实现中，只能有一个默认参数，不要同时出现，因为我可能写的不一样，编译器不知道用哪个\nvoid myFunc(int a = 10, int b = 10);\nvoid myFunc(int a = 10, int b = 10)&#123;&#125;\n报错：重定义默认参数\n</code></pre>\n<p>附加：占位参数</p>\n<pre><code class=\"cpp\">//函数 占位参数\n//如果有了占位参数，函数调用时候必须要提供这个参数，但是用不到这个参数\n//占位参数 没有什么用 只有后面重载 ++符号才有一点用\n//占位参数 可以有默认值\nvoid func2(int a, int)\n&#123;\n\n&#125;\nvoid test02()\n&#123;\n    func2(10, 1);\n&#125;\n</code></pre>\n<h6 id=\"专题：函数重载-overload\"><a href=\"#专题：函数重载-overload\" class=\"headerlink\" title=\"专题：函数重载(overload)\"></a>专题：函数重载(overload)</h6><p>实现函数重载的条件</p>\n<p>1、同一个作用域</p>\n<p>2、参数个数不同or参数类型不同or参数顺序不同</p>\n<p>3、返回值类型不能作为函数重载的条件（因为调用函数时eg：func(a,b);无法区分到底用不用返回值）</p>\n<p>4、当函数重载碰到了默认参数时，要注意避免二义性问题</p>\n<pre><code class=\"cpp\">eg:\nvoid func2(int a, int b = 10)\n&#123;\n\n&#125;\nvoid func2(int a)\n&#123;\n\n&#125;\n</code></pre>\n<p>5、const也可以作为重载的条件</p>\n<pre><code class=\"cpp\">void func3(const int &amp;a)  //引用必须要引合法的内存空间//const也可以作为重载的条件\n&#123;\n\n&#125;\nvoid test03()\n&#123;\n    int a = 10;\n    func3(10);\n&#125;\n</code></pre>\n<p>函数重载的原理</p>\n<pre><code class=\"cpp\">为实现函数重载，不同的编译器会用不同的机制来修饰函数名\n如：void func(),编译器内部可能会将其修饰为_func;\nvoid func(int x),编译器内部可能将其修饰为_func_int;\nvoid func(int x, cahr c),编译器内部可能将其修饰为_func_int_char\n</code></pre>\n<h6 id=\"2-4-extern-“C”浅析\"><a href=\"#2-4-extern-“C”浅析\" class=\"headerlink\" title=\"2.4 extern “C”浅析\"></a>2.4 extern “C”浅析</h6><pre><code class=\"cpp\">解决的问题 在C++中调用C语言的函数(由于函数重载，C++中编译器可能会把函数名改掉)\n(C++比C语言多了些特性，所以直接调用可能会出问题，用下面的方式能屏蔽C++的特性，用C语言的语法规则使用函数)\n\n调用多个：\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n......(C语言的函数 eg: void func(); )\n#ifdef __cplusplus\n&#125;\n#endif\n\n调用单个:\nextern &quot;C&quot; void func();\n</code></pre>\n<h6 id=\"专题：封装\"><a href=\"#专题：封装\" class=\"headerlink\" title=\"专题：封装\"></a>专题：封装</h6><p><strong>1、属性和行为作为一个整体来表示生活中的事物</strong></p>\n<p>（与C语言相区分，C语言中strucrt中不能放函数，就可能造成“人”的行为作用到“狗”的属性上）</p>\n<p><strong>2、在c++中struct和class是一个意思，唯一的不同，默认权限， struct是public，而class默认权限是private</strong></p>\n<p><strong>3、私有权限(private)  就是私有成员，在类内部可以访问，类外部不可访问<br>公共权限(public)  在类内部和外部都可以访问<br>保护权限(protected)  类内部可以访问（以及当前类子类可以访问），类外部不可以访问</strong></p>\n<p><strong>建议：将所有成员变量都设置为private，对外提供读或写的接口</strong></p>\n<h5 id=\"三、第三天\"><a href=\"#三、第三天\" class=\"headerlink\" title=\"三、第三天\"></a>三、第三天</h5><h6 id=\"3-1-分文件编写\"><a href=\"#3-1-分文件编写\" class=\"headerlink\" title=\"3.1 分文件编写\"></a>3.1 分文件编写</h6><p><code>.h</code>中写类的成员函数的申明（一般要添加标准的输入输出流和命名空间std）</p>\n<p><code>.cpp</code>中写成员函数的实现，其中该成员函数要以<code>作用域::成员函数的形式</code></p>\n<p>可以用<code>#pragme once</code>避免头文件被重复包含</p>\n<h6 id=\"3-2-对象的构造-初始化-与析构-清理\"><a href=\"#3-2-对象的构造-初始化-与析构-清理\" class=\"headerlink\" title=\"3.2 对象的构造(初始化)与析构 (清理)\"></a>3.2 对象的构造(初始化)与析构 (清理)</h6><p>1、对象的初始化与清理</p>\n<pre><code class=\"cpp\">当定义了一个类后\nPerson p1;  \n程序员若没有提供构造函数和析构函数\n编译器就默认调用了构造函数和析构函数，但此时构造函数和析构函数是系统提供的两个空实现的函数\n\n构造函数：\n1.与类名相同,没有返回值，不写void，可以发生重载（即可以有参数，可以有多个构造函数）\n2.构造函数由编译器自动调用，而不是手动，而且只会调用一次\n\n3.\neg:\nPerson()\n&#123;\n    cout &lt;&lt; &quot;构造函数的调用&quot; &lt;&lt; endl;\n&#125;\n\n析构函数：\n1.与类名相同，类名前面加一个符号 &quot;~&quot;，也没有返回值，不写void，不可以有参数（不能发生函数重载）\n2.析构函数由编译器自动调用，而不是手动，而且只会调用一次\n3.构函数调用于主调函数结束之后。所以如果是在main函数中调用，要等函数全部执行完才调用，我们就看不到。\n4.\neg:\n~Person()\n&#123;\n    cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;\n&#125;\n注意：构造和析构必须写在public下\n</code></pre>\n<p>2、构造函数的分类及调用</p>\n<pre><code class=\"cpp\">1.按照参数有无进行分类:\n无参构造函数的写法：\nPerson()  //无参构造函数又叫默认构造函数\n&#123;\n    cout &lt;&lt; &quot;无参构造函数调用&quot; &lt;&lt; endl;\n&#125;\n无参构造函数的调用：\nPerson p1;(注意：不要写成 Person p1(); 编译器会把这个当做是函数声明\n有参构造函数的写法：\nPerson(int a)\n&#123;\n    cout &lt;&lt; &quot;有参构造函数调用&quot; &lt;&lt; endl;\n&#125;\n有参构造函数的调用：\nPerson p2(10);   or   Person p2 = Person(10);\n\n**附加知识点**\nPerson(10)； 匿名对象，执行当前行后就会释放这个对象（注意与上面的区分）\n\n2.按照类型进行分类\n普通构造函数（就是上面的无参和有参）\n拷贝构造函数的写法\nPerson(const Person&amp; p)//因为是“拷贝”，不让修改，所以加const\n&#123;\n    m_Age = p.m_Age;\n    cout &lt;&lt; &quot;拷贝构造函数调用&quot; &lt;&lt; endl;\n&#125;\n拷贝构造函数的调用\nPerson p1(p2);   or   Person p1 = Person(p2);\n\n注意：不能用拷贝构造函数初始化匿名对象（因为拷贝构造函数需要一个对象名来作为参数）\neg：\nPerson(p5);  //如果这么写，编译器会认为你写的是 Person p5; 即对象的声明\n</code></pre>\n<blockquote>\n<p>注意：拷贝构造函数并不是把一个对象直接复制给另一个对象，拷贝构造函数仅仅是将一个对象的地址传给另一个对象，至于如何操作，是复制还是什么具体要自己实现</p>\n</blockquote>\n<p>注意：隐式类型转换</p>\n<pre><code class=\"cpp\">Person p7 = 100;  //相当于调用了Person p7 = Person(100);  隐式类型转换\nPerson p8 = p7;  //相当于调用了Person p8 = Person(p7);  隐式类型转换\n</code></pre>\n<p>3、拷贝构造函数调用时机</p>\n<p>（1）用已经创建好的对象来初始化新的对象</p>\n<pre><code class=\"cpp\">void test01()\n&#123;\n    Person p1;\n    p1.m_Age = 10;\n    Person p2 = Person(p1);\n&#125;\n</code></pre>\n<p>（2）以值传递的方式给函数的参数传值</p>\n<pre><code class=\"cpp\">void doWork(Person p1)  //Person p1 = Person(p);\n&#123;\n\n&#125;\nvoid test02()\n&#123;\n    Person p;\n    p.m_Age = 10;\n    doWork(p);\n&#125;\n</code></pre>\n<p>（3）以值方式返回局部对象</p>\n<pre><code class=\"cpp\">Person doWork2()\n&#123;\n    Person p1;\n    return p1;\n&#125;\nvoid test03()\n&#123;\n    Person p = doWork2();\n&#125;\n</code></pre>\n<p>4、构造函数的调用规则</p>\n<p>默认情况下，c++编译器至少为我们写的类提供三个函数</p>\n<p>1.默认构造函数（无参，函数体为空）</p>\n<p>2.默认析构函数（无参，函数体为空）</p>\n<p>3.默认拷贝构造函数，<strong>对类中非静态成员属性简单值拷贝</strong></p>\n<p>注意：当用户定义了有参的构造，系统就不会提供默认构造函数，但是会提供拷贝构造函数</p>\n<p>注意：当用户定义了拷贝构造，c++就不会提供其它构造函数</p>\n<h6 id=\"3-3-深拷贝和浅拷贝\"><a href=\"#3-3-深拷贝和浅拷贝\" class=\"headerlink\" title=\"3.3 深拷贝和浅拷贝\"></a>3.3 深拷贝和浅拷贝</h6><p>由于&amp;的特性，浅拷贝即通常的拷贝构造函数的拷贝，仅仅是“取别名”，本质上是只复制了被拷贝的变量的地址,原对象和浅拷贝对象会共享相同的数据。</p>\n<p>系统默认提供的拷贝构造，会进行简单的值拷贝</p>\n<p>如果属性里有指向堆区空间的数据，那么简单的浅拷贝会导致重复释放内存的异常</p>\n<p>解决上述问题，需要我们自己提供拷贝构造函数，进行深拷贝</p>\n<h6 id=\"3-4-初始化列表\"><a href=\"#3-4-初始化列表\" class=\"headerlink\" title=\"3.4 初始化列表\"></a>3.4 初始化列表</h6><p>利用初始化列表来初始化数据</p>\n<p>在构造函数后面 + ： 属性（值 or 参数），属性（值 or 参数）…</p>\n<p><strong>是值就是赋值给前面的属性，是参数就是传参给前面的属性</strong></p>\n<pre><code class=\"cpp\">//第一种\nPerson() : m_A(10),m_B(20), m_C(30)\n&#123;\n\n&#125;  //相当于m_A = 10;前提是Person类中要有m_A这个成员属性\n//第二种\nPerson(int a, int b, int c) : m_A(a), m_B(b), m_C(c)\n&#123;\n\n&#125;  //相当于m_A = a;前提是Person类中要有m_A这个成员属性\n//想初始化哪个值初始化哪个值，没有说三个数都要写上去\n</code></pre>\n<h6 id=\"3-5-类对象作为类成员\"><a href=\"#3-5-类对象作为类成员\" class=\"headerlink\" title=\"3.5 类对象作为类成员\"></a>3.5 类对象作为类成员</h6><p>&#x3D;&#x3D;当类对象作为类成员时，构造顺序是先构造类对象的构造，然后构造自己&#x3D;&#x3D;</p>\n<blockquote>\n<p>这是为了确保成员函数在使用前已经被正确初始化</p>\n</blockquote>\n<p>&#x3D;&#x3D;析构顺序与构造相反&#x3D;&#x3D;</p>\n<blockquote>\n<p>这是为了确保在对象的析构函数执行时，成员对象仍然是有效的。</p>\n<p>这样可以保证在成员对象的析构函数中，可以正确地处理和释放它们所占用的资源。</p>\n</blockquote>\n<h6 id=\"专题：explicit-显式\"><a href=\"#专题：explicit-显式\" class=\"headerlink\" title=\"专题：explicit(显式)\"></a>专题：explicit(显式)</h6><p>explicit关键字，放在函数名前，防止隐式类型转换</p>\n<pre><code class=\"cpp\">eg：explicit MyString(int a)\n&#123;\n    mSize = a;\n&#125;\n</code></pre>\n<h6 id=\"3-6-new关键字\"><a href=\"#3-6-new关键字\" class=\"headerlink\" title=\"3.6 new关键字\"></a>3.6 new关键字</h6><pre><code class=\"cpp\">//用于在动态存储区（堆）上分配内存，创建动态对象，并返回指向该对象的指针。\n//用于创建对象、动态数组或分配其他类型的动态内存\nvoid test02()\n&#123;\n    //开辟到堆区\n    Person* p1 = new Person;\n    Person* p2 = new Person(10);\n    Person* p3 = new Person(*p2);\n    //释放new出来的对象\n    delete p1;\n    delete p2;\n    delete p3;\n&#125;\n//1.malloc与new的区别\n//malloc是一个库函数，new是一个运算符\n//malloc返回值是void*，new返回值是new出来的对象的指针\n//malloc要看是否开辟成功，而new内部做好了该操作（内部会malloc数据在堆区，判断内存是否分配成功，调用构造函数）\n//malloc不会调用构造函数，new会调用构造函数\n//malloc对应的释放是free，new对应的释放是delete\n//2.注意事项\n//不要用void*万能指针去接受new出来的对象，原因是不能释放\n//3.利用new创建数组\n// int* pInt = new int[10];//调用10次默认构造函数\n// 在堆区创建数组时，类中必须要存在默认构造函数，否则无法创建\n// Person* persons = new Person[10];\n// 如果是数组，释放的时候要在delete后加[]\n// delete [] persons;\n// 如果数组是在栈上开辟，那么可以指定利用哪个构造函数来初始化对象\n// Person Persons2[3] = &#123; person(10),person(10),person(10) &#125;;\n</code></pre>\n<h6 id=\"3-7-静态成员变量\"><a href=\"#3-7-静态成员变量\" class=\"headerlink\" title=\"3.7 静态成员变量\"></a>3.7 静态成员变量</h6><p>在一个类中，若将一个成员变量声明为static，这种成员称为静态变量成员，与一般的数据成员不同，<u>无论建立了多少对象，所有对象共享这个静态成员变量</u>；静态成员变量，属于某个类，所有对象共享</p>\n<blockquote>\n<p>静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间，所以比main函数还先调用</p>\n</blockquote>\n<p><strong>1.静态成员变量必须在类中声明，在类外定义</strong>（主要是为了避免多次定义静态成员变量）</p>\n<pre><code class=\"cpp\">原因：调用静态成员变量有两种方式：\n分别是用类名\neg: Person::m_Age;\n和对象名\neg: P1.m_Age;\n若静态成员变量在类内定义，若定义在构造函数中，\n用对象名的方式，显然能调用构造函数\n但用类名的方式，则不会调用构造函数，此时，静态成员变量就没有初始化\n</code></pre>\n<p>静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间</p>\n<p><strong>注意：静态成员变量也是有权限的</strong></p>\n<pre><code class=\"cpp\">private:\n    static int m_other; //私有权限 在类外不能访问\n&#125;;\n//但是：\nint Person::m_other = 10; //类外初始化却是可以的，因为编译器会算作你这一条语句写在了Person类里面\n</code></pre>\n<p><strong>2.静态数据成员可以通过类名或者对象名来引用</strong></p>\n<p><strong>3.静态成员变量，属于某个类的所有对象共享</strong></p>\n<h6 id=\"3-8-静态成员函数\"><a href=\"#3-8-静态成员函数\" class=\"headerlink\" title=\"3.8 静态成员函数\"></a>3.8 静态成员函数</h6><p>基本和静态成员变量一样</p>\n<p><strong>但是：静态成员函数不可以访问普通的成员变量</strong>（因为没有编译器没有自动添加this指针）</p>\n<pre><code class=\"cpp\">原因：\n静态成员函数由类的所有对象共享。\n当静态成员函数访问了普通的成员变量时，\n每一个对象都有该普通成员变量，并且他们的值不一定相等\n静态成员函数就会分不清要调用哪一个\n</code></pre>\n<p><strong>可以访问静态成员变量，因为静态成员变量也只有一份</strong></p>\n<p><strong>普通成员函数，可以访问普通成员变量，也可以访问静态成员变量</strong></p>\n<h6 id=\"3-9-静态成员实现单例模式\"><a href=\"#3-9-静态成员实现单例模式\" class=\"headerlink\" title=\"3.9 静态成员实现单例模式\"></a>3.9 静态成员实现单例模式</h6><p>单例模式：一个类中只有唯一的一个实例对象。</p>\n<blockquote>\n<p>私有化默认构造函数，拷贝构造函数，唯一主席指针变成只读状态；对外提供公共接口static ChairMan* getInstance();</p>\n</blockquote>\n<pre><code class=\"cpp\">class Printer\n&#123;\nprivate:\n    Printer()\n    &#123;\n        m_Count = 0;\n    &#125;\n    Printer(const Printer&amp; p)\n    &#123;\n\n    &#125;\n    static Printer* printer;\n\npublic:\n    static Printer* getInstance()\n    &#123;\n        return printer;\n    &#125;\n\n    void printText(string text)\n    &#123;\n        cout &lt;&lt; &quot;打印的内容：&quot; &lt;&lt; text &lt;&lt; endl;\n        m_Count++;\n    &#125;\n\n    int m_Count;\n&#125;;\n\nPrinter* Printer::printer = new Printer;\n\nvoid test01()\n&#123;\n    Printer* p1 = Printer::getInstance();\n    p1-&gt;printText(&quot;入职申请&quot;);\n    p1-&gt;printText(&quot;离职报告&quot;);\n\n    cout &lt;&lt; &quot;打印机使用次数&quot; &lt;&lt; p1-&gt;m_Count &lt;&lt; endl;\n\n    Printer* p2 = Printer::getInstance();\n    p2-&gt;printText(&quot;调休申请&quot;);\n\n    cout &lt;&lt; &quot;打印机使用次数&quot; &lt;&lt; p2-&gt;m_Count &lt;&lt; endl;\n&#125;\n</code></pre>\n<h6 id=\"3-10-成员变量与函数的存储\"><a href=\"#3-10-成员变量与函数的存储\" class=\"headerlink\" title=\"3.10 成员变量与函数的存储\"></a>3.10 成员变量与函数的存储</h6><p>C++成员变量与成员函数分开存储</p>\n<p>一个类中，只有非静态成员变量属于类大小</p>\n<p>空类的大小为1个字节</p>\n<p>（每个对象在内存中必须有独一无二的地址，即使是空对象也不例外。为确保空类的每个实例都有唯一的地址，编译器会为空类分配一个字节的内存空间。）</p>\n<p>（这个额外的字节并不存储任何数据，它只是用来区分不同的空类实例。）</p>\n<pre><code class=\"cpp\">class Person\n&#123;\npublic:\n    int m_A;//成员属性 算在类的大小中\n    \n    //成员函数 并不算在类的大小中（成员函数属于这个类的作用域，而不属于某一个具体的对象）\n    void func()\n    &#123;\n\n    &#125;\n\n    static int m_B;//静态成员变量，也不属于某个对象，不算在类的大小（即占几个字节）中\n\n    static void func2()//静态成员函数，也不属于某个对象，不算在类的大小（即占几个字节）中\n    &#123;\n\n    &#125;\n\n    double m_D;//最后结果是16，如果单单考虑数据类型大小应该是12（4+8），原因：考虑内存对齐。\n\n&#125;;\nint Person::m_B = 0;\n\nvoid test01()\n&#123;\n    //空类的大小为1个字节\n    //C++中空类也可以实例化对象，每个对象在内存中都应该有独一无二的地址\n    cout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n&#125;\n</code></pre>\n<h6 id=\"3-11-this指针\"><a href=\"#3-11-this指针\" class=\"headerlink\" title=\"3.11 this指针\"></a>3.11 this指针</h6><p>this指针指向被调用的成员函数所属的对象</p>\n<p>&#x3D;&#x3D;个人理解：this最大的意义可能就在于“属于谁”&#x3D;&#x3D;</p>\n<pre><code class=\"cpp\">//实际上每个成员函数的第一个参数默认都有个指向对象的 this 指针，如：\nvoid Hello() \n&#123; \n    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; \n&#125; //上面的函数实质上是下面这样的：\nvoid Hello(Person* this ) \n&#123; \n    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; \n&#125;//每个成员函数都拥有所属对象的地址作为自己的第一个参数\n</code></pre>\n<p>*this 对象本体</p>\n<pre><code class=\"cpp\">//对于一般对象是：Person p1;  是p1.func();\n//对于指针对象：Person* p1;  则是（*p1）.func();编译器觉得这样太丑了。改为p1-&gt;func();与上面的同等效果\n</code></pre>\n<p>this可以解决名称的冲突</p>\n<pre><code class=\"cpp\">//1.在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。\n//2.this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。\n//3.友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针\n//4.静态成员函数是不能使用 this 指针，因为静态成员函数相当于是共享的变量，不属于某个对象的变量。\nclass Person\n&#123;\npublic:\n    Person(int age)\n    &#123;\n        //this指针指向的是被调用的成员函数所属的对象\n        //*this是这个对象的本体\n        this-&gt;age = age;\n    &#125;\n    void showAge()\n    &#123;\n        cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n    &#125;\n    int age;\n    //Person&amp; 链式调用，该数据类型返回的是它本身，如p1返回p1\n    Person&amp; addAge(Person&amp; p)\n    &#123;\n        this-&gt;age += p.age;\n        return *this;\n    &#125;\n&#125;;\nvoid test01()\n&#123;\n    Person p1(18);\n    cout &lt;&lt; &quot;p1的年龄：&quot; &lt;&lt; p1.age &lt;&lt; endl;\n    p1.showAge();\n    Person p2(10);\n    p1.addAge(p2).addAge(p2).addAge(p2);//链式编程\n    p1.showAge();\n&#125;\n//c++中当定义类对象是指针对象时候，就需要用到-&gt;指向类中的成员；当定义一般对象时候时就需要用到&quot;.&quot;指向类中的成员。\n</code></pre>\n<h6 id=\"3-12-空指针访问成员函数\"><a href=\"#3-12-空指针访问成员函数\" class=\"headerlink\" title=\"3.12 空指针访问成员函数\"></a>3.12 空指针访问成员函数</h6><p>如果是一个空指针</p>\n<p>可以访问没有this的一些成员函数</p>\n<p>如果函数用到了this指针，程序会down掉，如果想让代码严谨，加判断：</p>\n<pre><code class=\"cpp\">class Person\n&#123;\npublic:\n    void showClassName()\n    &#123;\n        cout &lt;&lt; &quot;class Name is Person&quot; &lt;&lt; endl;\n    &#125;\n    void showAge()\n    &#123;\n        //NULL-&gt;m_Age;\n        if (this == NULL)\n        &#123;\n            return;\n        &#125;\n        cout &lt;&lt; &quot;age = &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;\n    &#125;\n    int m_Age = 10;\n&#125;;\nvoid test01()\n&#123;\n    /*Person p1;\n    p1.m_Age = 18;\n    p1.showAge();\n    p1.showClassName();*/\n    Person* p1 = NULL;\n    p1-&gt;showAge();\n    p1-&gt;showClassName();\n&#125;\n</code></pre>\n<h6 id=\"3-13-常函数与常对象\"><a href=\"#3-13-常函数与常对象\" class=\"headerlink\" title=\"3.13 常函数与常对象\"></a>3.13 常函数与常对象</h6><p>this指针本质是 指针常量  Person* const this（指针的指向是不可以修改的，指针指向的值可以改）</p>\n<p>如果想指针指向的值也不能修改 const Person* const this</p>\n<p>需要将成员函数改成常函数，成员函数的后面 加 const</p>\n<p>有些特例的属性，即使是常函数或者说常对象 也是可以修改的，需要将属性加关键字 mulable</p>\n<p>常对象 const Person p;常对象只能调用常函数，不可以调用普通的成员函数</p>\n<pre><code class=\"cpp\">class Person\n&#123;\npublic:\n    //**成员函数** 声明的后面加const代表常函数，不可以修改成员属性了\n    void showPerson() const\n    &#123;\n        //const Person* const this\n        //this指针的本质 是一个指针常量，指针的指向是不可以修改的，指针指向的值可以改\n        cout &lt;&lt; this-&gt;m_A &lt;&lt; endl;\n        //this-&gt;m_A = 100;\n        //this = NULL;\n\n        this-&gt;m_B = 100;\n    &#125;\n    void showPerson2()\n    &#123;\n        cout &lt;&lt; &quot;aaa&quot; &lt;&lt; endl;\n    &#125;\n    int m_A;\n    mutable int m_B;//即使是常函数，m_B我也想可以修改，用mutable关键字\n&#125;;\nvoid test01()\n&#123;\n    Person p1;\n    p1.m_A = 10;\n    p1.showPerson();\n&#125;\n//常对象\nvoid test02()\n&#123;\n    const Person p1;//常对象\n    //常对象也不可以修改内部的属性\n    //p1.m_A = 100;\n    p1.m_B = 100;//m_B是特殊属性，即使是常对象或常函数，都可以改\n\n    p1.showPerson();//常对象 只能调用常函数\n    p1.showPerson2();//常对象 是不能调用普通的成员函数的\n&#125;\n</code></pre>\n<h6 id=\"3-14-全局函数作为友元函数\"><a href=\"#3-14-全局函数作为友元函数\" class=\"headerlink\" title=\"3.14 全局函数作为友元函数\"></a>3.14 全局函数作为友元函数</h6><p>有一个全局函数，作为本类的友元函数，可以访问到私有内容</p>\n<p>类的内部写入：friend + 函数声明</p>\n<pre><code class=\"cpp\">//家建筑\nclass Building\n&#123;\n    //有一个全局函数，作为本类的友元函数，可以访问到私有内容\n    friend void goodGay(Building&amp; building);\npublic:\n    Building()\n    &#123;\n        this-&gt;m_SittingRoom = &quot;客厅&quot;;\n        this-&gt;m_BedRoom = &quot;卧室&quot;;\n    &#125;\npublic:\n    //客厅\n    string m_SittingRoom;\nprivate:\n    //卧室\n    string m_BedRoom;\n&#125;;\n//好基友全局函数\nvoid goodGay(Building &amp; building)\n&#123;\n    cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;\n    cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building.m_BedRoom &lt;&lt; endl;\n&#125;\nvoid test01()\n&#123;\n    Building b;\n    goodGay(b);\n&#125;\n</code></pre>\n<h5 id=\"四、第四天\"><a href=\"#四、第四天\" class=\"headerlink\" title=\"四、第四天\"></a>四、第四天</h5><h6 id=\"4-1-类作为有元类\"><a href=\"#4-1-类作为有元类\" class=\"headerlink\" title=\"4.1 类作为有元类\"></a>4.1 类作为有元类</h6><p>类作为友元类</p>\n<p>告诉编译器 goodGay类是本类的好朋友，可以访问到里面的私有内容</p>\n<p>在类内部写入：friend class goodGay;</p>\n<pre><code class=\"cpp\">class Building;\nclass goodGay\n&#123;\npublic:\n    goodGay();\n    void visit();\nprivate:\n    Building* building;\n&#125;;\nclass Building\n&#123;\n    //告诉编译器 goodGay类是本类的好朋友，可以访问到里面的私有内容\n    friend class goodGay;\npublic:\n    Building()\n    &#123;\n\n    &#125;\npublic:\n    //客厅\n    string m_SittingRoom;\nprivate:\n    //卧室\n    string m_BedRoom;\n&#125;;\n//类外做函数的实现\ngoodGay::goodGay()\n&#123;\n    this-&gt;building = new Building;\n&#125;\nvoid goodGay::visit()\n&#123;\n    cout &lt;&lt; &quot;好基友类 正在访问：&quot; &lt;&lt; this-&gt;building-&gt;m_SittingRoom &lt;&lt; endl;\n    cout &lt;&lt; &quot;好基友类 正在访问：&quot; &lt;&lt; this-&gt;building-&gt;m_BedRoom &lt;&lt; endl;\n&#125;\nBuilding::Building()\n&#123;\n    this-&gt;m_SittingRoom = &quot;客厅&quot;;\n    this-&gt;m_BedRoom = &quot;卧室&quot;;\n&#125;\nvoid test01()\n&#123;\n    //Building building;\n    goodGay gg;\n    gg.visit();\n&#125;\n</code></pre>\n<h6 id=\"4-2-类中成员函数作为友元函数\"><a href=\"#4-2-类中成员函数作为友元函数\" class=\"headerlink\" title=\"4.2 类中成员函数作为友元函数\"></a>4.2 类中成员函数作为友元函数</h6><p>告诉编译器，goodGay类中的visit成员函数，利用访问本类中的私有内容</p>\n<p>friend void goodGay::visit();</p>\n<h6 id=\"4-3-数组类封装\"><a href=\"#4-3-数组类封装\" class=\"headerlink\" title=\"4.3 数组类封装\"></a>4.3 数组类封装</h6><p>（这里只展示MyArray.cpp）</p>\n<pre><code class=\"cpp\">#include &quot;MyArray.h&quot;\n\nMyArray::MyArray()//默认构造函数\n&#123;\n    this-&gt;m_capacity = 100;\n    this-&gt;m_Size = 0;\n    this-&gt;pAddress = new int[this-&gt;m_capacity];\n&#125;\n\nMyArray::MyArray(int capacity)//有参构造函数\n&#123;\n\n    this-&gt;m_capacity = capacity;\n    this-&gt;m_Size = 0;\n    this-&gt;pAddress = new int[this-&gt;m_capacity];\n&#125;\n\nMyArray::MyArray(const MyArray&amp; arr)//拷贝构造函数\n&#123;\n    this-&gt;m_capacity = arr.m_capacity;\n    this-&gt;m_Size = arr.m_Size;\n    this-&gt;pAddress = new int[this-&gt;m_capacity];\n    for (int i = 0; i &lt; this-&gt;m_Size; ++i)\n    &#123;\n        this-&gt;pAddress[i] = arr.pAddress[i];\n    &#125;\n&#125;\n\nvoid MyArray::pushBack(int val)//尾插\n&#123;\n    this-&gt;pAddress[this-&gt;m_Size] = val;\n    this-&gt;m_Size++;\n&#125;\n\nint MyArray::getCapacity()//获取数组容量\n&#123;\n    return this-&gt;m_capacity;\n&#125;\n\nint MyArray::getSize()//获取数组大小\n&#123;\n    return this-&gt;m_Size;\n&#125;\n\nvoid MyArray::setData(int index, int val)//修改数据\n&#123;\n    this-&gt;pAddress[index] = val;\n&#125;\n\nint MyArray::getData(int index)//获取数据\n&#123;\n    return this-&gt;pAddress[index];\n&#125;\n\nMyArray::~MyArray()//析构函数\n&#123;\n    if (this-&gt;pAddress != NULL)\n    &#123;\n        delete[] this-&gt;pAddress;\n        this-&gt;pAddress = NULL;\n    &#125;\n    \n&#125;\n</code></pre>\n<h6 id=\"4-4-加号运算符重载\"><a href=\"#4-4-加号运算符重载\" class=\"headerlink\" title=\"4.4 加号运算符重载\"></a>4.4 加号运算符重载</h6><p>对于内置的数据类型，编译器知道该如何进行运算；但对于自定义的数据类型，编译器不知道如何运算；</p>\n<p>&#x3D;&#x3D;利用运算符重载可以解决这个问题。&#x3D;&#x3D;下面是运用成员函数和全局函数来解决这个问题</p>\n<p>&#x3D;&#x3D;注意：运算符重载也可以发生函数重载&#x3D;&#x3D;</p>\n<pre><code class=\"cpp\">class Person\n&#123;\npublic:\n    Person() &#123;&#125;;\n\n    Person(int a, int b) : m_A(a), m_B(b)\n    &#123;\n\n    &#125;\n\n    ////利用成员函数+号运算符重载\n    //Person operator+(Person&amp; p)\n    //&#123;\n    //\tPerson temp;\n    //\ttemp.m_A = this-&gt;m_A + p.m_A;\n    //\ttemp.m_B = this-&gt;m_B + p.m_B;\n\n    //\treturn temp;//存疑：返回的是拷贝构造\n    //&#125;\n    int m_A;\n    int m_B;\n\n&#125;;\n\n//利用全局函数进行+运算符的重载\nPerson operator+(Person&amp; p1, Person&amp; p2)\n&#123;\n    Person temp;\n    temp.m_A = p1.m_A + p2.m_A;\n    temp.m_B = p1.m_B + p2.m_B;\n\n    return temp;\n&#125;\n//运算符重载的函数重载\nPerson operator+(Person&amp; p1, int a)\n&#123;\n    Person temp;\n    temp.m_A = p1.m_A + a;\n    temp.m_B = p1.m_B + a;\n\n    return temp;\n&#125;\nvoid test01()\n&#123;\n    Person p1(10, 10);\n    Person p2(10, 10);\n\n    Person p3 = p1 + p2;\n    //成员函数的本质：\n    // Person p3 = p1.operator+(p2);\n    //全局函数的本质\n    //Person p3 = operator+(p1,p2);\n    cout &lt;&lt; &quot;p3的m_A:&quot; &lt;&lt; p3.m_A &lt;&lt; endl;\n\n    //运算符重载 可不可以发生函数重载？\n    \n    Person p4 = p1 + 100;\n    cout &lt;&lt; &quot;p4的m_A:&quot; &lt;&lt; p4.m_A &lt;&lt; endl;\n&#125;\n</code></pre>\n<h6 id=\"4-5-左移运算符重载任务布置\"><a href=\"#4-5-左移运算符重载任务布置\" class=\"headerlink\" title=\"4.5 左移运算符重载任务布置\"></a>4.5 左移运算符重载任务布置</h6><p>1.运算符重载知识一种“语法上的方便”，也就是它是另一种函数调用的方式。</p>\n<p>2.对与内置的数据类型的表达式的运算符是不能改变的（如想重载int类型数据的+号）</p>\n<pre><code class=\"cpp\">//该代码用到了运算符重载，链式编程，友元\nclass Person\n&#123;\n    //若Person的属性是私有，可以用友元访问私有属性\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p);\npublic:\n    Person() &#123;&#125;;\n    Person(int a, int b)\n    &#123;\n        this-&gt;m_A = a;\n        this-&gt;m_B = b;\n    &#125;\n    \n    //试图利用成员函数 实现&lt;&lt;运算符重载      这样做不行，这样cout就在&lt;&lt;右边了\n    /*void operator&lt;&lt;(ostream&amp; cout)\n    &#123;\n\n    &#125;*/\nprivate:\n    int m_A;\n    int m_B;\n&#125;;\n\n//试图利用全局函数 实现&lt;&lt;运算符重载\nostream&amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p)//将这的cout改成out，下数第二行的cout不变也能正常运行。原因：&amp;是取别名，原名也能用\n&#123;\n    cout &lt;&lt; &quot;m_A=&quot; &lt;&lt; p.m_A &lt;&lt; &quot; m_B=&quot; &lt;&lt; p.m_B;\n    return cout;\n&#125;\n\nvoid test01()\n&#123;\n    Person p1(10, 10);\n    //cout &lt;&lt; &quot;m_A=&quot; &lt;&lt; p1.m_A &lt;&lt; &quot; m_B=&quot; &lt;&lt; p1.m_B &lt;&lt; endl;\n    cout &lt;&lt; p1 &lt;&lt; endl;//链式编程，cout&lt;&lt;p1后返回值应该要还是cout\n&#125;\n</code></pre>\n<h6 id=\"4-6-递增运算符重载\"><a href=\"#4-6-递增运算符重载\" class=\"headerlink\" title=\"4.6 递增运算符重载\"></a>4.6 递增运算符重载</h6><pre><code class=\"cpp\">class MyInter\n&#123;\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInter&amp; myInt);\n\npublic:\n    MyInter()\n    &#123;\n        this-&gt;m_Num = 0;\n    &#125;\n    //重载前置++\n    MyInter&amp; operator++()//这里为什么要加&amp;,因为加&amp;返回的是本体，不加返回的是编译器复制出来的一个对象\n    &#123;\n        m_Num++;\n\n        return *this;\n    &#125;\n    //重载后置++\n    MyInter&amp; operator++(int)\n    &#123;\n        MyInter temp = *this;\n\n        this-&gt;m_Num++;\n\n        return temp;\n    &#125;\n\nprivate:int m_Num;\n&#125;;\n\n//左移运算符\nostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInter&amp; myInt)\n&#123;\n    cout &lt;&lt; myInt.m_Num;\n    return cout;\n&#125;\n//前置++案例\nvoid test01()\n&#123;\n    MyInter myInt;\n    cout &lt;&lt; ++myInt &lt;&lt; endl;//  1\n    cout &lt;&lt; myInt &lt;&lt; endl;//  1\n    cout &lt;&lt; myInt++ &lt;&lt; endl;//  1\n    cout &lt;&lt; myInt &lt;&lt; endl;//    2\n    cout &lt;&lt; ++myInt &lt;&lt; endl;//  3\n    cout &lt;&lt; myInt &lt;&lt; endl;//   3\n\n&#125;\n</code></pre>\n<h6 id=\"4-7-指针运算符重载-智能指针\"><a href=\"#4-7-指针运算符重载-智能指针\" class=\"headerlink\" title=\"4.7 指针运算符重载-智能指针\"></a>4.7 指针运算符重载-智能指针</h6><p>智能指针的用途：托管堆区创建的对象的释放</p>\n<p>如果想让sp对象当做一个指针去对待，需要重载-&gt;与*</p>\n<pre><code class=\"cpp\">class Person\n&#123;\npublic:\n    Person(int age)\n    &#123;\n        this-&gt;m_Age = age;\n        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n    void showAge()\n    &#123;\n        cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;\n    &#125;\n    ~Person()\n    &#123;\n        cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;\n    &#125;\nprivate:\n    int m_Age;\n&#125;;\n//智能指针，用来托管new出来的对象的释放\nclass SmartPointer\n&#123;\npublic:\n    SmartPointer(Person* person)\n    &#123;\n        cout &lt;&lt; &quot;SmartPointer构造函数调用&quot; &lt;&lt; endl;\n        this-&gt;person = person;\n    &#125;\n    //重载指针运算符\n    Person* operator-&gt;()\n    &#123;\n        return this-&gt;person;\n    &#125;\n    //重载*(解引用)运算符\n    Person&amp; operator*()\n    &#123;\n        return *this-&gt;person;\n    &#125;\n    ~SmartPointer()\n    &#123;\n        cout &lt;&lt; &quot;SmartPointer析构函数调用&quot; &lt;&lt; endl;\n        if (this-&gt;person != NULL)\n        &#123;\n            delete this-&gt;person;\n            this-&gt;person = NULL;\n        &#125;\n    &#125;\nprivate:\n    Person* person;\n&#125;;\nvoid test01()\n&#123;\n    //Person* p = new Person(18);\n    //p-&gt;showAge();\n    //(*p).showage();\n    //delete p;\n    SmartPointer sp = SmartPointer(new Person(18));\n    //sp-&gt;showAge();//sp-&gt;-&gt;showAge();编译器简化为sp-&gt;showAge();\n    sp-&gt;showAge();\n    (*sp).showAge();\n&#125;\n</code></pre>\n<h6 id=\"4-8-赋值运算符重载\"><a href=\"#4-8-赋值运算符重载\" class=\"headerlink\" title=\"4.8 赋值运算符重载\"></a>4.8 赋值运算符重载</h6><p>系统会默认给一个类添加4个函数：默认构造，拷贝构造，析构，operator&#x3D;</p>\n<blockquote>\n<p>由于系统提供的operator&#x3D;会进行简单的值拷贝，导致如果属性中有堆区的数据，会进行重复释放（当一个类中包含指针成员变量指向堆区内存时，在进行浅拷贝时，两个对象的指针成员变量会指向同一块内存。这会导致问题，当其中一个对象的析构函数调用 <code>delete</code> 释放堆区内存时，另一个对象仍然持有指向已释放内存的指针，导致悬空指针的问题。）</p>\n</blockquote>\n<p>解决方案，需要重载operator&#x3D;，对于a&#x3D;b&#x3D;c的问题，要注意返回值是Person&amp;。</p>\n<pre><code class=\"cpp\">class Person\n&#123;\npublic:\n    Person(const char* name, int age)\n    &#123;\n        this-&gt;m_Name = new char[strlen(name) + 1];\n        strcpy(this-&gt;m_Name, name);\n\n        this-&gt;m_Age = age;\n    &#125;\n    //系统会默认给一个类，创建至少三个函数，默认构造，析构，拷贝构造（简单值拷贝），operator=（值拷贝）\n\n    Person&amp; operator=(const Person&amp; p)\n    &#123;\n        //先判断原来堆区是否有数据，如果有先释放\n        if (this-&gt;m_Name != NULL)\n        &#123;\n            delete [] this-&gt;m_Name;\n            this-&gt;m_Name = NULL;\n            this-&gt;m_Name = new char[strlen(p.m_Name) + 1];\n            strcpy(this-&gt;m_Name, p.m_Name);\n        &#125;\n        //this-&gt;m_Name = p.m_Name;\n        this-&gt;m_Age = p.m_Age;\n\n        return *this;\n    &#125;\n    Person(const Person&amp; p)\n    &#123;\n        this-&gt;m_Name = new char[strlen(p.m_Name) + 1];\n        strcpy(this-&gt;m_Name, p.m_Name);\n        this-&gt;m_Age = p.m_Age;\n    &#125;\n\n    ~Person()\n    &#123;\n        if (this-&gt;m_Name != NULL)\n        &#123;\n            delete[] this-&gt;m_Name;\n            this-&gt;m_Name = NULL;\n        &#125;\n    &#125;\n    char* m_Name;\n    int m_Age;\n&#125;;\n\nvoid test01()\n&#123;\n    Person p1(&quot;tom&quot;, 18);\n    Person p2(&quot;Jerry&quot;, 19);\n\n    p1 = p2;\n\n    cout &lt;&lt; &quot;p1 姓名：&quot; &lt;&lt; p1.m_Name &lt;&lt; &quot; 年龄&quot; &lt;&lt; p1.m_Age &lt;&lt; endl;\n    cout &lt;&lt; &quot;p2 姓名：&quot; &lt;&lt; p2.m_Name &lt;&lt; &quot; 年龄&quot; &lt;&lt; p1.m_Age &lt;&lt; endl;\n\n    Person p3(&quot;&quot;, 0);\n    p3 = p1 = p2;\n\n    cout &lt;&lt; &quot;p3 姓名：&quot; &lt;&lt; p3.m_Name &lt;&lt; &quot; 年龄&quot; &lt;&lt; p1.m_Age &lt;&lt; endl;\n\n    Person p4 = Person(p3);\n\n    cout &lt;&lt; &quot;p4 姓名：&quot; &lt;&lt; p4.m_Name &lt;&lt; &quot; 年龄&quot; &lt;&lt; p1.m_Age &lt;&lt; endl;\n&#125;\n</code></pre>\n<h5 id=\"五、第五天\"><a href=\"#五、第五天\" class=\"headerlink\" title=\"五、第五天\"></a>五、第五天</h5><h6 id=\"5-1-关系运算符重载\"><a href=\"#5-1-关系运算符重载\" class=\"headerlink\" title=\"5.1 关系运算符重载\"></a>5.1 关系运算符重载</h6><pre><code class=\"cpp\">class Person\n&#123;\npublic:\n    Person(string name,int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n\n    bool operator==(const Person&amp; p)\n    &#123;\n        /*if (this-&gt;m_Age == p.m_Age &amp;&amp; this-&gt;m_Name == p.m_Name)\n        &#123;\n            return true;\n        &#125;\n        return false;*/\n\n        return this-&gt;m_Age == p.m_Age &amp;&amp; this-&gt;m_Name == p.m_Name;\n    &#125;\n\n    string m_Name;\n    int m_Age;\n&#125;;\n\nvoid test01()\n&#123;\n    Person p1(&quot;Tom&quot;, 10);\n    Person p2(&quot;Tom&quot;, 10);\n\n    if (p1 == p2)\n    &#123;\n        cout &lt;&lt; &quot;p1等于p2&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;p1不等于p2&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"5-2-函数调用运算符重载\"><a href=\"#5-2-函数调用运算符重载\" class=\"headerlink\" title=\"5.2 函数调用运算符重载\"></a>5.2 函数调用运算符重载</h6><p>实现了两个()运算符重载</p>\n<pre><code class=\"cpp\">class MyFunc\n&#123;\npublic:\n    void operator()(string text)\n    &#123;\n        cout &lt;&lt; text &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    MyFunc func;//仿函数，看起来像函数，但实际上是一个对象（不是仿函数定义，只是一个形象化描述）\n    func(&quot;hello world&quot;);\n&#125;\n\nclass MyAdd\n&#123;\npublic:\n    int operator()(int a, int b)\n    &#123;\n        return a + b;\n    &#125;\n&#125;;\n\nvoid test02()\n&#123;\n    MyAdd myAdd;\n    cout &lt;&lt; myAdd(1, 1) &lt;&lt; endl;\n\n    // MyAdd()(10,10) 匿名函数对象\n    cout &lt;&lt; MyAdd()(10,10) &lt;&lt; endl;\n&#125;\n</code></pre>\n<h6 id=\"5-3-不要重载逻辑与和逻辑或符号\"><a href=\"#5-3-不要重载逻辑与和逻辑或符号\" class=\"headerlink\" title=\"5.3 不要重载逻辑与和逻辑或符号\"></a>5.3 不要重载逻辑与和逻辑或符号</h6><p>内置版本的&amp;&amp;和||首先计算左边的表达式，如果这完全能决定结果，就无需计算右边的表达式了。而我们若重载&amp;&amp;和||，那么就无此特性了</p>\n<p>&#x3D;&#x3D;我们说的运算符重载只是另一种形式的函数调用而已，对于函数调用总是在函数执行之前对所有参数进行求值。&#x3D;&#x3D;</p>\n<p>例如：</p>\n<pre><code class=\"cpp\">if(complex1 &amp;&amp; (complex1 += complex2))&#123;\n    cout &lt;&lt; &quot;真！&quot; &lt;&lt; endl;\n&#125;\nelse&#123;\n    cout &lt;&lt; &quot;假！&quot; &lt;&lt; endl;\n&#125;\n</code></pre>\n<h6 id=\"5-4-重载总结\"><a href=\"#5-4-重载总结\" class=\"headerlink\" title=\"5.4 重载总结\"></a>5.4 重载总结</h6><blockquote>\n<p>&#x3D;, [], (), -&gt; 操作符只能通过成员函数进行重载；（不然容易出现二义性）</p>\n<p>&lt;&lt; 和 &gt;&gt; 只能通过全局函数配合有元函数进行重载；（比如让cout写左边，就要用全局函数）</p>\n<p>不要重载 &amp;&amp; 和 || 操作符；（因为无法实现短路规则）</p>\n</blockquote>\n<p>常规建议：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>建议使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>所有的一元运算符</td>\n<td>成员</td>\n</tr>\n<tr>\n<td>&#x3D; () [] -&gt; -&gt;**</td>\n<td>必须是成员</td>\n</tr>\n<tr>\n<td>+&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; *&#x3D; ^&#x3D;等</td>\n<td>成员</td>\n</tr>\n<tr>\n<td>其它二元运算符</td>\n<td>非成员</td>\n</tr>\n</tbody></table>\n<h6 id=\"5-5-字符串类封装\"><a href=\"#5-5-字符串类封装\" class=\"headerlink\" title=\"5.5 字符串类封装\"></a>5.5 字符串类封装</h6><pre><code class=\"cpp\">//MyString.h\nclass MyString\n&#123;\n    //左移运算符配合友元\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyString&amp; str);\n    //左移运算符配合友元\n    friend istream&amp; operator&gt;&gt;(istream&amp; cin, MyString&amp; str);\npublic:\n    //有参构造函数\n    MyString(const char* str);\n    //拷贝构造函数\n    MyString(const MyString&amp; str);\n    //用户使用方式 MyString str = &quot;aaa&quot;;  MyString str2 = str;\n    //重载[]运算符\n    char&amp; operator[](int index);\n    //重载=运算符\n    MyString&amp; operator=(const char* str);\n    MyString&amp; operator=(MyString&amp; str);\n    //重载+运算符，实现字符串的拼接\n    MyString operator+(const char* str);\n    MyString operator+(MyString&amp; str);\n    //重载==号运算符\n    bool operator==(const char* str);\n    bool operator==(MyString&amp; str);\n    //析构函数\n    ~MyString();\n\nprivate:\n    //指向堆区的字符串的指针\n    char* pString;\n\n    //字符串长度\n    int m_Size;\n&#125;;\n</code></pre>\n<pre><code class=\"cpp\">//MyString.cpp\n#include &quot;MyString.h&quot;\n//重载&lt;&lt;运算符\nostream&amp; operator&lt;&lt;(ostream&amp; cout, MyString&amp; str)\n&#123;\n    cout &lt;&lt; str.pString &lt;&lt; endl;\n\n    return cout;\n&#125;\n//重载&gt;&gt;运算符\nistream&amp; operator&gt;&gt;(istream&amp; cin, MyString&amp; str)\n&#123;\n    //先判断str中是否有数据，如果有 先进行释放\n    if (str.pString != NULL)\n    &#123;\n        delete[] str.pString;\n        str.pString = NULL;\n    &#125;\n\n    char buf[1024];//缓冲区\n\n    cin &gt;&gt; buf;//将用户输入的数据存放在buf中\n    //我要将buf中的数据放入到我内部维护的pString中\n    str.pString = new char[strlen(buf) + 1];\n    strcpy(str.pString, buf);\n    str.m_Size = strlen(buf);\n\n    return cin;\n&#125;\nMyString::MyString(const char* str)\n&#123;\n    this-&gt;pString = new char[strlen(str) + 1];//要加1的原因是strlen不统计&#39;\\0&#39;\n    //strlen接受一个指向以 null 终止的字符串的指针作为参数，\n    //并返回字符串的长度，即不包括 null 终止符的字符数。\n    strcpy(this-&gt;pString, str);//strcpy是C语言标准库，会复制&#39;\\0&#39;\n\n    this-&gt;m_Size = strlen(str);\n&#125;\n\nMyString::MyString(const MyString&amp; str)\n&#123;\n    /*this-&gt;pString = new char[str.m_Size];\n    strcpy(this-&gt;pString, str.pString);\n\n    this-&gt;m_Size = str.m_Size;*/\n    this-&gt;pString = new char[strlen(str.pString) + 1];\n    strcpy(this-&gt;pString, str.pString);\n\n    this-&gt;m_Size = strlen(str.pString);\n&#125;\n\nchar&amp; MyString::operator[](int index)\n&#123;\n    return this-&gt;pString[index];\n&#125;\n\nMyString&amp; MyString::operator=(const char* str)\n&#123;\n    //先判断原来是否有数据，如果有先释放\n    if (this-&gt;pString != NULL)\n    &#123;\n        delete[] this-&gt;pString;\n        this-&gt;pString = NULL;\n    &#125;\n    this-&gt;pString = new char[strlen(str) + 1];\n    strcpy(this-&gt;pString, str);\n    this-&gt;m_Size = strlen(str);\n\n    return *this;\n&#125;\n\nMyString&amp; MyString::operator=(MyString&amp; str)\n&#123;\n    //先判断原来是否有数据，如果有先释放\n    if (this-&gt;pString != NULL)\n    &#123;\n        delete[] this-&gt;pString;\n        this-&gt;pString = NULL;\n    &#125;\n    this-&gt;pString = new char[strlen(str.pString) + 1];\n    strcpy(this-&gt;pString, str.pString);\n    this-&gt;m_Size = strlen(str.pString);\n\n    return *this;\n&#125;\n\nMyString MyString::operator+(const char* str)\n&#123;\n    int newSize = this-&gt;m_Size + strlen(str) + 1;\n    char* temp = new char[newSize];\n\n    //将abc和def放到temp空间下\n    memset(temp, 0, newSize);//三个参数，指向内存块的指针，值，字节数\n    strcat(temp, this-&gt;pString);//字符串追加，两个参数目标字符串，源字符串\n    strcat(temp, str);\n    MyString newString(temp);\n    delete[] temp;\n    return newString;\n&#125;\n\nMyString MyString::operator+(MyString&amp; str)\n&#123;\n    int newSize = this-&gt;m_Size + strlen(str.pString) + 1;\n    char* temp = new char[newSize];\n\n    //将abc和def放到temp空间下\n    memset(temp, 0, newSize);//三个参数，指向内存块的指针，值，字节数\n    strcat(temp, this-&gt;pString);//字符串追加，两个参数目标字符串，源字符串\n    strcat(temp, str.pString);\n    MyString newString(temp);\n    delete[] temp;\n    return newString;\n&#125;\n\nbool MyString::operator==(const char* str)\n&#123;\n    //strcmp 函数会按照字典顺序比较两个字符串，并返回一个整数值来表示比较结果：\n    //如果 str1 等于 str2，则返回值为 0。\n    //如果 str1 小于 str2，则返回值为负数。\n    //如果 str1 大于 str2，则返回值为正数。\n    if (strcmp(this-&gt;pString, str) == 0)\n    &#123;\n        return true;\n    &#125;\n    return false;\n&#125;\n\nbool MyString::operator==(MyString&amp; str)\n&#123;\n    if (strcmp(this-&gt;pString, str.pString) == 0)\n    &#123;\n        return true;\n    &#125;\n    return false;\n&#125;\n\nMyString::~MyString()\n&#123;\n    if (this-&gt;pString != NULL)\n    &#123;\n        delete[] this-&gt;pString;\n        this-&gt;pString = NULL;\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"5-6-继承的基本语法\"><a href=\"#5-6-继承的基本语法\" class=\"headerlink\" title=\"5.6 继承的基本语法\"></a>5.6 继承的基本语法</h6><p>语法为 class 子类 : 继承方式 父类</p>\n<p>BasePage 基类（父类）  GamePage 派生类（子类）</p>\n<p>继承好处：可以减少重复代码的出现</p>\n<pre><code class=\"cpp\">//利用继承可以减少重复代码的出现\n//BasePage 基类（父类）  GamePage 派生类（子类）\n//语法为 class 子类 : 继承方式 父类\nclass BasePage\n&#123;\npublic:\n    void header()\n    &#123;\n        cout &lt;&lt; &quot;公共头部&quot; &lt;&lt; endl;\n    &#125;\n    void footer()\n    &#123;\n        cout &lt;&lt; &quot;公共底部&quot; &lt;&lt; endl;\n    &#125;\n    void leftList()\n    &#123;\n        cout &lt;&lt; &quot;公共的左侧列表&quot; &lt;&lt; endl;\n    &#125;\n\n&#125;;\nclass GamePage : public BasePage\n&#123;\n    void content()\n    &#123;\n        cout &lt;&lt; &quot;LOL赛事直播&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\nclass NewsPage : public BasePage\n&#123;\n    void content()\n    &#123;\n        cout &lt;&lt; &quot;两会召开&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n</code></pre>\n<h6 id=\"5-7-继承方式\"><a href=\"#5-7-继承方式\" class=\"headerlink\" title=\"5.7 继承方式\"></a>5.7 继承方式</h6><p><img src=\"https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306010942357.png\" alt=\"image-20230601094233412\"></p>\n<h6 id=\"5-8-继承中的对象模型\"><a href=\"#5-8-继承中的对象模型\" class=\"headerlink\" title=\"5.8 继承中的对象模型\"></a>5.8 继承中的对象模型</h6><p>父类中私有的属性，子类继承了，但是编译器给隐藏了，因此访问不到</p>\n<pre><code class=\"cpp\">class Base\n&#123;\npublic:\n    int m_A;\nprotected:\n    int m_B;\nprivate:\n    int m_C;\n&#125;;\nclass Son : public Base\n&#123;\npublic:\n    //父类中私有的属性，子类继承了，但是编译器给隐藏了，因此访问不到\n    int m_D;\n&#125;;\n\nvoid test01()\n&#123;\n    cout &lt;&lt; sizeof(Son) &lt;&lt; endl;\n&#125;\n</code></pre>\n<h6 id=\"5-9-继承中的构造与析构\"><a href=\"#5-9-继承中的构造与析构\" class=\"headerlink\" title=\"5.9 继承中的构造与析构\"></a>5.9 继承中的构造与析构</h6><p>&#x3D;&#x3D;在创建子类实例时，子类首先会调用父类的构造函数，以初始化从父类继承的成员。&#x3D;&#x3D;</p>\n<pre><code class=\"cpp\">//如果不调用基类的构造函数，可能出现以下后果\nclass Base &#123;\npublic:\n    int value;\n    Base() &#123;\n        value = 10;\n    &#125;\n&#125;;\n\nclass Derived : public Base &#123;\npublic:\n    Derived() &#123;\n        // 没有调用基类的构造函数\n    &#125;\n&#125;;\n\nint main() &#123;\n    Derived d;\n    cout &lt;&lt; d.value &lt;&lt; endl; // 基类成员value的值是未定义的，输出结果不确定\n    return 0;\n&#125;\n</code></pre>\n<p>（而在子类的析构时，会先调用子类的析构函数，再调用父类的析构函数。只是因为在继承关系中，子类继承了父类的成员，当子类对象被销毁时，需要先清理子类自身的资源，然后再清理父类的资源。）</p>\n<p>&#x3D;&#x3D;可以使用初始化列表语法，显式指出调用父类的哪个构造函数&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;子类不会继承，父类的构造和析构函数&#x3D;&#x3D;</p>\n<pre><code class=\"cpp\">class Base2\n&#123;\npublic:\n    Base2(int a)\n    &#123;\n        this-&gt;m_A = a;\n    &#125;\n    int m_A;\n&#125;;\n//: 代表继承\nclass Son2 : public Base2\n&#123;\npublic:\n    //: 代表初始化列表\n    //可以使用初始化列表语法 显示指出调用父类的哪个构造函数\n    Son2(int a=1000):Base2(a)\n    &#123;       \n    &#125;\n    int m_B;\n&#125;;\n\nvoid test02()\n&#123;\n    Son2 s();\n&#125;\n//子类不会继承 父类的构造和析构函数。因为只有父类自己才知道如何构造和析构自己的属性\n</code></pre>\n<h6 id=\"5-10-继承中的同名成员处理\"><a href=\"#5-10-继承中的同名成员处理\" class=\"headerlink\" title=\"5.10 继承中的同名成员处理\"></a>5.10 继承中的同名成员处理</h6><p><strong>为什么允许派生类定义同名成员？</strong></p>\n<p><strong>答：这是允许派生类根据自身的需求对继承的成员进行定制化的实现。</strong></p>\n<p>（1.通过重写基类成员，派生类可以提供更具体、更适合自身的实现逻辑。2.派生类可以在基类成员的基础上添加额外的功能。3.实现多态性）</p>\n<p>&#x3D;&#x3D;如果子类和父类拥有同名成员，优先调用子类的成员，不过可以通过作用域调用父类的成员。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;同名的成员函数，子类会隐藏掉父类中的所有版本（因为是隐藏，所有还是能通过作用域调用的）&#x3D;&#x3D;</p>\n<h6 id=\"5-11-继承中的同名静态成员处理\"><a href=\"#5-11-继承中的同名静态成员处理\" class=\"headerlink\" title=\"5.11 继承中的同名静态成员处理\"></a>5.11 继承中的同名静态成员处理</h6><p>其它跟上面是一样的，只不过静态成员的访问方式有两种，一种是通过对象来访问，一种是通过类名来访问</p>\n<pre><code class=\"cpp\">class Base\n&#123;\npublic:\n    static int m_A;//共享数据，编译阶段分配内存，类内声明，类外初始化\n\n    static void func()\n    &#123;\n        cout &lt;&lt; &quot;Base中的func调用&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\nint Base::m_A = 10;\n\nclass Son :public Base\n&#123;\npublic:\n    static int m_A;\n\n    static void func()\n    &#123;\n        cout &lt;&lt; &quot;Son中的func调用&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\nint Son::m_A = 20;\n\nvoid test01()\n&#123;\n    //对m_A进行访问\n    Son s;\n    cout &lt;&lt; s.Base::m_A &lt;&lt; endl;\n    cout &lt;&lt; s.m_A &lt;&lt; endl;\n\n    //通过类名进行访问\n    cout &lt;&lt; &quot;通过类名进行访问son中的m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\n    cout &lt;&lt; &quot;通过类名进行访问Base中的m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;\n\n    //同名成员函数 进行调用\n    s.func();\n    Son::func();\n\n    s.Base::func();\n    Son::Base::func();\n&#125;\n</code></pre>\n<h6 id=\"5-12-多继承的语法\"><a href=\"#5-12-多继承的语法\" class=\"headerlink\" title=\"5.12 多继承的语法\"></a>5.12 多继承的语法</h6><p>class 子类 : 继承方式 父类, 继承方式 父类  </p>\n<p>如：<code>class Son : public Base1, public Base2</code></p>\n<p>当两个父类有同名的成员，被子类继承后，调用时需加作用域进行区分</p>\n<h6 id=\"扩展：基类子对象\"><a href=\"#扩展：基类子对象\" class=\"headerlink\" title=\"扩展：基类子对象\"></a>扩展：基类子对象</h6><p>所谓派生，就是对基类做某种拓展。所以派生类对象内部，一定有一份基类对象存在。</p>\n<p>派生类对象内部的这份基类对象，本质上是派生类的一个成员，称为基类子对象。直接存放在派生类对象内部。因为不是独立对象，所以称为子对象</p>\n<h6 id=\"5-13-菱形继承问题以及解决\"><a href=\"#5-13-菱形继承问题以及解决\" class=\"headerlink\" title=\"5.13 菱形继承问题以及解决\"></a>5.13 菱形继承问题以及解决</h6><p>两个派生类继承同一个基类，而又有某个类同时继承两个派生类，这种继承被称为菱形继承。</p>\n<pre><code class=\"cpp\">//比如以下结构\nclass  B\n&#123;\n  protected:  int a;\n  public: B( )&#123; ...&#125; \n&#125;;\nclass B1: public  B\n&#123;\n  public: base1( )&#123;...&#125; \n&#125;;\nclass B2: public  B\n&#123;\n  public: B2( )&#123;...&#125; \n&#125;; \nclass D:public B1,public B2\n&#123;...&#125;\n</code></pre>\n<img src=\"https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306021105407.png\" alt=\"image-20230602110548973\" style=\"zoom: 67%;\" />\n\n<pre><code class=\"cpp\">//以下程序会报错，因为a具有二义性。\nclass B &#123;\n  protected:\n   int a;\n  public:\n   B( )&#123; a=5; cout&lt;&lt;&quot;B a=&quot;&lt;&lt;a&lt;&lt;endl;&#125;  &#125;;\nclass B1:public B&#123;\n   public:\n    B1( )&#123; a=a+10; cout&lt;&lt;&quot;B1 a=&quot;&lt;&lt;a&lt;&lt;endl;&#125; &#125;;\nclass B2:public B&#123;\n  public:\n    B2( )&#123; a=a+20; cout&lt;&lt;&quot;B2 a=&quot;&lt;&lt;a&lt;&lt;endl;&#125; &#125;;\nclass D:public B1,public B2&#123;\n  public:\n    D( )&#123; cout&lt;&lt;&quot;D a=&quot;&lt;&lt; a&lt;&lt;endl;&#125; &#125;;\n    //将D的构造函数改成如下结构能够通过运行\n    // D( )&#123; cout&lt;&lt;&quot;B1 a=&quot;&lt;&lt;B1:: a&lt;&lt;endl;  cout&lt;&lt;&quot;B2 a=&quot;&lt;&lt; B2::a&lt;&lt;endl;&#125;  &#125;;\nint main( )\n&#123; D  obj; return  0;  &#125;\n//结果：\n//B a=5\n//B1 a=15\n//B a=5\n//B2 a=25\n//B1 a=15\n//B2 a=25\n\n//能够看到a被初始化了两次，我们希望a只被再第一次初始化以后就不再继续初始化了。那么我们要使用虚基类。\n</code></pre>\n<p>如果将公共基类说明为虚基类。那么，对同一个虚基类的构造函数只调用一次，这样从不同的路径继承的虚基类的成员在内存中就只拥有一个拷贝。从而解决了以上的二义性问题。</p>\n<pre><code class=\"cpp\"> class  派生类名:继承方式 virtual 基类名\n &#123;   … &#125;\n 或\n class  派生类名: virtual 继承方式 基类名\n &#123;  … &#125;\n</code></pre>\n<p>我们将上面的继承结构改成如下所示</p>\n<pre><code class=\"cpp\">class B&#123;\n  protected:  int a;\n  public: B( )&#123; ...&#125; &#125;;\nclass B1: public virtual B&#123;\n  public: B1( )&#123;...&#125; &#125;;\nclass B2: public virtual B&#123;\n  public: B2( )&#123;...&#125; &#125;; \nclass D:public B1,public B2&#123; . . .&#125;\n</code></pre>\n<img src=\"https://pd0820.oss-cn-shenzhen.aliyuncs.com/typora/202306021115489.png\" alt=\"image-20230602111536411\" style=\"zoom: 67%;\" />\n\n<pre><code class=\"cpp\">//改成虚基类后，D obj;的结果为：\n//B a=5\n//B1 a=15\n//B2 a=35\n//D a=35\n//可以看到a只被初始化了一次。\n</code></pre>\n<p>注意：如果在虚基类中定义有带形参的构造函数,并且没有定义默认形式的构造函数,则整个继承结构中,所有直接或间接的派生类都必须在构造函数的成员初始化表中列出对虚基类构造函数的调用,以初始化在虚基类中定义的数据成员。</p>\n<pre><code class=\"cpp\">class B &#123;  int a;\n  public:\n   B(int sa)\n  &#123; a=sa;  cout&lt;&lt;&quot;Constructing B&quot;&lt;&lt;endl; &#125; &#125;;\nclass B1:virtual public B&#123;  int b;\n  public:\n   B1(int sa,int sb):B(sa)\n   &#123; b=sb; cout&lt;&lt;&quot;Constructing B1&quot;&lt;&lt;endl; &#125; &#125;;\nclass B2:virtual public B&#123;  int c;\n  public:\n   B2(int sa,int sc):B(sa)\n  &#123; c=sc; cout&lt;&lt;&quot;Constructing B2&quot;&lt;&lt;endl; &#125; &#125;;\nclass D:public B1,public B2 &#123;\n   int d;\n  public:\n   D(int sa,int sb,int sc,int sd): B(sa),B1(sa,sb),B2(sa,sc)\n   &#123; d=sd; cout&lt;&lt;&quot;Constructing D&quot;&lt;&lt;endl;&#125; &#125;;\n int main()\n&#123; D  obj(2,4,6,8); return 0; &#125;\n</code></pre>\n<p>任何一个类的上层（不一定是直接继承虚基类），只要含有虚基类都要再构造函数中调用虚基类的构造函数。</p>\n<pre><code class=\"cpp\">//运行结果\n//Constructing B\n//Constructing B1\n//Constructing B2\n//Constructing D\n</code></pre>\n<p>若同一层次中同时包含虚基类和非虚基类,应先调用虚基类的构造函数,再调用非虚基类的构造函数,最后调用派生类构造函数;</p>\n<pre><code class=\"cpp\"> class X∶public Y，virtual public Z&#123;\n        //…\n    &#125;；\n    X  one；\n    定义类X的对象one后，将产生如下的调用次序。\n    Z( )；\n    Y( )；\n    X( )；\n</code></pre>\n<h6 id=\"扩展：怎么看这个类在内存中的情况\"><a href=\"#扩展：怎么看这个类在内存中的情况\" class=\"headerlink\" title=\"扩展：怎么看这个类在内存中的情况\"></a>扩展：怎么看这个类在内存中的情况</h6><p>1.按win，然后点开VS2019的开发者命令提示工具，cd到自己代码的上一级目录</p>\n<p>2.通过<code>cl /d1 reportSingleClassLayoutSheepTuo test01.cpp</code>来访问</p>\n<pre><code class=\"cpp\">class Animal\n&#123;\npublic:\n    int m_Age;\n&#125;;\n//virtual加上后，继承方式数据虚继承\n//Animal类 变为 虚基类\n//羊类\nclass Sheep : virtual public Animal\n&#123;...&#125;;\n//驼类\nclass Tuo : virtual public Animal\n&#123;...&#125;;\n//羊驼类\nclass SheepTuo : public Sheep, public Tuo\n&#123;...&#125;;\n//虚继承内部工作原理\nvoid test02()\n&#123;\n    SheepTuo st;\n    st.m_Age = 100;\n\n    //通过sheep找到偏移量的值\n    cout &lt;&lt; &quot;通过sheep找到的偏移量为：&quot; &lt;&lt; *(int*)((int*)*(int*)&amp;st + 1) &lt;&lt; endl;\n\n    //通过tuo找到偏移量的值\n    cout &lt;&lt; &quot;通过tuo找到的偏移量为：&quot; &lt;&lt; *(int*)((int*)*((int*)&amp;st + 1) + 1) &lt;&lt; endl;\n\n    //通过偏移量求出m_Age的值\n    cout &lt;&lt; &quot;通过偏移量求出m_Age的值：&quot; &lt;&lt; ((Animal*)((char*)&amp;st + (*(int*)((int*)*(int*)&amp;st + 1))))-&gt;m_Age &lt;&lt; endl;\n&#125;\n</code></pre>\n","categories":["C++","基础知识"],"tags":["常识","C++"]}]